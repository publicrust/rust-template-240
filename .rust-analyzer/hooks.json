[
  {
    "HookSignature": "OnClientDisconnect(Network.Connection cn, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Connection cn)",
    "MethodSourseCode": "\n\tprotected void OnDisconnected(string strReason, Connection cn)\n\t{\n\t\tif (cn != null)\n\t\t{\n\t\t\tcn.connected = false;\n\t\t\tcn.active = false;\n\t\t\tif (callbackHandler != null)\n\t\t\t{\n\t\t\t\tcallbackHandler.OnDisconnected(strReason, cn);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnClientDisconnect\u0022, cn, strReason);\n\t\t\tRemoveConnection(cn);\n\t\t}\n\t}\n",
    "ClassName": "Server",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRconCommand(? connectionUserEndPoint, string text, string[] array2)",
    "MethodSignature": "OnMessage(MessageEventArgs e, WebSocketContext connection)",
    "MethodSourseCode": "\n\tprivate void OnMessage(MessageEventArgs e, WebSocketContext connection)\n\t{\n\t\tif (covalence == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, Covalence is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tRemoteMessage message = RemoteMessage.GetMessage(e.Data);\n\t\tif (message == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (string.IsNullOrEmpty(message.Message))\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage.Text is not set\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring[] array = CommandLine.Split(message.Message);\n\t\tstring text = array[0].ToLower();\n\t\tstring[] array2 = array.Skip(1).ToArray();\n\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, connection.UserEndPoint, text, array2) == null)\n\t\t{\n\t\t\tIServer obj = covalence.Server;\n\t\t\tobject[] args = array2;\n\t\t\tobj.Command(text, args);\n\t\t}\n\t}\n",
    "ClassName": "RemoteConsole",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupPermissionGranted(string groupName, string permission)",
    "MethodSignature": "GrantGroupPermission(string groupName, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantGroupPermission\u0022)]\n\tpublic void GrantGroupPermission(string groupName, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner) || !GroupExists(groupName) || !groupsData.TryGetValue(groupName, out var groupData))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t}\n\t\telse if (groupData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionGranted\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnUserGroupRemoved(string playerId, string groupName)",
    "MethodSignature": "RemoveUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveUserGroup\u0022)]\n\tpublic void RemoveUserGroup(string playerId, string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (groupName.Equals(\u0022*\u0022))\n\t\t{\n\t\t\tif (userData.Groups.Count \u003E 0)\n\t\t\t{\n\t\t\t\tuserData.Groups.Clear();\n\t\t\t}\n\t\t}\n\t\telse if (userData.Groups.Remove(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupRemoved\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "Init()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tforeach (string key in Hooks.Keys)\n\t\t{\n\t\t\tSubscribe(key);\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Init\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tif (base.Loader != null)\n\t\t\t{\n\t\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSPlugin",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnGroupCreated(string groupName, string groupTitle, int groupRank)",
    "MethodSignature": "CreateGroup(string groupName, string groupTitle, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022CreateGroup\u0022)]\n\tpublic bool CreateGroup(string groupName, string groupTitle, int groupRank)\n\t{\n\t\tif (GroupExists(groupName) || string.IsNullOrEmpty(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tGroupData value = new GroupData\n\t\t{\n\t\t\tTitle = groupTitle,\n\t\t\tRank = groupRank\n\t\t};\n\t\tgroupsData.Add(groupName, value);\n\t\tInterface.CallHook(\u0022OnGroupCreated\u0022, groupName, groupTitle, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnGroupDeleted(string groupName)",
    "MethodSignature": "RemoveGroup(string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveGroup\u0022)]\n\tpublic bool RemoveGroup(string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = groupsData.Remove(groupName);\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (GroupData item in groupsData.Values.Where((GroupData g) =\u003E g.ParentGroup == groupName))\n\t\t\t{\n\t\t\t\titem.ParentGroup = string.Empty;\n\t\t\t}\n\t\t}\n\t\tif (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) =\u003E current | userData.Groups.Remove(groupName)))\n\t\t{\n\t\t\tSaveUsers();\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGroupDeleted\u0022, groupName);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupTitleSet(string groupName, string groupTitle)",
    "MethodSignature": "SetGroupTitle(string groupName, string groupTitle)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupTitle\u0022)]\n\tpublic bool SetGroupTitle(string groupName, string groupTitle)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Title == groupTitle)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Title = groupTitle;\n\t\tInterface.CallHook(\u0022OnGroupTitleSet\u0022, groupName, groupTitle);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnGroupPermissionRevoked(string groupName, string permission)",
    "MethodSignature": "RevokeGroupPermission(string groupName, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeGroupPermission\u0022)]\n\tpublic void RevokeGroupPermission(string groupName, string permission)\n\t{\n\t\tif (!GroupExists(groupName) || string.IsNullOrEmpty(permission) || !groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (value.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tvalue.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (value.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionRevoked\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "LoadDefaultMessages()",
    "MethodSignature": "LoadDefaultMessages()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultMessages()\n\t{\n\t\tCallHook(\u0022LoadDefaultMessages\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGroupRankSet(string groupName, int groupRank)",
    "MethodSignature": "SetGroupRank(string groupName, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupRank\u0022)]\n\tpublic bool SetGroupRank(string groupName, int groupRank)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Rank == groupRank)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Rank = groupRank;\n\t\tInterface.CallHook(\u0022OnGroupRankSet\u0022, groupName, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)",
    "MethodSignature": "RegisterPermission(string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RegisterPermission\u0022)]\n\tpublic void RegisterPermission(string permission, Plugin owner)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (PermissionExists(permission))\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Duplicate permission registered \u0027{0}\u0027 (by plugin \u0027{1}\u0027)\u0022, permission, owner.Title);\n\t\t\treturn;\n\t\t}\n\t\tif (!registeredPermissions.TryGetValue(owner, out var value))\n\t\t{\n\t\t\tvalue = new HashSet\u003Cstring\u003E(StringComparer.OrdinalIgnoreCase);\n\t\t\tregisteredPermissions.Add(owner, value);\n\t\t\towner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);\n\t\t}\n\t\tvalue.Add(permission);\n\t\tInterface.CallHook(\u0022OnPermissionRegistered\u0022, permission, owner);\n\t\tif (!permission.StartsWith(owner.Name \u002B \u0022.\u0022, StringComparison.OrdinalIgnoreCase) \u0026\u0026 !owner.IsCorePlugin)\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Missing plugin name prefix \u0027{0}\u0027 for permission \u0027{1}\u0027 (by plugin \u0027{2}\u0027)\u0022, owner.Name.ToLower(), permission, owner.Title);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnUserPermissionRevoked(string playerId, string permission)",
    "MethodSignature": "RevokeUserPermission(string playerId, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeUserPermission\u0022)]\n\tpublic void RevokeUserPermission(string playerId, string permission)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (userData.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tuserData.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuserData.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (userData.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionRevoked\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnPluginLoaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "PluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\tpublic bool PluginLoaded(Plugin plugin)\n\t{\n\t\tplugin.OnError \u002B= plugin_OnError;\n\t\ttry\n\t\t{\n\t\t\tplugin.Loader?.PluginErrors.Remove(plugin.Name);\n\t\t\tRootPluginManager.AddPlugin(plugin);\n\t\t\tif (plugin.Loader != null \u0026\u0026 plugin.Loader.PluginErrors.ContainsKey(plugin.Name))\n\t\t\t{\n\t\t\t\tUnloadPlugin(plugin.Name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tplugin.IsLoaded = true;\n\t\t\tCallHook(\u0022OnPluginLoaded\u0022, plugin);\n\t\t\tLogInfo(\u0022Loaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tif (plugin.Loader != null)\n\t\t\t{\n\t\t\t\tplugin.Loader.PluginErrors[plugin.Name] = ex.Message;\n\t\t\t}\n\t\t\tLogException($\u0022Could not initialize plugin \u0027{plugin.Name} v{plugin.Version}\u0027\u0022, ex);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnUserGroupAdded(string playerId, string groupName)",
    "MethodSignature": "AddUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022AddUserGroup\u0022)]\n\tpublic void AddUserGroup(string playerId, string groupName)\n\t{\n\t\tif (GroupExists(groupName) \u0026\u0026 GetUserData(playerId).Groups.Add(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupAdded\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "LoadDefaultConfig()",
    "MethodSignature": "LoadDefaultConfig()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultConfig()\n\t{\n\t\tCallHook(\u0022LoadDefaultConfig\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGroupParentSet(string groupName, string parentGroupName)",
    "MethodSignature": "SetGroupParent(string groupName, string parentGroupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupParent\u0022)]\n\tpublic bool SetGroupParent(string groupName, string parentGroupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (string.IsNullOrEmpty(parentGroupName))\n\t\t{\n\t\t\tvalue.ParentGroup = null;\n\t\t\treturn true;\n\t\t}\n\t\tif (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(value.ParentGroup) \u0026\u0026 value.ParentGroup.Equals(parentGroupName))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (HasCircularParent(groupName, parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvalue.ParentGroup = parentGroupName;\n\t\tInterface.CallHook(\u0022OnGroupParentSet\u0022, groupName, parentGroupName);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnPluginUnloaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "UnloadPlugin(string name)",
    "MethodSourseCode": "\n\tpublic bool UnloadPlugin(string name)\n\t{\n\t\tPlugin plugin = RootPluginManager.GetPlugin(name);\n\t\tif (plugin == null || (plugin.IsCorePlugin \u0026\u0026 !IsShuttingDown))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\textensionManager.GetPluginLoaders().SingleOrDefault((PluginLoader l) =\u003E l.LoadedPlugins.ContainsKey(name))?.Unloading(plugin);\n\t\tRootPluginManager.RemovePlugin(plugin);\n\t\tif (plugin.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022OnPluginUnloaded\u0022, plugin);\n\t\t}\n\t\tplugin.IsLoaded = false;\n\t\tLogInfo(\u0022Unloaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\treturn true;\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnUserPermissionGranted(string playerId, string permission)",
    "MethodSignature": "GrantUserPermission(string playerId, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantUserPermission\u0022)]\n\tpublic void GrantUserPermission(string playerId, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t}\n\t\telse if (userData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionGranted\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnUserNameUpdated(string playerId, string lastSeenNickname, string obj)",
    "MethodSignature": "UpdateNickname(string playerId, string playerName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022UpdateNickname\u0022)]\n\tpublic void UpdateNickname(string playerId, string playerName)\n\t{\n\t\tif (UserExists(playerId))\n\t\t{\n\t\t\tUserData userData = GetUserData(playerId);\n\t\t\tstring lastSeenNickname = userData.LastSeenNickname;\n\t\t\tstring obj = playerName.Sanitize();\n\t\t\tuserData.LastSeenNickname = playerName.Sanitize();\n\t\t\tInterface.CallHook(\u0022OnUserNameUpdated\u0022, playerId, lastSeenNickname, obj);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnDiscordClientCreated()",
    "MethodSignature": "OnPluginAdded(Plugin plugin)",
    "MethodSourseCode": "\n\tinternal static void OnPluginAdded(Plugin plugin)\n\t{\n\t\tOnPluginRemoved(plugin);\n\t\tFieldInfo[] fields = plugin.GetType().GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);\n\t\tforeach (FieldInfo fieldInfo in fields)\n\t\t{\n\t\t\tif (fieldInfo.GetCustomAttributes(typeof(DiscordClientAttribute), inherit: true).Length != 0)\n\t\t\t{\n\t\t\t\tDiscordClient discordClient = Clients[plugin.Name];\n\t\t\t\tif (discordClient == null)\n\t\t\t\t{\n\t\t\t\t\tDiscordExtension.GlobalLogger.Debug(\u0022DiscordClient.OnPluginAdded Creating DiscordClient for plugin \u0022 \u002B plugin.Name);\n\t\t\t\t\tdiscordClient = new DiscordClient(plugin);\n\t\t\t\t\tClients[plugin.Name] = discordClient;\n\t\t\t\t}\n\t\t\t\tfieldInfo.SetValue(plugin, discordClient);\n\t\t\t\tplugin.Call(\u0022OnDiscordClientCreated\u0022);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDiscordExtension.DiscordCommand.ProcessPluginCommands(plugin);\n\t}\n",
    "ClassName": "DiscordClient",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnDiscordClientDisconnected(Oxide.Core.Plugins.Plugin Owner, Oxide.Ext.Discord.DiscordClient oxide.Ext.Discord.DiscordClient)",
    "MethodSignature": "Disconnect()",
    "MethodSourseCode": "\n\tpublic void Disconnect()\n\t{\n\t\tInterface.Call(\u0022OnDiscordClientDisconnected\u0022, Owner, this);\n\t\tBot?.RemoveClient(this);\n\t}\n",
    "ClassName": "DiscordClient",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDiscordClientConnected(Oxide.Core.Plugins.Plugin Owner, Oxide.Ext.Discord.DiscordClient oxide.Ext.Discord.DiscordClient)",
    "MethodSignature": "Connect(DiscordSettings settings)",
    "MethodSourseCode": "\n\tpublic void Connect(DiscordSettings settings)\n\t{\n\t\tSettings = settings ?? throw new ArgumentNullException(\u0022settings\u0022);\n\t\tLogger = new Logger(settings.LogLevel);\n\t\tif (string.IsNullOrEmpty(Settings.ApiToken))\n\t\t{\n\t\t\tLogger.Error(\u0022API Token is null or empty!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!TokenValidator.IsMatch(Settings.ApiToken))\n\t\t{\n\t\t\tLogger.Warning(\u0022API Token does not appear to be a valid discord bot token: \u0022 \u002B Settings.GetHiddenToken() \u002B \u0022. Please confirm you are using the correct bot token. If the token is correct and this message is showing please let the Discord Extension Developers know.\u0022);\n\t\t}\n\t\tif (!string.IsNullOrEmpty(\u0022\u0022))\n\t\t{\n\t\t\tLogger.Warning(\u0022Using Discord Test Version: \u0022 \u002B DiscordExtension.GetExtensionVersion);\n\t\t}\n\t\tLogger.Debug(\u0022DiscordClient.Connect GetOrCreate bot for \u0022 \u002B Owner.Name);\n\t\tBot = BotClient.GetOrCreate(this);\n\t\tRegisterPluginForHooks(Owner);\n\t\tInterface.Call(\u0022OnDiscordClientConnected\u0022, Owner, this);\n\t}\n",
    "ClassName": "DiscordClient",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "Internal(Arg arg)",
    "MethodSourseCode": "\n\tprivate static bool Internal(Arg arg)\n\t{\n\t\tif (arg.Invalid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnServerCommand\u0022, arg);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!arg.HasPermission())\n\t\t{\n\t\t\targ.ReplyWith(\u0022You cannot run this command\u0022);\n\t\t\treturn false;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022ConsoleSystem: \u0022 \u002B arg.cmd.FullName))\n\t\t\t{\n\t\t\t\targ.cmd.Call(arg);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Error: \u0022 \u002B arg.cmd.FullName \u002B \u0022 - \u0022 \u002B ex.Message \u002B \u0022 (\u0022 \u002B ex.Source \u002B \u0022)\u0022);\n\t\t\tDebug.LogException(ex);\n\t\t\treturn false;\n\t\t}\n\t\tif (arg.cmd.Variable \u0026\u0026 arg.cmd.GetOveride != null \u0026\u0026 string.IsNullOrWhiteSpace(arg.Reply))\n\t\t{\n\t\t\tstring @string = arg.cmd.String;\n\t\t\tstring text = (arg.cmd.Variable ? arg.cmd.String : \u0022\u0022);\n\t\t\tif (text != @string)\n\t\t\t{\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "IOnRunCommandLine()",
    "MethodSignature": "UpdateValuesFromCommandLine()",
    "MethodSourseCode": "\n\tpublic static void UpdateValuesFromCommandLine()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRunCommandLine\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (KeyValuePair\u003Cstring, string\u003E @switch in Facepunch.CommandLine.GetSwitches())\n\t\t{\n\t\t\tstring text = @switch.Value;\n\t\t\tif (text == \u0022\u0022)\n\t\t\t{\n\t\t\t\ttext = \u00221\u0022;\n\t\t\t}\n\t\t\tstring strCommand = @switch.Key.Substring(1);\n\t\t\tRun(Option.Unrestricted, strCommand, text);\n\t\t}\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "Loaded()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tif (base.Filename != null)\n\t\t{\n\t\t\tWatcher.AddMapping(base.Name);\n\t\t}\n\t\tbase.Manager.OnPluginAdded \u002B= OnPluginLoaded;\n\t\tbase.Manager.OnPluginRemoved \u002B= OnPluginUnloaded;\n\t\tforeach (KeyValuePair\u003Cstring, MemberInfo\u003E pluginReferenceMember in pluginReferenceMembers)\n\t\t{\n\t\t\tif (pluginReferenceMember.Value.MemberType == MemberTypes.Property)\n\t\t\t{\n\t\t\t\t((PropertyInfo)pluginReferenceMember.Value).SetValue(this, manager.GetPlugin(pluginReferenceMember.Key), null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((FieldInfo)pluginReferenceMember.Value).SetValue(this, manager.GetPlugin(pluginReferenceMember.Key));\n\t\t\t}\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Loaded\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t}\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnFrame(object[] args)",
    "MethodSignature": "OnFrame(float delta)",
    "MethodSourseCode": "\n\tprivate void OnFrame(float delta)\n\t{\n\t\tobject[] args = new object[1] { delta };\n\t\tforeach (KeyValuePair\u003Cstring, Plugin\u003E loadedPlugin in loader.LoadedPlugins)\n\t\t{\n\t\t\tif (loadedPlugin.Value is CSharpPlugin { HookedOnFrame: not false } cSharpPlugin)\n\t\t\t{\n\t\t\t\tcSharpPlugin.CallHook(\u0022OnFrame\u0022, args);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSharpExtension",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "Unload()",
    "MethodSignature": "HandleRemovedFromManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleRemovedFromManager(PluginManager manager)\n\t{\n\t\tif (base.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022Unload\u0022, null);\n\t\t}\n\t\tWatcher.RemoveMapping(base.Name);\n\t\tbase.Manager.OnPluginAdded -= OnPluginLoaded;\n\t\tbase.Manager.OnPluginRemoved -= OnPluginUnloaded;\n\t\tforeach (KeyValuePair\u003Cstring, MemberInfo\u003E pluginReferenceMember in pluginReferenceMembers)\n\t\t{\n\t\t\tif (pluginReferenceMember.Value.MemberType == MemberTypes.Property)\n\t\t\t{\n\t\t\t\t((PropertyInfo)pluginReferenceMember.Value).SetValue(this, null, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((FieldInfo)pluginReferenceMember.Value).SetValue(this, null);\n\t\t\t}\n\t\t}\n\t\tbase.HandleRemovedFromManager(manager);\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tTechTreeData.NodeInstance byID = techTree.GetByID(num);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTree.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTree.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint num2 = ResearchTable.ScrapForResearch(byID.itemDef);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num2)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num2);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "OnMeleeAttack(BasePlayer player, HitInfo hitInfo)",
    "MethodSignature": "PlayerAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tpublic void PlayerAttack(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerAttack\u0022, 50))\n\t\t{\n\t\t\tusing PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);\n\t\t\tif (playerAttack == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHitInfo hitInfo = Facepunch.Pool.Get\u003CHitInfo\u003E();\n\t\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\t\thitInfo.Initiator = player;\n\t\t\thitInfo.Weapon = this;\n\t\t\thitInfo.WeaponPrefab = this;\n\t\t\thitInfo.Predicted = msg.connection;\n\t\t\thitInfo.damageProperties = damageProperties;\n\t\t\tif (Interface.CallHook(\u0022OnMeleeAttack\u0022, player, hitInfo) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hitInfo.IsNaNOrInfinity())\n\t\t\t{\n\t\t\t\tstring shortPrefabName = base.ShortPrefabName;\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_nan\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity hitEntity = hitInfo.HitEntity;\n\t\t\tBasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;\n\t\t\tbool flag = basePlayer != null;\n\t\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\t\tbool flag5 = hitEntity != null;\n\t\t\tbool flag6 = flag5 \u0026\u0026 hitEntity.IsNpc;\n\t\t\tif (ConVar.AntiHack.melee_protection \u003E 0)\n\t\t\t{\n\t\t\t\tbool flag7 = true;\n\t\t\t\tfloat num = 1f \u002B ConVar.AntiHack.melee_forgiveness;\n\t\t\t\tfloat melee_clientframes = ConVar.AntiHack.melee_clientframes;\n\t\t\t\tfloat melee_serverframes = ConVar.AntiHack.melee_serverframes;\n\t\t\t\tfloat num2 = melee_clientframes / 60f;\n\t\t\t\tfloat num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\t\tfloat num4 = (player.desyncTimeClamped \u002B num2 \u002B num3) * num;\n\t\t\t\tint layerMask = (ConVar.AntiHack.melee_terraincheck ? 10551296 : 2162688);\n\t\t\t\tif (flag \u0026\u0026 hitInfo.boneArea == (HitArea)(-1))\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\n\t\t\t\t\tstring shortPrefabName3 = basePlayer.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Bone is invalid  (\u0022 \u002B shortPrefabName2 \u002B \u0022 on \u0022 \u002B shortPrefabName3 \u002B \u0022 bone \u0022 \u002B hitInfo.HitBone \u002B \u0022)\u0022);\n\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_bone\u0022);\n\t\t\t\t\tflag7 = false;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 2)\n\t\t\t\t{\n\t\t\t\t\tif (flag5)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num5 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num6 = hitEntity.BoundsPadding() \u002B num4 * num5;\n\t\t\t\t\t\tfloat num7 = hitEntity.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num7 \u003E num6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName5 = hitEntity.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Entity too far away (\u0022 \u002B shortPrefabName4 \u002B \u0022 on \u0022 \u002B shortPrefabName5 \u002B \u0022 with \u0022 \u002B num7 \u002B \u0022m \u003E \u0022 \u002B num6 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_target\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4 \u0026\u0026 flag7 \u0026\u0026 flag \u0026\u0026 !flag6 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num8 = basePlayer.BoundsPadding() \u002B num4 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\t\tfloat num9 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num9 \u003E num8)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName7 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Player too far away (\u0022 \u002B shortPrefabName6 \u002B \u0022 on \u0022 \u002B shortPrefabName7 \u002B \u0022 with \u0022 \u002B num9 \u002B \u0022m \u003E \u0022 \u002B num8 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022player_distance\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 1)\n\t\t\t\t{\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude2 = player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num10 = player.BoundsPadding() \u002B num4 * magnitude2 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num11 = player.tickHistory.Distance(player, hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num11 \u003E num10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName8 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName8 \u002B \u0022 on \u0022 \u002B text \u002B \u0022 with \u0022 \u002B num11 \u002B \u0022m \u003E \u0022 \u002B num10 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num12 = player.MaxVelocity() \u002B player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num13 = player.BoundsPadding() \u002B num4 * num12 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num14 = player.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num14 \u003E num13)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName9 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text2 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName9 \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num13 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 3)\n\t\t\t\t{\n\t\t\t\t\tif (flag5)\n\t\t\t\t\t{\n\t\t\t\t\t\tVector3 pointStart = hitInfo.PointStart;\n\t\t\t\t\t\tVector3 vector = hitInfo.HitPositionWorld \u002B hitInfo.HitNormalWorld.normalized * 0.001f;\n\t\t\t\t\t\tVector3 center = player.eyes.center;\n\t\t\t\t\t\tVector3 position = player.eyes.position;\n\t\t\t\t\t\tVector3 vector2 = pointStart;\n\t\t\t\t\t\tVector3 vector3 = hitInfo.PositionOnRay(vector);\n\t\t\t\t\t\tVector3 vector4 = vector;\n\t\t\t\t\t\tbool num15 = GamePhysics.LineOfSight(center, position, vector2, vector3, vector4, layerMask);\n\t\t\t\t\t\tif (!num15)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!num15)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName10 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName11 = hitEntity.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName10, \u0022 on \u0022, shortPrefabName11, \u0022) \u0022, center, \u0022 \u0022, position, \u0022 \u0022, vector2, \u0022 \u0022, vector3, \u0022 \u0022, vector4));\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_los\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag7 \u0026\u0026 flag \u0026\u0026 !flag6)\n\t\t\t\t\t{\n\t\t\t\t\t\tVector3 vector5 = hitInfo.HitPositionWorld \u002B hitInfo.HitNormalWorld.normalized * 0.001f;\n\t\t\t\t\t\tVector3 position2 = basePlayer.eyes.position;\n\t\t\t\t\t\tVector3 vector6 = basePlayer.CenterPoint();\n\t\t\t\t\t\tif ((!GamePhysics.LineOfSight(vector5, position2, layerMask, 0f, ConVar.AntiHack.losforgiveness) || !GamePhysics.LineOfSight(position2, vector5, layerMask, ConVar.AntiHack.losforgiveness, 0f)) \u0026\u0026 (!GamePhysics.LineOfSight(vector5, vector6, layerMask, 0f, ConVar.AntiHack.losforgiveness) || !GamePhysics.LineOfSight(vector6, vector5, layerMask, ConVar.AntiHack.losforgiveness, 0f)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName12 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName13 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName12, \u0022 on \u0022, shortPrefabName13, \u0022) \u0022, vector5, \u0022 \u0022, position2, \u0022 or \u0022, vector5, \u0022 \u0022, vector6));\n\t\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_los\u0022);\n\t\t\t\t\t\t\tflag7 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag7)\n\t\t\t\t{\n\t\t\t\t\tAntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplayer.metabolism.UseHeart(heartStress * 0.2f);\n\t\t\tusing (TimeWarning.New(\u0022DoAttackShared\u0022, 50))\n\t\t\t{\n\t\t\t\tDoAttackShared(hitInfo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnPlayerDropActiveItem(BasePlayer player, Item activeItem)",
    "MethodSignature": "DropActive(Vector3 position, Vector3 velocity)",
    "MethodSourseCode": "\n\tpublic void DropActive(Vector3 position, Vector3 velocity)\n\t{\n\t\tItem activeItem = player.GetActiveItem();\n\t\tif (activeItem == null || Interface.CallHook(\u0022OnPlayerDropActiveItem\u0022, player, activeItem) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerBelt.DropActive\u0022))\n\t\t{\n\t\t\tactiveItem.Drop(position, velocity);\n\t\t\tplayer.svActiveItemID = 0u;\n\t\t\tplayer.SendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PlayerBelt",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEngineStopped(VehicleEngineController vehicleEngineController)",
    "MethodSignature": "StopEngine()",
    "MethodSourseCode": "\n\tpublic void StopEngine()\n\t{\n\t\tif (isServer \u0026\u0026 CurEngineState != 0 \u0026\u0026 Interface.CallHook(\u0022OnEngineStop\u0022, this) == null)\n\t\t{\n\t\t\tCancelEngineStart();\n\t\t\towner.SetFlag(BaseEntity.Flags.On, b: false);\n\t\t\towner.SetFlag(engineStartingFlag, b: false);\n\t\t\tInterface.CallHook(\u0022OnEngineStopped\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "VehicleEngineController",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEventTrigger(TriggeredEventPrefab triggeredEventPrefab)",
    "MethodSignature": "RunEvent()",
    "MethodSourseCode": "\n\tprivate void RunEvent()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEventTrigger\u0022, this) == null)\n\t\t{\n\t\t\tDebug.Log(\u0022[event] \u0022 \u002B targetPrefab.resourcePath);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SendMessage(\u0022TriggeredEventSpawn\u0022, SendMessageOptions.DontRequireReceiver);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggeredEventPrefab",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "RPC_LootCorpse(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_LootCorpse(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanLoot() \u0026\u0026 containers != null \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tItemContainer[] array = containers;\n\t\t\tforeach (ItemContainer container in array)\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(container);\n\t\t\t}\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tClientRPCPlayer(null, player, \u0022RPC_ClientLootCorpse\u0022);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFuelAmountCheck(EntityFuelSystem entityFuelSystem, Item fuelItem)",
    "MethodSignature": "GetFuelAmount()",
    "MethodSourseCode": "\n\tpublic int GetFuelAmount()\n\t{\n\t\tItem fuelItem = GetFuelItem();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelAmountCheck\u0022, this, fuelItem);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelItem == null || fuelItem.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn fuelItem.amount;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnResearchCostDetermine(ItemDefinition info)",
    "MethodSignature": "ScrapForResearch(ItemDefinition info)",
    "MethodSourseCode": "\n\tpublic static int ScrapForResearch(ItemDefinition info)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, info);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint result = 0;\n\t\tif (info.rarity == Rarity.Common)\n\t\t{\n\t\t\tresult = 20;\n\t\t}\n\t\tif (info.rarity == Rarity.Uncommon)\n\t\t{\n\t\t\tresult = 75;\n\t\t}\n\t\tif (info.rarity == Rarity.Rare)\n\t\t{\n\t\t\tresult = 125;\n\t\t}\n\t\tif (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)\n\t\t{\n\t\t\tresult = 500;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenCooked(BaseOven baseOven, Item item, BaseEntity slot)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tbase.inventory.OnCycle(0.5f);\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tItemModBurnable component = item.info.GetComponent\u003CItemModBurnable\u003E();\n\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t{\n\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\titem.MarkDirty();\n\t\t}\n\t\tif (item.fuel \u003C= 0f)\n\t\t{\n\t\t\tConsumeFuel(item, component);\n\t\t}\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "CanHideStash(BasePlayer rpcPlayer, StashContainer stashContainer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRemoveDying(GrowableEntity growableEntity, BasePlayer receiver)",
    "MethodSignature": "RemoveDying(BasePlayer receiver)",
    "MethodSourseCode": "\n\tpublic void RemoveDying(BasePlayer receiver)\n\t{\n\t\tif (State == PlantProperties.State.Dying \u0026\u0026 !(Properties.removeDyingItem == null) \u0026\u0026 Interface.CallHook(\u0022OnRemoveDying\u0022, this, receiver) == null)\n\t\t{\n\t\t\tif (Properties.removeDyingEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);\n\t\t\tif (receiver != null)\n\t\t\t{\n\t\t\t\treceiver.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t\t}\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNetworkTo(BaseNetworkable baseNetworkable, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (net.group == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn player.net.subscriber.IsSubscribed(net.group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDeath(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Die(HitInfo info = null)\n\t{\n\t\tusing (TimeWarning.New(\u0022Player.Die\u0022))\n\t\t{\n\t\t\tif (!IsDead())\n\t\t\t{\n\t\t\t\tif (Belt != null \u0026\u0026 ShouldDropActiveItem())\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\n\t\t\t\t\tBelt.DropActive(GetDropPosition(), GetInheritedDropVelocity() \u002B vector.normalized * 3f);\n\t\t\t\t}\n\t\t\t\tif (!WoundInsteadOfDying(info) \u0026\u0026 Interface.CallHook(\u0022OnPlayerDeath\u0022, this, info) == null)\n\t\t\t\t{\n\t\t\t\t\tbase.Die(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnCorpsePopulate(HTNPlayer target, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "OnCreateCorpse(HTNPlayer target)",
    "MethodSourseCode": "\n\tpublic override BaseCorpse OnCreateCorpse(HTNPlayer target)\n\t{\n\t\tif (DeathEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(DeathEffect.resourcePath, target, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = target.DropCorpse(\u0022assets/prefabs/npc/scientist/scientist_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tif (target.AiDomain != null \u0026\u0026 target.AiDomain.NavAgent != null \u0026\u0026 target.AiDomain.NavAgent.isOnNavMesh)\n\t\t\t\t{\n\t\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * target.AiDomain.NavAgent.baseOffset;\n\t\t\t\t}\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved5, target.HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(target.inventory.containerMain, target.inventory.containerWear, target.inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = target.displayName;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = target.userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tnPCPlayerCorpse.TakeChildren(target);\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t\tif (Loot.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, target, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] loot = Loot;\n\t\t\t\t\tfor (int i = 0; i \u003C loot.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = loot[i];\n\t\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlot.numberToSpawn; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "ScientistJunkpileDefinition",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerRecovered(BasePlayer basePlayer)",
    "MethodSignature": "WoundingTick()",
    "MethodSourseCode": "\n\tprivate void WoundingTick()\n\t{\n\t\tusing (TimeWarning.New(\u0022WoundingTick\u0022))\n\t\t{\n\t\t\tif (IsDead())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (secondsSinceWoundedStarted \u003E= woundedDuration)\n\t\t\t{\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 20)\n\t\t\t\t{\n\t\t\t\t\tRecoverFromWounded();\n\t\t\t\t\tInterface.CallHook(\u0022OnPlayerRecovered\u0022, this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDie();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInvoke(WoundingTick, 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnLiftUse(Lift lift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tMoveUp();\n\t\t}\n\t}\n",
    "ClassName": "Lift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnHorseUnhitch(RidableHorse horse, HitchTrough.HitchSpot hitchSpot)",
    "MethodSignature": "Unhitch(RidableHorse horse)",
    "MethodSourseCode": "\n\tpublic void Unhitch(RidableHorse horse)\n\t{\n\t\tHitchSpot[] array = hitchSpots;\n\t\tforeach (HitchSpot hitchSpot in array)\n\t\t{\n\t\t\tif (hitchSpot.GetHorse(base.isServer) == horse)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnHorseUnhitch\u0022, horse, hitchSpot) != null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thitchSpot.SetOccupiedBy(null);\n\t\t\t\thorse.SetHitch(null);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "CanDropCrate()",
    "MethodSourseCode": "\n\tpublic bool CanDropCrate()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterDropCrate\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003E 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterUseNapalm(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanUseNapalm()",
    "MethodSourseCode": "\n\tpublic bool CanUseNapalm()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterUseNapalm\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn UnityEngine.Time.realtimeSinceStartup - lastNapalmTime \u003E= 30f;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, ModularCarSeat modularCarSeat)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (associatedSeatingModule.DoorsAreLockable)\n\t\t{\n\t\t\tModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;\n\t\t\tif (modularCar != null)\n\t\t\t{\n\t\t\t\treturn modularCar.PlayerCanUseThis(player, ModularCarLock.LockType.Door);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ModularCarSeat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMarkHostile(BaseCombatEntity baseCombatEntity, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic virtual void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tfloat b = UnityEngine.Time.realtimeSinceStartup \u002B duration;\n\t\t\tunHostileTime = Mathf.Max(unHostileTime, b);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDefaultItemsReceive(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tulong skin = 0uL;\n\t\tint infoInt = base.baseEntity.GetInfoInt(\u0022client.rockskin\u0022, 0);\n\t\tif (infoInt \u003E 0 \u0026\u0026 base.baseEntity.blueprints.steamInventory.HasItem(infoInt))\n\t\t{\n\t\t\tIPlayerItemDefinition itemDefinition = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\tif (itemDefinition != null)\n\t\t\t{\n\t\t\t\tskin = itemDefinition.WorkshopDownload;\n\t\t\t}\n\t\t}\n\t\tGiveItem(ItemManager.CreateByName(\u0022rock\u0022, 1, skin), containerBelt);\n\t\tGiveItem(ItemManager.CreateByName(\u0022torch\u0022, 1, 0uL), containerBelt);\n\t\tif (IsBirthday())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL), containerWear);\n\t\t}\n\t\tif (IsChristmas())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityFlagsNetworkUpdate(BaseEntity baseEntity)",
    "MethodSignature": "SendNetworkUpdate_Flags()",
    "MethodSourseCode": "\n\tprotected void SendNetworkUpdate_Flags()\n\t{\n\t\tif (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendNetworkUpdate_Flags\u0022))\n\t\t{\n\t\t\tLogEntry(LogEntryType.Network, 2, \u0022SendNetworkUpdate_Flags\u0022);\n\t\t\tif (Interface.CallHook(\u0022OnEntityFlagsNetworkUpdate\u0022, this) == null)\n\t\t\t{\n\t\t\t\tList\u003CConnection\u003E subscribers = GetSubscribers();\n\t\t\t\tif (subscribers != null \u0026\u0026 subscribers.Count \u003E 0 \u0026\u0026 Network.Net.sv.write.Start())\n\t\t\t\t{\n\t\t\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.EntityFlags);\n\t\t\t\t\tNetwork.Net.sv.write.EntityID(net.ID);\n\t\t\t\t\tNetwork.Net.sv.write.Int32((int)flags);\n\t\t\t\t\tSendInfo info = new SendInfo(subscribers);\n\t\t\t\t\tNetwork.Net.sv.write.Send(info);\n\t\t\t\t}\n\t\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_RotateVM(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RotateVM(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRotateVendingMachine\u0022, this, msg.player) == null \u0026\u0026 CanRotate())\n\t\t{\n\t\t\tUpdateEmptyFlag();\n\t\t\tif (msg.player.CanBuild() \u0026\u0026 IsInventoryEmpty())\n\t\t\t{\n\t\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerHealthChange(BasePlayer basePlayer, float oldvalue, float newvalue)",
    "MethodSignature": "OnHealthChanged(float oldvalue, float newvalue)",
    "MethodSourseCode": "\n\tpublic override void OnHealthChanged(float oldvalue, float newvalue)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerHealthChange\u0022, this, oldvalue, newvalue) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbase.OnHealthChanged(oldvalue, newvalue);\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (oldvalue \u003E newvalue)\n\t\t\t{\n\t\t\t\tLifeStoryHurt(oldvalue - newvalue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLifeStoryHeal(newvalue - oldvalue);\n\t\t\t}\n\t\t\tmetabolism.isDirty = true;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSendCommand(Network.Connection cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(Connection cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(Connection cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args);\n\t\t\tNetwork.Net.sv.write.Start();\n\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.ConsoleCommand);\n\t\t\tNetwork.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tNetwork.Net.sv.write.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnFindBurnable(BaseOven baseOven)",
    "MethodSignature": "FindBurnable()",
    "MethodSourseCode": "\n\tpublic Item FindBurnable()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindBurnable\u0022, this);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tforeach (Item item in base.inventory.itemList)\n\t\t{\n\t\t\tif ((bool)item.info.GetComponent\u003CItemModBurnable\u003E() \u0026\u0026 (fuelType == null || item.info == fuelType))\n\t\t\t{\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneNameUpdated(PhoneController phoneController, string PhoneName, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 20)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 20);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_OpenShop(RPCMessage msg)\n\t{\n\t\tif (OccupiedCheck(msg.player))\n\t\t{\n\t\t\tSendSellOrders(msg.player);\n\t\t\tPlayerOpenLoot(msg.player, customerPanel);\n\t\t\tInterface.CallHook(\u0022OnOpenVendingShop\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnItemPickup(Item item, BasePlayer msgPlayer)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Pickup(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 item != null \u0026\u0026 allowPickup \u0026\u0026 Interface.CallHook(\u0022OnItemPickup\u0022, item, msg.player) == null)\n\t\t{\n\t\t\tClientRPC(null, \u0022PickupSound\u0022);\n\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\tmsg.player.SignalBroadcast(Signal.Gesture, \u0022pickup_item\u0022);\n\t\t}\n\t}\n",
    "ClassName": "WorldItem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_OpenAdmin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_OpenAdmin(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tSendSellOrders(player);\n\t\t\tPlayerOpenLoot(player);\n\t\t\tClientRPCPlayer(null, player, \u0022CLIENT_OpenAdminMenu\u0022);\n\t\t\tInterface.CallHook(\u0022OnOpenVendingAdmin\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnGrowableGathered(GrowableEntity growableEntity, Item item, BasePlayer player)",
    "MethodSignature": "GiveFruit(BasePlayer player, int amount, bool applyCondition)",
    "MethodSourseCode": "\n\tpublic void GiveFruit(BasePlayer player, int amount, bool applyCondition)\n\t{\n\t\tItem item = ItemManager.Create(Properties.pickupItem, amount, 0uL);\n\t\tif (applyCondition)\n\t\t{\n\t\t\titem.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);\n\t\t}\n\t\tif (player != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGrowableGathered\u0022, this, item, player);\n\t\t\tplayer.GiveItem(item, GiveItemReason.PickedUp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnExperimentStart(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer playerInfo = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetPlayerInfo(player.userID);\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !playerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnAnalysisComplete(SurveyCrater surveyCrater, BasePlayer msgPlayer)",
    "MethodSignature": "AnalysisComplete(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AnalysisComplete(RPCMessage msg)\n\t{\n\t\tInterface.CallHook(\u0022OnAnalysisComplete\u0022, this, msg.player);\n\t}\n",
    "ClassName": "SurveyCrater",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanHelicopterTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "PlayerVisible(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool PlayerVisible(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tVector3 position = ply.eyes.position;\n\t\tif (TOD_Sky.Instance.IsNight \u0026\u0026 Vector3.Distance(position, interestZoneOrigin) \u003E 40f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tVector3 vector = base.transform.position - Vector3.up * 6f;\n\t\tfloat num = Vector3.Distance(position, vector);\n\t\tVector3 normalized = (position - vector).normalized;\n\t\tif (GamePhysics.Trace(new Ray(vector \u002B normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) \u0026\u0026 GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag2)",
    "MethodSignature": "SpawnPlayer(BasePlayer player, uint sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool SpawnPlayer(BasePlayer player, uint sleepingBag)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tSleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);\n\t\tSleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) =\u003E x.ValidForPlayer(player2.userID, ignoreTimers: false) \u0026\u0026 x.net.ID == sleepingBag \u0026\u0026 x.unlockTime \u003C UnityEngine.Time.realtimeSinceStartup);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, player, sleepingBag2);\n\t\tif (obj is SleepingBag)\n\t\t{\n\t\t\tsleepingBag2 = (SleepingBag)obj;\n\t\t}\n\t\tsleepingBag2.GetSpawnPos(out var pos, out var rot);\n\t\tplayer2.RespawnAt(pos, rot);\n\t\tSleepingBag[] array2 = array;\n\t\tforeach (SleepingBag sleepingBag3 in array2)\n\t\t{\n\t\t\tif (Vector3.Distance(pos, sleepingBag3.transform.position) \u003C= ConVar.Server.respawnresetrange)\n\t\t\t{\n\t\t\t\tsleepingBag3.SetUnlockTime(UnityEngine.Time.realtimeSinceStartup \u002B sleepingBag3.secondsBetweenReuses);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)",
    "MethodSignature": "CanAcceptItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic bool CanAcceptItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanVendingAcceptItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tBasePlayer ownerPlayer = item.GetOwnerPlayer();\n\t\tif (transactionActive)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (item.parent == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.inventory.itemList.Contains(item))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (ownerPlayer == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn CanPlayerAdmin(ownerPlayer);\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityGroundMissing(BaseEntity baseEntity)",
    "MethodSignature": "OnGroundMissing()",
    "MethodSourseCode": "\tprivate void OnGroundMissing()\n\t{\n\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);\n\t\tif (baseEntity != null \u0026\u0026 Interface.CallHook(\u0022OnEntityGroundMissing\u0022, baseEntity) == null)\n\t\t{\n\t\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\t\tif (baseCombatEntity != null)\n\t\t\t{\n\t\t\t\tbaseCombatEntity.Die();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DestroyOnGroundMissing",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanNetworkTo(BaseEntity baseEntity, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tif (player == this)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBaseEntity baseEntity = GetParentEntity();\n\t\tif (base.limitNetworking)\n\t\t{\n\t\t\tif (baseEntity == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (baseEntity != player)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (baseEntity != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\treturn baseEntity.ShouldNetworkTo(player);\n\t\t}\n\t\treturn base.ShouldNetworkTo(player);\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerLootEnd(PlayerLoot playerLoot)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\tpublic void Clear()\n\t{\n\t\tif (!IsLooting())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerLootEnd\u0022, this);\n\t\tMarkDirty();\n\t\tif ((bool)entitySource)\n\t\t{\n\t\t\tentitySource.SendMessage(\u0022PlayerStoppedLooting\u0022, base.baseEntity, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tforeach (ItemContainer container in containers)\n\t\t{\n\t\t\tif (container != null)\n\t\t\t{\n\t\t\t\tcontainer.onDirty -= MarkDirty;\n\t\t\t}\n\t\t}\n\t\tcontainers.Clear();\n\t\tentitySource = null;\n\t\titemSource = null;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Hurt(HitInfo info)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022This should be called serverside only\u0022);\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Hurt( HitInfo )\u0022, 50))\n\t\t{\n\t\t\tfloat num = health;\n\t\t\tScaleDamage(info);\n\t\t\tif (info.PointStart != Vector3.zero)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C propDirection.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (!(propDirection[i].extraProtection == null) \u0026\u0026 !propDirection[i].IsWeakspot(base.transform, info))\n\t\t\t\t\t{\n\t\t\t\t\t\tpropDirection[i].extraProtection.Scale(info.damageTypes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);\n\t\t\tif (Interface.CallHook(\u0022IOnBaseCombatEntityHurt\u0022, this, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(this is BasePlayer))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t\tDebugHurt(info);\n\t\t\thealth = num - info.damageTypes.Total();\n\t\t\tSendNetworkUpdate();\n\t\t\tif (ConVar.Global.developer \u003E 1)\n\t\t\t{\n\t\t\t\tDebug.Log(string.Concat(\u0022[Combat]\u0022.PadRight(10), base.gameObject.name, \u0022 hurt \u0022, info.damageTypes.GetMajorityDamageType(), \u0022/\u0022, info.damageTypes.Total(), \u0022 - \u0022, health.ToString(\u00220\u0022), \u0022 health left\u0022));\n\t\t\t}\n\t\t\tlastDamage = info.damageTypes.GetMajorityDamageType();\n\t\t\tlastAttacker = info.Initiator;\n\t\t\tif (lastAttacker != null)\n\t\t\t{\n\t\t\t\tBaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;\n\t\t\t\tif (baseCombatEntity != null)\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;\n\t\t\tif (markAttackerHostile \u0026\u0026 baseCombatEntity2 != null \u0026\u0026 baseCombatEntity2 != this)\n\t\t\t{\n\t\t\t\tbaseCombatEntity2.MarkHostileFor();\n\t\t\t}\n\t\t\tif (lastDamage.IsConsideredAnAttack())\n\t\t\t{\n\t\t\t\tlastAttackedTime = UnityEngine.Time.time;\n\t\t\t\tif (lastAttacker != null)\n\t\t\t\t{\n\t\t\t\t\tLastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diesAtZeroHealth \u0026\u0026 Health() \u003C= 0f)\n\t\t\t{\n\t\t\t\tDie(info);\n\t\t\t}\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer)\n\t\t\t{\n\t\t\t\tif (IsDead())\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.Log(info, num, health, \u0022killed\u0022);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.Log(info, num, health);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnMapImageUpdated()",
    "MethodSignature": "ImageUpdate(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server.FromOwner]\n\tpublic void ImageUpdate(RPCMessage msg)\n\t{\n\t\tif (msg.player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte b = msg.read.UInt8();\n\t\tbyte b2 = msg.read.UInt8();\n\t\tuint num = msg.read.UInt32();\n\t\tif ((b == 0 \u0026\u0026 fogImages[b2] == num) || (b == 1 \u0026\u0026 paintImages[b2] == num))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint num2 = (uint)(b * 1000 \u002B b2);\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array != null)\n\t\t{\n\t\t\tFileStorage.server.RemoveEntityNum(net.ID, num2);\n\t\t\tuint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);\n\t\t\tif (b == 0)\n\t\t\t{\n\t\t\t\tfogImages[b2] = num3;\n\t\t\t}\n\t\t\tif (b == 1)\n\t\t\t{\n\t\t\t\tpaintImages[b2] = num3;\n\t\t\t}\n\t\t\tInvalidateNetworkCache();\n\t\t\tInterface.CallHook(\u0022OnMapImageUpdated\u0022);\n\t\t}\n\t}\n",
    "ClassName": "MapEntity",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSignature": "Kick(string reason)",
    "MethodSourseCode": "\n\tpublic void Kick(string reason)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(net.connection, reason);\n\t\t\tInterface.CallHook(\u0022OnPlayerKicked\u0022, this, reason);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemResearched(ResearchTable researchTable, int num)",
    "MethodSignature": "ResearchAttemptFinished()",
    "MethodSourseCode": "\n\tpublic void ResearchAttemptFinished()\n\t{\n\t\tItem targetItem = GetTargetItem();\n\t\tItem scrapItem = GetScrapItem();\n\t\tif (targetItem != null \u0026\u0026 scrapItem != null)\n\t\t{\n\t\t\tint num = ScrapForResearch(targetItem);\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemResearched\u0022, this, num);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tnum = (int)obj;\n\t\t\t}\n\t\t\tif (scrapItem.amount \u003E= num)\n\t\t\t{\n\t\t\t\tif (scrapItem.amount \u003C= num)\n\t\t\t\t{\n\t\t\t\t\tbase.inventory.Remove(scrapItem);\n\t\t\t\t\tscrapItem.RemoveFromContainer();\n\t\t\t\t\tscrapItem.Remove();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tscrapItem.UseItem(num);\n\t\t\t\t}\n\t\t\t\tbase.inventory.Remove(targetItem);\n\t\t\t\ttargetItem.Remove();\n\t\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\t\titem.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);\n\t\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tif (researchSuccessEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tif (user != null)\n\t\t{\n\t\t\tuser.inventory.loot.SendImmediate();\n\t\t}\n\t\tEndResearch();\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnCardSwipe(CardReader cardReader, Keycard keycard, BasePlayer msgPlayer)",
    "MethodSignature": "ServerCardSwiped(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerCardSwiped(RPCMessage msg)\n\t{\n\t\tif (!IsPowered() || Vector3Ex.Distance2D(msg.player.transform.position, base.transform.position) \u003E 1f || IsInvoking(GrantCard) || IsInvoking(FailCard))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint uid = msg.read.UInt32();\n\t\tKeycard keycard = BaseNetworkable.serverEntities.Find(uid) as Keycard;\n\t\tEffect.server.Run(swipeEffect.resourcePath, audioPosition.position, Vector3.up, msg.player.net.connection);\n\t\tif (keycard != null \u0026\u0026 Interface.CallHook(\u0022OnCardSwipe\u0022, this, keycard, msg.player) == null)\n\t\t{\n\t\t\tItem item = keycard.GetItem();\n\t\t\tif (item != null \u0026\u0026 keycard.accessLevel == accessLevel \u0026\u0026 item.conditionNormalized \u003E 0f)\n\t\t\t{\n\t\t\t\tInvoke(GrantCard, 0.5f);\n\t\t\t\titem.LoseCondition(1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInvoke(FailCard, 0.5f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CardReader",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanBypassQueue(Network.Connection connection)",
    "MethodSignature": "CanJumpQueue(Connection connection)",
    "MethodSourseCode": "\n\tprivate bool CanJumpQueue(Connection connection)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBypassQueue\u0022, connection);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Moderator)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Owner)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanTakeCutting(BasePlayer player, GrowableEntity growableEntity)",
    "MethodSignature": "TakeClones(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void TakeClones(BasePlayer player)\n\t{\n\t\tif (player == null || !CanClone() || Interface.CallHook(\u0022CanTakeCutting\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Properties.BaseCloneCount \u002B Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;\n\t\tif (num \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(Properties.CloneItem, num, 0uL);\n\t\t\tGrowableGeneEncoding.EncodeGenesToItem(this, item);\n\t\t\tplayer.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\tif (Properties.pickEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignalBroadcast(BaseEntity baseEntity)",
    "MethodSignature": "SignalBroadcast(Signal signal, string arg, Connection sourceConnection)",
    "MethodSourseCode": "\n\tpublic void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)\n\t{\n\t\tif (net != null \u0026\u0026 net.group != null \u0026\u0026 !base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSignalBroadcast\u0022, this) == null)\n\t\t{\n\t\t\tClientRPCEx(new SendInfo(net.group.subscribers)\n\t\t\t{\n\t\t\t\tmethod = SendMethod.Unreliable,\n\t\t\t\tpriority = Priority.Immediate\n\t\t\t}, sourceConnection, \u0022SignalFromServerEx\u0022, (int)signal, arg);\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnElevatorButtonPress(ElevatorLift elevatorLift, BasePlayer msgPlayer, Elevator.Direction direction, bool flag)",
    "MethodSignature": "Server_RaiseLowerFloor(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Server_RaiseLowerFloor(RPCMessage msg)\n\t{\n\t\tif (!CanMove())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tElevator.Direction direction = (Elevator.Direction)msg.read.Int32();\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnElevatorButtonPress\u0022, this, msg.player, direction, flag) == null)\n\t\t{\n\t\t\tSetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);\n\t\t\towner.Server_RaiseLowerElevator(direction, flag);\n\t\t\tInvoke(ClearDirection, 0.7f);\n\t\t\tif (liftButtonPressedEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ElevatorLift",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPhoneDial(PhoneController phoneController, PhoneController telephone, BasePlayer currentPlayer)",
    "MethodSignature": "CallPhone(int number)",
    "MethodSourseCode": "\n\tpublic void CallPhone(int number)\n\t{\n\t\tif (number == PhoneNumber)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.CallSelf);\n\t\t\treturn;\n\t\t}\n\t\tif (TelephoneManager.GetCurrentActiveCalls() \u002B 1 \u003E TelephoneManager.MaxConcurrentCalls)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.NetworkBusy);\n\t\t\treturn;\n\t\t}\n\t\tPhoneController telephone = TelephoneManager.GetTelephone(number);\n\t\tif (telephone != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPhoneDial\u0022, this, telephone, currentPlayer) == null)\n\t\t\t{\n\t\t\t\tif (telephone.serverState == Telephone.CallState.Idle \u0026\u0026 telephone.CanReceiveCall())\n\t\t\t\t{\n\t\t\t\t\tSetPhoneState(Telephone.CallState.Dialing);\n\t\t\t\t\tlastDialedNumber = number;\n\t\t\t\t\tactiveCallTo = telephone;\n\t\t\t\t\tactiveCallTo.ReceiveCallFrom(this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOnDialFailed(Telephone.DialFailReason.Engaged);\n\t\t\t\t\ttelephone.OnIncomingCallWhileBusy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.WrongNumber);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "CanUseVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanOpenLootPanel(BasePlayer player, string panelName)",
    "MethodSourseCode": "\n\tpublic override bool CanOpenLootPanel(BasePlayer player, string panelName = \u0022\u0022)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (panelName == customerPanel)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.CanOpenLootPanel(player, panelName))\n\t\t{\n\t\t\treturn CanPlayerAdmin(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDismountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tVector3 res;\n\t\tif (lite)\n\t\t{\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t}\n\t\telse if (!GetDismountPosition(player, out res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.ClientRPCPlayer(null, _mounted, \u0022ForcePositionTo\u0022, res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t\t_mounted = null;\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tif ((bool)player.GetParentEntity())\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionToParentOffset\u0022, baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, res);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBuildingPrivilege(BaseEntity baseEntity, OBB obb)",
    "MethodSignature": "GetBuildingPrivilege(OBB obb)",
    "MethodSourseCode": "\n\tpublic BuildingPrivlidge GetBuildingPrivilege(OBB obb)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBuildingPrivilege\u0022, this, obb);\n\t\tif (obj is BuildingPrivlidge)\n\t\t{\n\t\t\treturn (BuildingPrivlidge)obj;\n\t\t}\n\t\tBuildingBlock other = null;\n\t\tBuildingPrivlidge result = null;\n\t\tList\u003CBuildingBlock\u003E obj2 = Facepunch.Pool.GetList\u003CBuildingBlock\u003E();\n\t\tVis.Entities(obb.position, 16f \u002B obb.extents.magnitude, obj2, 2097152);\n\t\tfor (int i = 0; i \u003C obj2.Count; i\u002B\u002B)\n\t\t{\n\t\t\tBuildingBlock buildingBlock = obj2[i];\n\t\t\tif (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) \u003E 16f)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBuildingManager.Building building = buildingBlock.GetBuilding();\n\t\t\tif (building != null)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();\n\t\t\t\tif (!(dominatingBuildingPrivilege == null))\n\t\t\t\t{\n\t\t\t\t\tother = buildingBlock;\n\t\t\t\t\tresult = dominatingBuildingPrivilege;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\treturn result;\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBonusItemDrop(Item item, BasePlayer basePlayer)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer) == null)\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity());\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnEntityFromOwnerCheck(BaseEntity ent, BasePlayer player, uint id, string debugName)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityFromOwnerCheck\u0022, ent, player, id, debugName);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnDispenserBonus(ResourceDispenser resourceDispenser, BasePlayer player, Item item)",
    "MethodSignature": "AssignFinishBonus(BasePlayer player, float fraction)",
    "MethodSourseCode": "\n\tpublic void AssignFinishBonus(BasePlayer player, float fraction)\n\t{\n\t\tSendMessage(\u0022FinishBonusAssigned\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tif (fraction \u003C= 0f || finishBonus == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount finishBonu in finishBonus)\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));\n\t\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\n\t\t\tItem item = ItemManager.Create(finishBonu.itemDef, num \u002B num2, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnDispenserBonus\u0022, this, player, item);\n\t\t\t\tif (obj is Item)\n\t\t\t\t{\n\t\t\t\t\titem = (Item)obj;\n\t\t\t\t}\n\t\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanStackItem(Item item, Item item)",
    "MethodSignature": "CanStack(Item item)",
    "MethodSourseCode": "\n\tpublic bool CanStack(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanStackItem\u0022, this, item);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (item == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (info.stackable \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.stackable \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.itemid != info.itemid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (hasCondition \u0026\u0026 condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.hasCondition \u0026\u0026 item.condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValid())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBlueprint() \u0026\u0026 blueprintTarget != item.blueprintTarget)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.skin != skin)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t{\n\t\t\tint num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\tint num2 = ((instanceData != null) ? instanceData.dataInt : (-1));\n\t\t\tif (num != num2)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapTrigger(BearTrap bearTrap, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t{\n\t\t\thurtTarget = obj;\n\t\t\tInvoke(DelayedFire, 0.05f);\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRevive(BasePlayer getOwnerPlayer, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModConsumable component = GetOwnerItemDefinition().GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tif (player != ownerPlayer \u0026\u0026 player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanResearchItem(BasePlayer player, Item targetItem)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnEntityStabilityCheck(StabilityEntity stabilityEntity)",
    "MethodSignature": "StabilityCheck()",
    "MethodSourseCode": "\n\tpublic void StabilityCheck()\n\t{\n\t\tif (base.IsDestroyed || Interface.CallHook(\u0022OnEntityStabilityCheck\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (supports == null)\n\t\t{\n\t\t\tInitializeSupports();\n\t\t}\n\t\tbool flag = false;\n\t\tint num = DistanceFromGround();\n\t\tif (num != cachedDistanceFromGround)\n\t\t{\n\t\t\tcachedDistanceFromGround = num;\n\t\t\tflag = true;\n\t\t}\n\t\tfloat num2 = SupportValue();\n\t\tif (Mathf.Abs(cachedStability - num2) \u003E Stability.accuracy)\n\t\t{\n\t\t\tcachedStability = num2;\n\t\t\tflag = true;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tdirty = true;\n\t\t\tUpdateConnectedEntities();\n\t\t\tUpdateStability();\n\t\t}\n\t\telse if (dirty)\n\t\t{\n\t\t\tdirty = false;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (num2 \u003C Stability.collapse)\n\t\t{\n\t\t\tif (stabilityStrikes \u003C Stability.strikes)\n\t\t\t{\n\t\t\t\tUpdateStability();\n\t\t\t\tstabilityStrikes\u002B\u002B;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tKill(DestroyMode.Gib);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstabilityStrikes = 0;\n\t\t}\n\t}\n",
    "ClassName": "StabilityEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl();\n\t\t\tif ((bool)ply)\n\t\t\t{\n\t\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t\t}\n\t\t}\n\t\tcurrentlyControllingEnt.uid = 0u;\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnMeleeThrown(BasePlayer player, Item item)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (player == null || player.IsHeadUnderwater())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!canThrowAsProjectile)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Not throwable (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(this, \u0022not_throwable\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem item = GetItem();\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(this, \u0022item_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemModProjectile component = item.info.GetComponent\u003CItemModProjectile\u003E();\n\t\t\tif (component == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\n\t\t\tif (projectileShoot.projectiles.Count != 1)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Projectile count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(this, \u0022count_mismatch\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplayer.CleanupExpiredProjectiles();\n\t\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t\t{\n\t\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t\t{\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\t\tplayer.stats.combat.Log(this, \u0022duplicate_id\u0022);\n\t\t\t\t}\n\t\t\t\telse if (ValidateEyePos(player, projectile.startPos))\n\t\t\t\t{\n\t\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);\n\t\t\t\t\tEffect effect = new Effect();\n\t\t\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\n\t\t\t\t\teffect.scale = 1f;\n\t\t\t\t\teffect.pooledString = component.projectileObject.resourcePath;\n\t\t\t\t\teffect.number = projectile.seed;\n\t\t\t\t\tEffectNetwork.Send(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprojectileShoot?.Dispose();\n\t\t\titem.SetParent(null);\n\t\t\tInterface.CallHook(\u0022OnMeleeThrown\u0022, player, item);\n\t\t\tif (!canAiHearIt)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfloat num = 0f;\n\t\t\tif (component.projectileObject != null)\n\t\t\t{\n\t\t\t\tGameObject gameObject = component.projectileObject.Get();\n\t\t\t\tif (gameObject != null)\n\t\t\t\t{\n\t\t\t\t\tProjectile component2 = gameObject.GetComponent\u003CProjectile\u003E();\n\t\t\t\t\tif (component2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (DamageTypeEntry damageType in component2.damageTypes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum \u002B= damageType.amount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player != null)\n\t\t\t{\n\t\t\t\tSensation sensation = default(Sensation);\n\t\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\t\tsensation.Position = player.transform.position;\n\t\t\t\tsensation.Radius = 50f;\n\t\t\t\tsensation.DamagePotential = num;\n\t\t\t\tsensation.InitiatorPlayer = player;\n\t\t\t\tsensation.Initiator = player;\n\t\t\t\tSense.Stimulate(sensation);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 65
  },
  {
    "HookSignature": "OnEntityDeath(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void OnKilled(HitInfo info)\n\t{\n\t\tisKilled = true;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tKill();\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerTick(BasePlayer basePlayer, PlayerTick msg, bool wasPlayerStalled)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tlastInputTime = UnityEngine.Time.time;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(0u);\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(msg.activeItem);\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (!IsWounded())\n\t\t{\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t\t}\n\t\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\t\tUpdateRotationFromTick(msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDoorKnocked(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_KnockDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_KnockDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !knockEffect.isValid || UnityEngine.Time.realtimeSinceStartup \u003C nextKnockTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextKnockTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.5f;\n\t\tBaseEntity slot = GetSlot(Slot.LowerCenterDecoration);\n\t\tif (slot != null)\n\t\t{\n\t\t\tDoorKnocker component = slot.GetComponent\u003CDoorKnocker\u003E();\n\t\t\tif ((bool)component)\n\t\t\t{\n\t\t\t\tcomponent.Knock(rpc.player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEffect.server.Run(knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\tInterface.CallHook(\u0022OnDoorKnocked\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnStashExposed(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_WantsUnhide(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_WantsUnhide(RPCMessage rpc)\n\t{\n\t\tif (IsHidden())\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif (PlayerInRange(player) \u0026\u0026 Interface.CallHook(\u0022CanSeeStash\u0022, rpc.player, this) == null)\n\t\t\t{\n\t\t\t\tSetHidden(isHidden: false);\n\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, this, rpc.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnVehicleModuleSelected(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tuint itemUID = msg.read.UInt32();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result) \u0026\u0026 result is VehicleModuleStorage vehicleModuleStorage)\n\t\t{\n\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnItemSplit(Item item, int split_Amount)",
    "MethodSignature": "SplitItem(int split_Amount)",
    "MethodSourseCode": "\n\tpublic Item SplitItem(int split_Amount)\n\t{\n\t\tAssert.IsTrue(split_Amount \u003E 0, \u0022split_Amount \u003C= 0\u0022);\n\t\tif (split_Amount \u003C= 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (split_Amount \u003E= amount)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemSplit\u0022, this, split_Amount);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tamount -= split_Amount;\n\t\tItem item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);\n\t\titem.amount = split_Amount;\n\t\titem.skin = skin;\n\t\tif (IsBlueprint())\n\t\t{\n\t\t\titem.blueprintTarget = blueprintTarget;\n\t\t}\n\t\tif (info.amountType == ItemDefinition.AmountType.Genetics \u0026\u0026 instanceData != null \u0026\u0026 instanceData.dataInt != 0)\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataInt = instanceData.dataInt;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t}\n\t\tMarkDirty();\n\t\treturn item;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnTurretTarget(AutoTurret autoTurret, BaseCombatEntity targ)",
    "MethodSignature": "SetTarget(BaseCombatEntity targ)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity targ)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTurretTarget\u0022, this, targ) == null)\n\t\t{\n\t\t\tif (targ != target)\n\t\t\t{\n\t\t\t\tEffect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t\tMarkDirtyForceUpdateOutputs();\n\t\t\t\tnextShotTime \u002B= 0.1f;\n\t\t\t}\n\t\t\ttarget = targ;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (!broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Add(obj);\n\t\t\t\tMarkFrequencyDirty(frequency);\n\t\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnFuelConsume(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= 1)\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tfuel.amount--;\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityVisibilityCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityVisibilityCheck\u0022, ent, player, id, debugName, maximumDistance);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688))\n\t\t\t\t{\n\t\t\t\t\tif (!ent.IsVisible(player.eyes.HeadRay(), maximumDistance))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn ent.IsVisible(player.eyes.position, maximumDistance);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanUseWires(BasePlayer player)",
    "MethodSignature": "CanPlayerUseWires(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic static bool CanPlayerUseWires(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseWires\u0022, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CCollider\u003E obj2 = Facepunch.Pool.GetList\u003CCollider\u003E();\n\t\tGamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);\n\t\tbool result = obj2.All((Collider collider) =\u003E collider.gameObject.CompareTag(\u0022IgnoreWireCheck\u0022));\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\treturn result;\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcConversationStart(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor)",
    "MethodSignature": "Server_BeginTalking(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_BeginTalking(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tCleanupConversingPlayers();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor != null)\n\t\t{\n\t\t\tif (conversingPlayers.Contains(player))\n\t\t\t{\n\t\t\t\tOnConversationEnded(player);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnNpcConversationStart\u0022, this, player, conversationFor) == null)\n\t\t\t{\n\t\t\t\tconversingPlayers.Add(player);\n\t\t\t\tUpdateFlags();\n\t\t\t\tClientRPCPlayer(null, player, \u0022Client_StartConversation\u0022, GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech());\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnCounterTargetChange(PowerCounter powerCounter, BasePlayer msgPlayer, int num)",
    "MethodSignature": "SERVER_SetTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void SERVER_SetTarget(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (Interface.CallHook(\u0022OnCounterTargetChange\u0022, this, msg.player, num) == null \u0026\u0026 CanPlayerAdmin(msg.player))\n\t\t{\n\t\t\ttargetCounterNumber = num;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerMetabolize(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "ServerUpdate(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tpublic override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tbase.ServerUpdate(ownerEntity, delta);\n\t\tInterface.CallHook(\u0022OnPlayerMetabolize\u0022, this, ownerEntity, delta);\n\t\tSendChangesToClient();\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCollectiblePickup(Item item, BasePlayer reciever, CollectibleEntity collectibleEntity)",
    "MethodSignature": "DoPickup(BasePlayer reciever)",
    "MethodSourseCode": "\n\tpublic void DoPickup(BasePlayer reciever)\n\t{\n\t\tif (itemList == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemAmount[] array = itemList;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((bool)reciever)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnCollectiblePickup\u0022, item, reciever, this) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treciever.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t}\n\t\t}\n\t\titemList = null;\n\t\tif (pickupEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\n\t\t}\n\t\tKill();\n\t}\n",
    "ClassName": "CollectibleEntity",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnEntityDismounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tVector3 res;\n\t\tif (lite)\n\t\t{\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t}\n\t\telse if (!GetDismountPosition(player, out res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.ClientRPCPlayer(null, _mounted, \u0022ForcePositionTo\u0022, res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t\t_mounted = null;\n\t\t\tSetFlag(Flags.Busy, b: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tif ((bool)player.GetParentEntity())\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionToParentOffset\u0022, baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, res);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 55
  },
  {
    "HookSignature": "OnNpcTarget(Rust.Ai.HTN.BaseNpcMemory rust.Ai.HTN.BaseNpcMemory, BaseNpc animal)",
    "MethodSignature": "RememberPrimaryAnimal(BaseNpc animal)",
    "MethodSourseCode": "\n\tpublic void RememberPrimaryAnimal(BaseNpc animal)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, this, animal) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C NpcContext.AnimalsInRange.Count; i\u002B\u002B)\n\t\t{\n\t\t\tAnimalInfo primaryKnownAnimal = NpcContext.AnimalsInRange[i];\n\t\t\tif (primaryKnownAnimal.Animal == animal)\n\t\t\t{\n\t\t\t\tPrimaryKnownAnimal = primaryKnownAnimal;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNpcMemory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "CanBeLooted(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanBeLooted(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanLootPlayer\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsWounded())\n\t\t{\n\t\t\treturn IsSleeping();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnNpcTarget(NPCPlayerApex nPCPlayerApex, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\n\tpublic float GetWantsToAttack(BaseEntity target)\n\t{\n\t\tif (target == null)\n\t\t{\n\t\t\treturn 0f;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnNpcTarget\u0022, this, target);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\tif (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))\n\t\t{\n\t\t\treturn 0f;\n\t\t}\n\t\tif (target.GetType() == GetType())\n\t\t{\n\t\t\treturn 0f;\n\t\t}\n\t\tif (target.Health() \u003C= 0f)\n\t\t{\n\t\t\treturn 0f;\n\t\t}\n\t\treturn 1f;\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDemoRecordingStart(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnServerInitialized()",
    "MethodSignature": "OpenConnection()",
    "MethodSourseCode": "\n\tpublic void OpenConnection()\n\t{\n\t\tuseQueryPort = ConVar.Server.queryport \u003E 0 \u0026\u0026 ConVar.Server.queryport != ConVar.Server.port;\n\t\tif (!useQueryPort \u0026\u0026 !Network.Net.sv.AllowPassthroughMessages)\n\t\t{\n\t\t\tConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) \u002B 1;\n\t\t\tuseQueryPort = true;\n\t\t}\n\t\tNetwork.Net.sv.ip = ConVar.Server.ip;\n\t\tNetwork.Net.sv.port = ConVar.Server.port;\n\t\tStartSteamServer();\n\t\tif (!Network.Net.sv.Start())\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Couldn\u0027t Start Server.\u0022);\n\t\t\tCloseConnection();\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Net.sv.callbackHandler = this;\n\t\tNetwork.Net.sv.cryptography = new NetworkCryptographyServer();\n\t\tEACServer.DoStartup();\n\t\tInvokeRepeating(\u0022EACUpdate\u0022, 1f, 1f);\n\t\tInvokeRepeating(\u0022DoTick\u0022, 1f, 1f / (float)ConVar.Server.tickrate);\n\t\tInvokeRepeating(\u0022DoHeartbeat\u0022, 1f, 1f);\n\t\trunFrameUpdate = true;\n\t\tConsoleSystem.OnReplicatedVarChanged \u002B= OnReplicatedVarChanged;\n\t\tInterface.CallHook(\u0022IOnServerInitialized\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "CanDeployItem(BasePlayer msgPlayer, Deployer deployer, uint num)",
    "MethodSignature": "DoDeploy(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void DoDeploy(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable();\n\t\tif (deployable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRay ray = msg.read.Ray();\n\t\tuint num = msg.read.UInt32();\n\t\tif (Interface.CallHook(\u0022CanDeployItem\u0022, msg.player, this, num) == null)\n\t\t{\n\t\t\tif (deployable.toSlot)\n\t\t\t{\n\t\t\t\tDoDeploy_Slot(deployable, ray, num);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDoDeploy_Regular(deployable, ray);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "leaveteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void leaveteam(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam != 0L)\n\t\t{\n\t\t\tPlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);\n\t\t\tif (playerTeam != null \u0026\u0026 Interface.CallHook(\u0022OnTeamLeave\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(basePlayer.userID);\n\t\t\t\tbasePlayer.ClearTeam();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnMapMarkerAdded(BasePlayer basePlayer, ProtoBuf.MapNote ServerCurrentMapNote)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, MapNote.Deserialize(msg.read)) == null)\n\t\t{\n\t\t\tmsg.read.Position = 9L;\n\t\t\tServerCurrentMapNote?.Dispose();\n\t\t\tServerCurrentMapNote = MapNote.Deserialize(msg.read);\n\t\t\tDirtyPlayerState();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, ServerCurrentMapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnQuarryConsumeFuel(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "FuelCheck()",
    "MethodSourseCode": "\n\tpublic bool FuelCheck()\n\t{\n\t\tItem item = fuelStoragePrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory.FindItemsByItemName(\u0022lowgradefuel\u0022);\n\t\tif (item != null \u0026\u0026 item.amount \u003E= 1)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnQuarryConsumeFuel\u0022, this, item);\n\t\t\tif (obj is Item)\n\t\t\t{\n\t\t\t\titem = (Item)obj;\n\t\t\t}\n\t\t\titem.UseItem();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnItemRefill(Item item, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command == \u0022refill\u0022 \u0026\u0026 !player.IsSwimming() \u0026\u0026 HasCraftLevel(player) \u0026\u0026 !(item.conditionNormalized \u003E= 1f) \u0026\u0026 Interface.CallHook(\u0022OnItemRefill\u0022, item, player) == null)\n\t\t{\n\t\t\titem.DoRepair(conditionLost);\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModRepair",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnQuarryGather(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "ProcessResources()",
    "MethodSourseCode": "\n\tpublic void ProcessResources()\n\t{\n\t\tif (_linkedDeposit == null || hopperPrefab.instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)\n\t\t{\n\t\t\tif ((!canExtractLiquid \u0026\u0026 resource.isLiquid) || (!canExtractSolid \u0026\u0026 !resource.isLiquid))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresource.workDone \u002B= workToAdd;\n\t\t\tif (!(resource.workDone \u003C resource.workNeeded))\n\t\t\t{\n\t\t\t\tint num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);\n\t\t\t\tresource.workDone -= (float)num * resource.workNeeded;\n\t\t\t\tItem item = ItemManager.Create(resource.type, num, 0uL);\n\t\t\t\tif (Interface.CallHook(\u0022OnQuarryGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t\telse if (!item.MoveToContainer(hopperPrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\tSetOn(isOn: false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!FuelCheck())\n\t\t{\n\t\t\tSetOn(isOn: false);\n\t\t}\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnPlayerCorpseSpawn(BasePlayer basePlayer)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(\u0022assets/prefabs/player/player_corpse.prefab\u0022) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tplayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorResourceSet(ExcavatorArm excavatorArm, string text, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_SetResourceTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_SetResourceTarget(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnExcavatorResourceSet\u0022, this, text, msg.player) == null)\n\t\t{\n\t\t\tswitch (text)\n\t\t\t{\n\t\t\tcase \u0022HQM\u0022:\n\t\t\t\tresourceMiningIndex = 0;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Sulfur\u0022:\n\t\t\t\tresourceMiningIndex = 1;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Stone\u0022:\n\t\t\t\tresourceMiningIndex = 2;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Metal\u0022:\n\t\t\t\tresourceMiningIndex = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!IsOn())\n\t\t\t{\n\t\t\t\tBeginMining();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEngineLoadoutRefresh(Rust.Modular.EngineStorage rust.Modular.EngineStorage)",
    "MethodSignature": "RefreshLoadoutData()",
    "MethodSourseCode": "\n\tpublic void RefreshLoadoutData()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineLoadoutRefresh\u0022, this) == null)\n\t\t{\n\t\t\tisUsable = base.inventory.IsFull() \u0026\u0026 base.inventory.itemList.All((Item item) =\u003E !item.isBroken);\n\t\t\taccelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;\n\t\t\ttopSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;\n\t\t\tfuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;\n\t\t\tSendNetworkUpdate();\n\t\t\tGetEngineModule()?.RefreshPerformanceStats(this);\n\t\t}\n\t}\n",
    "ClassName": "EngineStorage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemRemove(Item item)",
    "MethodSignature": "Remove(float fTime)",
    "MethodSourseCode": "\n\tpublic void Remove(float fTime = 0f)\n\t{\n\t\tif (removeTime \u003E 0f || Interface.CallHook(\u0022OnItemRemove\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (isServer)\n\t\t{\n\t\t\tItemMod[] itemMods = info.itemMods;\n\t\t\tfor (int i = 0; i \u003C itemMods.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\titemMods[i].OnRemove(this);\n\t\t\t}\n\t\t}\n\t\tthis.onCycle = null;\n\t\tremoveTime = UnityEngine.Time.time \u002B fTime;\n\t\tthis.OnDirty = null;\n\t\tposition = -1;\n\t\tif (isServer)\n\t\t{\n\t\t\tItemManager.RemoveItem(this, fTime);\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (!broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Add(obj);\n\t\t\t\tMarkFrequencyDirty(frequency);\n\t\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRocketLaunched(BasePlayer player, BaseEntity baseEntity)",
    "MethodSignature": "SV_Launch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void SV_Launch(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (primaryMagazine.contents \u003C= 0)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022magazine_empty\u0022);\n\t\t\treturn;\n\t\t}\n\t\tprimaryMagazine.contents--;\n\t\tSignalBroadcast(Signal.Attack, string.Empty, player.net.connection);\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3().normalized;\n\t\tbool num = msg.read.Bit();\n\t\tBaseEntity mounted = player.GetParentEntity();\n\t\tif (mounted == null)\n\t\t{\n\t\t\tmounted = player.GetMounted();\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\tif (mounted != null)\n\t\t\t{\n\t\t\t\tvector = mounted.transform.TransformPoint(vector);\n\t\t\t\tvector2 = mounted.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector = player.eyes.position;\n\t\t\t\tvector2 = player.eyes.BodyForward();\n\t\t\t}\n\t\t}\n\t\tif (!ValidateEyePos(player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = primaryMagazine.ammoType.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = GetAimCone() \u002B component.projectileSpread;\n\t\tif (num2 \u003E 0f)\n\t\t{\n\t\t\tvector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);\n\t\t}\n\t\tfloat num3 = 1f;\n\t\tif (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1236478737))\n\t\t{\n\t\t\tnum3 = hitInfo.distance - 0.1f;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector \u002B vector2 * num3);\n\t\tif (!(baseEntity == null))\n\t\t{\n\t\t\tbaseEntity.creatorEntity = player;\n\t\t\tServerProjectile component2 = baseEntity.GetComponent\u003CServerProjectile\u003E();\n\t\t\tif ((bool)component2)\n\t\t\t{\n\t\t\t\tcomponent2.InitializeVelocity(GetInheritedVelocity(player) \u002B vector2 * component2.speed);\n\t\t\t}\n\t\t\tbaseEntity.Spawn();\n\t\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\n\t\t\tInterface.CallHook(\u0022OnRocketLaunched\u0022, player, baseEntity);\n\t\t\tGetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));\n\t\t}\n\t}\n",
    "ClassName": "BaseLauncher",
    "HookLineInvoke": 80
  },
  {
    "HookSignature": "OnExplosiveDud(DudTimedExplosive dudTimedExplosive)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tif (creatorEntity != null \u0026\u0026 creatorEntity.IsNpc)\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t\telse if (UnityEngine.Random.Range(0f, 1f) \u003C dudChance \u0026\u0026 Interface.CallHook(\u0022OnExplosiveDud\u0022, this) == null)\n\t\t{\n\t\t\tBecomeDud();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t}\n",
    "ClassName": "DudTimedExplosive",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, NPCVendingMachine nPCVendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved, Action\u003CBasePlayer, Item\u003E onItemPurchased)",
    "MethodSourseCode": "\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved = null, Action\u003CBasePlayer, Item\u003E onItemPurchased = null)\n\t{\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E= sellOrders.sellOrders.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (targetContainer == null \u0026\u0026 Vector3.Distance(buyer.transform.position, base.transform.position) \u003E 4f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\n\t\tList\u003CItem\u003E obj2 = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\tGetItemsToSell(sellOrder, obj2);\n\t\tif (obj2 == null || obj2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\n\t\tint num2 = obj2.Sum((Item x) =\u003E x.amount);\n\t\tif (num \u003E num2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CItem\u003E source = buyer.inventory.FindItemIDs(sellOrder.currencyID);\n\t\tif (sellOrder.currencyIsBP)\n\t\t{\n\t\t\tsource = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)\n\t\t\t\twhere x.blueprintTarget == sellOrder.currencyID\n\t\t\t\tselect x).ToList();\n\t\t}\n\t\tsource = source.Where((Item x) =\u003E !x.hasCondition || (x.conditionNormalized \u003E= 0.5f \u0026\u0026 x.maxConditionNormalized \u003E 0.5f)).ToList();\n\t\tif (source.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num3 = source.Sum((Item x) =\u003E x.amount);\n\t\tint num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;\n\t\tif (num3 \u003C num4)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\ttransactionActive = true;\n\t\tint num5 = 0;\n\t\tforeach (Item item3 in source)\n\t\t{\n\t\t\tint num6 = Mathf.Min(num4 - num5, item3.amount);\n\t\t\tItem item = ((item3.amount \u003E num6) ? item3.SplitItem(num6) : item3);\n\t\t\tTakeCurrencyItem(item);\n\t\t\tonCurrencyRemoved?.Invoke(buyer, item);\n\t\t\tnum5 \u002B= num6;\n\t\t\tif (num5 \u003E= num4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint num7 = 0;\n\t\tforeach (Item item4 in obj2)\n\t\t{\n\t\t\tint num8 = num - num7;\n\t\t\tItem item2 = ((item4.amount \u003E num8) ? item4.SplitItem(num8) : item4);\n\t\t\tif (item2 == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Vending machine error, contact developers!\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum7 \u002B= item2.amount;\n\t\t\t\tif (targetContainer == null)\n\t\t\t\t{\n\t\t\t\t\tGiveSoldItem(item2, buyer);\n\t\t\t\t}\n\t\t\t\telse if (!item2.MoveToContainer(targetContainer))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\n\t\t\t\t}\n\t\t\t\tonItemPurchased?.Invoke(buyer, item2);\n\t\t\t}\n\t\t\tif (num7 \u003E= num)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\tUpdateEmptyFlag();\n\t\ttransactionActive = false;\n\t\treturn true;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnDeleteVendingOffer(VendingMachine vendingMachine, int num)",
    "MethodSignature": "RPC_DeleteSellOrder(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_DeleteSellOrder(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tInterface.CallHook(\u0022OnDeleteVendingOffer\u0022, this, num);\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C sellOrders.sellOrders.Count)\n\t\t\t{\n\t\t\t\tsellOrders.sellOrders.RemoveAt(num);\n\t\t\t}\n\t\t\tRefreshSellOrderStockLevel();\n\t\t\tUpdateMapMarker();\n\t\t\tSendSellOrders(player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnItemLock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkDelete(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "DeleteBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void DeleteBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (IsValidIdentifier(text) \u0026\u0026 controlBookmarks.ContainsKey(text) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkDelete\u0022, this, player, text) == null)\n\t\t{\n\t\t\tuint num = controlBookmarks[text];\n\t\t\tcontrolBookmarks.Remove(text);\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (num == currentlyControllingEnt.uid)\n\t\t\t{\n\t\t\t\tcurrentlyControllingEnt.Set(null);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEngineStarted(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (needsBuildingPrivilegeToUse \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (onlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Already in use\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = lootPanelName;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDemolish(BasePlayer player, BuildingBlock buildingBlock)",
    "MethodSignature": "CanDemolish(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanDemolish(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDemolish\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (IsDemolishable())\n\t\t{\n\t\t\treturn HasDemolishPrivilege(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)",
    "MethodSignature": "CreateFromPosition(Vector3 pos)",
    "MethodSourseCode": "\n\tpublic ResourceDeposit CreateFromPosition(Vector3 pos)\n\t{\n\t\tVector2i indexFrom = GetIndexFrom(pos);\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\tUnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed \u002B World.Salt));\n\t\tResourceDeposit resourceDeposit = new ResourceDeposit\n\t\t{\n\t\t\torigin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)\n\t\t};\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C 0.5f)\n\t\t{\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);\n\t\t}\n\t\telse if (0 == 0)\n\t\t{\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\tfloat num = 0f;\n\t\t\tnum = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) \u003E 0.5f) ? 1f : 0f) * 0.25f));\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022metal.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t\tfloat num2 = 0f;\n\t\t\tnum2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) \u003E 0.5f) ? 1f : 0f) * (0.25f \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num2)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022sulfur.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t\tfloat num3 = 0f;\n\t\t\tif (World.Procedural)\n\t\t\t{\n\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 8) \u003E 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) \u003E 0.5f)\n\t\t\t\t{\n\t\t\t\t\tnum3 \u002B= 0.25f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum3 \u002B= 0.15f;\n\t\t\t}\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num3)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022hq.metal.ore\u0022), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t}\n\t\t_deposits.Add(indexFrom, resourceDeposit);\n\t\tInterface.CallHook(\u0022OnResourceDepositCreated\u0022, resourceDeposit);\n\t\tUnityEngine.Random.state = state;\n\t\treturn resourceDeposit;\n\t}\n",
    "ClassName": "ResourceDepositManager",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "OnNetworkGroupLeft(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupLeave(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupLeave(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupLeft\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEngineStart(IEngineControllerUser owner, BasePlayer player)",
    "MethodSignature": "TryStartEngine(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void TryStartEngine(BasePlayer player)\n\t{\n\t\tif (isServer \u0026\u0026 !owner.IsDead() \u0026\u0026 CurEngineState == EngineState.Off \u0026\u0026 player.net != null)\n\t\t{\n\t\t\tif (!owner.CanRunEngines())\n\t\t\t{\n\t\t\t\towner.OnEngineStartFailed();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnEngineStart\u0022, owner, player) == null)\n\t\t\t{\n\t\t\t\towner.SetFlag(engineStartingFlag, b: true);\n\t\t\t\towner.SetFlag(BaseEntity.Flags.On, b: false);\n\t\t\t\towner.Invoke(FinishStartingEngine, engineStartupTime);\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, owner, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VehicleEngineController",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTeamCreate(BasePlayer basePlayer)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = Instance.CreateTeam();\n\t\t\tplayerTeam.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam.AddPlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanLock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void TryLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 code.Length == 4 \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, rpc.player, this) == null \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectLocked.resourcePath);\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnPlayerCommand(BasePlayer player, string message)",
    "MethodSignature": "sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\tplayer = null;\n\t\t}\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;\n\t\tif (userGroup == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (text.Length \u003E 128)\n\t\t{\n\t\t\ttext = text.Substring(0, 128);\n\t\t}\n\t\tif (text.Length \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (text.StartsWith(\u0022/\u0022) || text.StartsWith(\u0022\\\\\u0022))\n\t\t{\n\t\t\tInterface.CallHook(\u0022IOnPlayerCommand\u0022, player, message);\n\t\t\treturn false;\n\t\t}\n\t\ttext = text.EscapeRichText();\n\t\tobject obj = Interface.CallHook(\u0022IOnPlayerChat\u0022, userId, username, text, targetChannel, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (serverlog)\n\t\t{\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat(\u0022[\u0022, targetChannel, \u0022] \u0022, username, \u0022: \u0022), ConsoleColor.DarkGreen, text);\n\t\t\tstring text2 = player?.ToString() ?? $\u0022{username}[{userId}]\u0022;\n\t\t\tif (targetChannel == ChatChannel.Team)\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022[TEAM CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022[CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t}\n\t\t}\n\t\tbool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;\n\t\tbool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));\n\t\tstring text3 = \u0022#5af\u0022;\n\t\tif (flag)\n\t\t{\n\t\t\ttext3 = \u0022#af5\u0022;\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\ttext3 = \u0022#fa5\u0022;\n\t\t}\n\t\tstring text4 = username.EscapeRichText();\n\t\tChatEntry chatEntry = default(ChatEntry);\n\t\tchatEntry.Channel = targetChannel;\n\t\tchatEntry.Message = text;\n\t\tchatEntry.UserId = ((player != null) ? player.UserIDString : userId.ToString());\n\t\tchatEntry.Username = username;\n\t\tchatEntry.Color = text3;\n\t\tchatEntry.Time = Epoch.Current;\n\t\tChatEntry chatEntry2 = chatEntry;\n\t\tHistory.Add(chatEntry2);\n\t\tRCon.Broadcast(RCon.LogType.Chat, chatEntry2);\n\t\tswitch (targetChannel)\n\t\t{\n\t\tcase ChatChannel.Global:\n\t\t\tif (Server.globalchat)\n\t\t\t{\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, 0, userId, text, text4, text3, 1f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ChatChannel.Team:\n\t\t{\n\t\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindPlayersTeam(userId);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\n\t\t\tif (onlineMemberConnections != null)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \u0022chat.add2\u0022, 1, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tplayerTeam.BroadcastTeamChat(userId, text4, text, text3);\n\t\t\treturn true;\n\t\t}\n\t\t}\n\t\tif (player != null)\n\t\t{\n\t\t\tfloat num2 = 2500f;\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\n\t\t\t\tif (!(sqrMagnitude \u003E num2))\n\t\t\t\t{\n\t\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, 0, userId, text, text4, text3, Mathf.Clamp01(num2 - sqrMagnitude \u002B 0.2f));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnEntityControl(RemoteControlEntity remoteControlEntity)",
    "MethodSignature": "CanControl()",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopCancelClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "CancelClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void CancelClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnShopCancelClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\t_ = (bool)vendorPlayer;\n\t\t\t_ = (bool)customerPlayer;\n\t\t\tResetTrade();\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSurveyGather(SurveyCharge surveyCharge, Item item)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tbase.Explode();\n\t\tif (WaterLevel.Test(base.transform.position, waves: true, this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);\n\t\tif (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime \u003C 10f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\torCreate.lastSurveyTime = Time.realtimeSinceStartup;\n\t\tif (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 point = hitOut.point;\n\t\t_ = hitOut.normal;\n\t\tList\u003CSurveyCrater\u003E obj = Pool.GetList\u003CSurveyCrater\u003E();\n\t\tVis.Entities(base.transform.position, 10f, obj, 1);\n\t\tbool num = obj.Count \u003E 0;\n\t\tPool.FreeList(ref obj);\n\t\tif (num)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tbool flag2 = false;\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)\n\t\t{\n\t\t\tif (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM \u0026\u0026 !resource.isLiquid \u0026\u0026 resource.amount \u003E= 1000)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);\n\t\t\t\tint iAmount = 1;\n\t\t\t\tflag = true;\n\t\t\t\tif (resource.isLiquid)\n\t\t\t\t{\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\n\t\t\t\t\tInterface.CallHook(\u0022OnSurveyGather\u0022, this, item);\n\t\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);\n\t\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 1f, GetInheritedDropVelocity() \u002B modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tstring strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SurveyCharge",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition, int skinItemId)",
    "MethodSignature": "CanCraft(int itemid, int skinItemId, ulong playerId)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(int itemid, int skinItemId, ulong playerId)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, itemDefinition, skinItemId);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (skinItemId != 0 \u0026\u0026 !CheckSkinOwnership(skinItemId, playerId))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (base.baseEntity.currentCraftLevel \u003C (float)itemDefinition.Blueprint.workbenchLevelRequired)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (HasUnlocked(itemDefinition))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PlayerBlueprints",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnVehicleLockableCheck(ModularCarLock modularCarLock)",
    "MethodSignature": "CanHaveALock()",
    "MethodSourseCode": "\n\tpublic bool CanHaveALock()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnVehicleLockableCheck\u0022, this);\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (!(obj is bool))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!owner.IsDead())\n\t\t{\n\t\t\treturn owner.HasDriverMountPoints();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ModularCarLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBroadcastCommand(string strCommand, object[] args)",
    "MethodSignature": "BroadcastToAllClients(string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void BroadcastToAllClients(string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnBroadcastCommand\u0022, strCommand, args);\n\t\t\tNetwork.Net.sv.write.Start();\n\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.ConsoleCommand);\n\t\t\tNetwork.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tNetwork.Net.sv.write.Send(new SendInfo(Network.Net.sv.connections));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerKeepAlive(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_KeepAlive(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_KeepAlive(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerKeepAlive\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tProlongWounding(10f);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcAlert(ScientistNPC scientistNPC)",
    "MethodSignature": "Alert()",
    "MethodSourseCode": "\n\tpublic void Alert()\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcAlert\u0022, this) == null)\n\t\t{\n\t\t\tlastAlertedTime = Time.time;\n\t\t\tSetChatterType(RadioChatterType.Alert);\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSetBedPublic(BasePlayer msgPlayer, SleepingBag sleepingBag)",
    "MethodSignature": "RPC_MakePublic(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_MakePublic(RPCMessage msg)\n\t{\n\t\tif (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID \u0026\u0026 !msg.player.CanBuild()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag != IsPublic() \u0026\u0026 Interface.CallHook(\u0022CanSetBedPublic\u0022, msg.player, this) == null)\n\t\t{\n\t\t\tSetPublic(flag);\n\t\t\tif (!IsPublic())\n\t\t\t{\n\t\t\t\tdeployerUserID = msg.player.userID;\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRfListenerAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tDebug.Log(\u0022adding same listener twice\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenList.Add(obj);\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnItemRemovedFromContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Remove(Item item)",
    "MethodSourseCode": "\n\tpublic bool Remove(Item item)\n\t{\n\t\tif (!itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (onPreItemRemove != null)\n\t\t{\n\t\t\tonPreItemRemove(item);\n\t\t}\n\t\titemList.Remove(item);\n\t\titem.parent = null;\n\t\tMarkDirty();\n\t\tif (onItemAddedRemoved != null)\n\t\t{\n\t\t\tonItemAddedRemoved(item, arg2: false);\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemRemovedFromContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnCorpsePopulate(HumanNPC humanNPC, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(\u0022assets/prefabs/npc/scientist/scientist_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = OverrideCorpseName();\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int i = 0; i \u003C lootSpawnSlots.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];\n\t\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlot.numberToSpawn; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryUnlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void TryUnlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tif (whitelistPlayers.Contains(rpc.player.userID))\n\t\t\t{\n\t\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tClientRPCPlayer(null, rpc.player, \u0022EnterUnlockCode\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRfBroadcasterRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Remove(obj);\n\t\t\t}\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnExplosiveFuseSet(TimedExplosive timedExplosive, float fuseLength)",
    "MethodSignature": "SetFuse(float fuseLength)",
    "MethodSourseCode": "\n\tpublic virtual void SetFuse(float fuseLength)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnExplosiveFuseSet\u0022, this, fuseLength);\n\t\t\tif (obj is float)\n\t\t\t{\n\t\t\t\tfuseLength = (float)obj;\n\t\t\t}\n\t\t\tInvoke(Explode, fuseLength);\n\t\t}\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnClothingItemChanged(PlayerInventory playerInventory, Item item, bool bAdded)",
    "MethodSignature": "OnClothingChanged(Item item, bool bAdded)",
    "MethodSourseCode": "\n\tprivate void OnClothingChanged(Item item, bool bAdded)\n\t{\n\t\tbase.baseEntity.SV_ClothingChanged();\n\t\tItemManager.DoRemoves();\n\t\tServerUpdate(0f);\n\t\tInterface.CallHook(\u0022OnClothingItemChanged\u0022, this, item, bAdded);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnRconConnection(System.Net.IPAddress iPEndPointAddress)",
    "MethodSignature": "ProcessConnections()",
    "MethodSourseCode": "\n\t\tprivate void ProcessConnections()\n\t\t{\n\t\t\tif (!server.Pending())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSocket socket = server.AcceptSocket();\n\t\t\tif (socket != null)\n\t\t\t{\n\t\t\t\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\n\t\t\t\tif (Interface.CallHook(\u0022OnRconConnection\u0022, iPEndPoint.Address) != null)\n\t\t\t\t{\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse if (IsBanned(iPEndPoint.Address))\n\t\t\t\t{\n\t\t\t\t\tDebug.Log(\u0022[RCON] Ignoring connection - banned. \u0022 \u002B iPEndPoint.Address.ToString());\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tclients.Add(new RConClient(socket));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerSpawn(BasePlayer basePlayer, Network.Connection connection)",
    "MethodSignature": "SpawnNewPlayer(Network.Connection connection)",
    "MethodSourseCode": "\n\tprivate BasePlayer SpawnNewPlayer(Network.Connection connection)\n\t{\n\t\tBasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();\n\t\tBasePlayer basePlayer = GameManager.server.CreateEntity(\u0022assets/prefabs/player/player.prefab\u0022, spawnPoint.pos, spawnPoint.rot).ToPlayer();\n\t\tif (Interface.CallHook(\u0022OnPlayerSpawn\u0022, basePlayer, connection) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tbasePlayer.health = 0f;\n\t\tbasePlayer.lifestate = BaseCombatEntity.LifeState.Dead;\n\t\tbasePlayer.ResetLifeStateOnSpawn = false;\n\t\tbasePlayer.limitNetworking = true;\n\t\tbasePlayer.Spawn();\n\t\tbasePlayer.limitNetworking = false;\n\t\tbasePlayer.PlayerInit(connection);\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);\n\t\t}\n\t\telse if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 \u0026\u0026 !basePlayer.hasPreviousLife))\n\t\t{\n\t\t\tbasePlayer.Respawn();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbasePlayer.SendRespawnOptions();\n\t\t}\n\t\tDebugEx.Log($\u0022{basePlayer.displayName} with steamid {basePlayer.userID} joined from ip {basePlayer.net.connection.ipaddress}\u0022);\n\t\tDebugEx.Log($\u0022\\tNetworkId {basePlayer.userID} is {basePlayer.net.ID} ({basePlayer.displayName})\u0022);\n\t\tif (basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)\n\t\t{\n\t\t\tDebugEx.Log($\u0022\\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}\u0022);\n\t\t}\n\t\treturn basePlayer;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerWound(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "StartWounded(BasePlayer source, HitInfo info)",
    "MethodSourseCode": "\n\tpublic void StartWounded(BasePlayer source = null, HitInfo info = null)\n\t{\n\t\tif (IsWounded() || Interface.CallHook(\u0022OnPlayerWound\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstats.Add(\u0022wounded\u0022, 1, (Stats)5);\n\t\twoundedDuration = UnityEngine.Random.Range(40f, 50f);\n\t\twoundedStartTime = UnityEngine.Time.realtimeSinceStartup;\n\t\tSetPlayerFlag(PlayerFlags.Wounded, b: true);\n\t\tEnableServerFall(wantsOn: true);\n\t\tSendNetworkUpdateImmediate();\n\t\tif (EACServer.playerTracker != null \u0026\u0026 net.connection != null \u0026\u0026 source != null \u0026\u0026 source.net.connection != null)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022playerTracker.LogPlayerDowned\u0022))\n\t\t\t{\n\t\t\t\tEasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);\n\t\t\t\tEasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(source.net.connection);\n\t\t\t\tEACServer.playerTracker.LogPlayerDowned(client, client2);\n\t\t\t}\n\t\t}\n\t\tInvoke(WoundingTick, 1f);\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerWounded(info.InitiatorPlayer, this, info);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAmmoUnload(BaseProjectile component, Item item, BasePlayer player)",
    "MethodSignature": "UnloadAmmo(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void UnloadAmmo(Item item, BasePlayer player)\n\t{\n\t\tBaseProjectile component = item.GetHeldEntity().GetComponent\u003CBaseProjectile\u003E();\n\t\tif (!component.canUnloadAmmo || Interface.CallHook(\u0022OnAmmoUnload\u0022, component, item, player) != null || !component)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint contents = component.primaryMagazine.contents;\n\t\tif (contents \u003E 0)\n\t\t{\n\t\t\tcomponent.primaryMagazine.contents = 0;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItem item2 = ItemManager.Create(component.primaryMagazine.ammoType, contents, 0uL);\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerSpectateEnd(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StopSpectating()",
    "MethodSourseCode": "\n\tpublic void StopSpectating()\n\t{\n\t\tif (IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectateEnd\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetParent(null);\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: false);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer getOwnerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void DoAttackShared(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, GetOwnerPlayer(), info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGetAttackStats(info);\n\t\tif (info.HitEntity != null)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022OnAttacked\u0022, 50))\n\t\t\t{\n\t\t\t\tinfo.HitEntity.OnAttacked(info);\n\t\t\t}\n\t\t}\n\t\tif (info.DoHitEffects)\n\t\t{\n\t\t\tif (base.isServer)\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20))\n\t\t\t\t{\n\t\t\t\t\tEffect.server.ImpactEffect(info);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20))\n\t\t\t\t{\n\t\t\t\t\tEffect.client.ImpactEffect(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (base.isServer \u0026\u0026 !base.IsDestroyed)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022UpdateItemCondition\u0022, 50))\n\t\t\t{\n\t\t\t\tUpdateItemCondition(info);\n\t\t\t}\n\t\t\tStartAttackCooldown(repeatDelay);\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcAttack(BaseNpc baseNpc, BaseEntity AttackTarget)",
    "MethodSignature": "StartAttack()",
    "MethodSourseCode": "\n\tpublic virtual void StartAttack()\n\t{\n\t\tif ((bool)AttackTarget \u0026\u0026 AttackReady() \u0026\u0026 Interface.CallHook(\u0022OnNpcAttack\u0022, this, AttackTarget) == null \u0026\u0026 !((AttackTarget.ServerPosition - ServerPosition).magnitude \u003E AttackRange))\n\t\t{\n\t\t\tnextAttackTime = UnityEngine.Time.realtimeSinceStartup \u002B AttackRate;\n\t\t\tBaseCombatEntity combatTarget = CombatTarget;\n\t\t\tif ((bool)combatTarget)\n\t\t\t{\n\t\t\t\tcombatTarget.Hurt(AttackDamage, AttackDamageType, this);\n\t\t\t\tStamina.Use(AttackCost);\n\t\t\t\tBusyTimer.Activate(0.5f);\n\t\t\t\tSignalBroadcast(Signal.Attack);\n\t\t\t\tClientRPC(null, \u0022Attack\u0022, AttackTarget.ServerPosition);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoShipSpawnCrate(CargoShip cargoShip)",
    "MethodSignature": "RespawnLoot()",
    "MethodSourseCode": "\n\tpublic void RespawnLoot()\n\t{\n\t\tif (Interface.CallHook(\u0022OnCargoShipSpawnCrate\u0022, this) == null)\n\t\t{\n\t\t\tInvokeRepeating(PlayHorn, 0f, 8f);\n\t\t\tSpawnCrate(lockedCratePrefab.resourcePath);\n\t\t\tSpawnCrate(eliteCratePrefab.resourcePath);\n\t\t\tfor (int i = 0; i \u003C 4; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(militaryCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tfor (int j = 0; j \u003C 4; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(junkCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tlootRoundsPassed\u002B\u002B;\n\t\t\tif (lootRoundsPassed \u003E= loot_rounds)\n\t\t\t{\n\t\t\t\tCancelInvoke(RespawnLoot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretAuthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void AddSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (!IsOnline() \u0026\u0026 rpc2.player.CanBuild() \u0026\u0026 !AtMaxAuthCapacity() \u0026\u0026 Interface.CallHook(\u0022OnTurretAuthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = rpc2.player.userID;\n\t\t\tplayerNameID.username = rpc2.player.displayName;\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnExcavatorGather(ExcavatorArm excavatorArm, Item item)",
    "MethodSignature": "ProduceResources()",
    "MethodSourseCode": "\n\tpublic void ProduceResources()\n\t{\n\t\tfloat num = resourceProductionTickRate / timeForFullResources;\n\t\tfloat num2 = resourcesToMine[resourceMiningIndex].amount * num;\n\t\tpendingResources[resourceMiningIndex].amount \u002B= num2;\n\t\tItemAmount[] array = pendingResources;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tif (!(itemAmount.amount \u003E= (float)outputPiles.Count))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);\n\t\t\titemAmount.amount -= num3 * 2;\n\t\t\tforeach (ExcavatorOutputPile outputPile in outputPiles)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);\n\t\t\t\tif (Interface.CallHook(\u0022OnExcavatorGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!item.MoveToContainer(outputPile.inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnPlayerVoice(BasePlayer basePlayer, byte[] data)",
    "MethodSignature": "OnReceivedVoice(byte[] data)",
    "MethodSourseCode": "\n\tpublic void OnReceivedVoice(byte[] data)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerVoice\u0022, this, data) == null)\n\t\t{\n\t\t\tif (Network.Net.sv.write.Start())\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.VoiceData);\n\t\t\t\tNetwork.Net.sv.write.UInt32(net.ID);\n\t\t\t\tNetwork.Net.sv.write.BytesWithSize(data);\n\t\t\t\tNetwork.Net.sv.write.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))\n\t\t\t\t{\n\t\t\t\t\tpriority = Priority.Immediate\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (activeTelephone != null)\n\t\t\t{\n\t\t\t\tactiveTelephone.OnReceivedVoiceFromUser(data);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcStopMoving(NPCPlayerApex nPCPlayerApex)",
    "MethodSignature": "StopMoving()",
    "MethodSourseCode": "\n\tpublic void StopMoving()\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcStopMoving\u0022, this) == null)\n\t\t{\n\t\t\tIsStopped = true;\n\t\t\tfinalDestination = GetPosition();\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFireBallDamage(FireBall fireBall, BaseCombatEntity baseCombatEntity, HitInfo hitInfo)",
    "MethodSignature": "DoRadialDamage()",
    "MethodSourseCode": "\n\tpublic void DoRadialDamage()\n\t{\n\t\tList\u003CCollider\u003E obj = Pool.GetList\u003CCollider\u003E();\n\t\tVector3 position = base.transform.position \u002B new Vector3(0f, radius * 0.75f, 0f);\n\t\tVis.Colliders(position, radius, obj, AttackLayers);\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.DoHitEffects = true;\n\t\thitInfo.DidHit = true;\n\t\thitInfo.HitBone = 0u;\n\t\thitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);\n\t\thitInfo.PointStart = base.transform.position;\n\t\tforeach (Collider item in obj)\n\t\t{\n\t\t\tif (item.isTrigger \u0026\u0026 (item.gameObject.layer == 29 || item.gameObject.layer == 18))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBaseCombatEntity baseCombatEntity = GameObjectEx.ToBaseEntity(item.gameObject) as BaseCombatEntity;\n\t\t\tif (!(baseCombatEntity == null) \u0026\u0026 baseCombatEntity.isServer \u0026\u0026 baseCombatEntity.IsAlive() \u0026\u0026 (!ignoreNPC || !baseCombatEntity.IsNpc) \u0026\u0026 baseCombatEntity.IsVisible(position))\n\t\t\t{\n\t\t\t\tif (baseCombatEntity is BasePlayer)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/impacts/additive/fire.prefab\u0022, baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up);\n\t\t\t\t}\n\t\t\t\thitInfo.PointEnd = baseCombatEntity.transform.position;\n\t\t\t\thitInfo.HitPositionWorld = baseCombatEntity.transform.position;\n\t\t\t\thitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallDamage\u0022, this, baseCombatEntity, hitInfo);\n\t\t\t\tbaseCombatEntity.OnAttacked(hitInfo);\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnSleepingBagDestroyed(SleepingBag sleepingBag2, BasePlayer player)",
    "MethodSignature": "DestroyBag(BasePlayer player, uint sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(BasePlayer player, uint sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (sleepingBag2.canBePublic)\n\t\t{\n\t\t\tsleepingBag2.SetPublic(isPublic: true);\n\t\t\tsleepingBag2.deployerUserID = 0uL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\tplayer.SendRespawnOptions();\n\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, player);\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity obj, AutoTurret autoTurret)",
    "MethodSignature": "ObjectVisible(BaseCombatEntity obj)",
    "MethodSourseCode": "\n\tpublic bool ObjectVisible(BaseCombatEntity obj)\n\t{\n\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, obj, this);\n\t\tif (obj2 is bool)\n\t\t{\n\t\t\treturn (bool)obj2;\n\t\t}\n\t\tList\u003CRaycastHit\u003E obj3 = Facepunch.Pool.GetList\u003CRaycastHit\u003E();\n\t\tVector3 position = eyePos.transform.position;\n\t\tVector3 vector = AimOffset(obj);\n\t\tfloat num = Vector3.Distance(vector, position);\n\t\tVector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);\n\t\tfor (int i = 0; (float)i \u003C (CheckPeekers() ? 3f : 1f); i\u002B\u002B)\n\t\t{\n\t\t\tVector3 normalized = (vector \u002B vector2 * visibilityOffsets[i] - position).normalized;\n\t\t\tobj3.Clear();\n\t\t\tGamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);\n\t\t\tfor (int j = 0; j \u003C obj3.Count; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);\n\t\t\t\tif ((!(entity != null) || !entity.isClient) \u0026\u0026 (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) \u0026\u0026 (!(entity != null) || !entity.EqualNetID(this)))\n\t\t\t\t{\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == obj || entity.EqualNetID(obj)))\n\t\t\t\t\t{\n\t\t\t\t\t\tFacepunch.Pool.FreeList(ref obj3);\n\t\t\t\t\t\tpeekIndex = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj3);\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMapMarkersClear(BasePlayer basePlayer, ProtoBuf.MapNote ServerCurrentMapNote)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner]\n\t[RPC_Server]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, ServerCurrentMapNote) == null)\n\t\t{\n\t\t\tServerCurrentDeathNote?.Dispose();\n\t\t\tServerCurrentDeathNote = null;\n\t\t\tServerCurrentMapNote?.Dispose();\n\t\t\tServerCurrentMapNote = null;\n\t\t\tDirtyPlayerState();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this, ServerCurrentMapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanDropActiveItem(BasePlayer basePlayer)",
    "MethodSignature": "ShouldDropActiveItem()",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldDropActiveItem()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDropActiveItem\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanRecycle(Recycler recycler, Item slot)",
    "MethodSignature": "HasRecyclable()",
    "MethodSourseCode": "\n\tpublic bool HasRecyclable()\n\t{\n\t\tfor (int i = 0; i \u003C 6; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = base.inventory.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanRecycle\u0022, this, slot);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Die(HitInfo info = null)\n\t{\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Global.developer \u003E 1)\n\t\t{\n\t\t\tDebug.Log(\u0022[Combat]\u0022.PadRight(10) \u002B base.gameObject.name \u002B \u0022 died\u0022);\n\t\t}\n\t\thealth = 0f;\n\t\tlifestate = LifeState.Dead;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tusing (TimeWarning.New(\u0022OnKilled\u0022))\n\t\t{\n\t\t\tOnKilled(info);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnStructureRotate(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoRotation(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void DoRotation(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanRotate(msg.player) \u0026\u0026 blockDefinition.canRotateAfterPlacement \u0026\u0026 Interface.CallHook(\u0022OnStructureRotate\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbase.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);\n\t\t\tRefreshEntityLinks();\n\t\t\tUpdateSurroundingEntities();\n\t\t\tUpdateSkin(force: true);\n\t\t\tRefreshNeighbours(linkToNeighbours: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(null, \u0022RefreshSkin\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnExplosiveDropped(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoDrop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void DoDrop(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1236478737))\n\t\t{\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tVector3 normal = hitInfo.normal;\n\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\n\t\t\tif ((bool)entity \u0026\u0026 entity is StabilityEntity \u0026\u0026 baseEntity is TimedExplosive)\n\t\t\t{\n\t\t\t\tentity = entity.ToServer\u003CBaseEntity\u003E();\n\t\t\t\tTimedExplosive obj = baseEntity as TimedExplosive;\n\t\t\t\tobj.onlyDamageParent = true;\n\t\t\t\tobj.DoStick(point, normal, entity);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t}\n\t\tbaseEntity.creatorEntity = msg.player;\n\t\tbaseEntity.skinID = skinID;\n\t\tbaseEntity.Spawn();\n\t\tSetUpThrownWeapon(baseEntity);\n\t\tStartAttackCooldown(repeatDelay);\n\t\tInterface.CallHook(\u0022OnExplosiveDropped\u0022, msg.player, baseEntity, this);\n\t\tUseItemAmount(1);\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnFuelItemCheck(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer)",
    "MethodSignature": "GetFuelItem()",
    "MethodSourseCode": "\n\tpublic Item GetFuelItem()\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelItemCheck\u0022, this, fuelContainer);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn fuelContainer.inventory.GetSlot(0);\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCodeEntered(CodeLock codeLock, BasePlayer rpcPlayer, string text)",
    "MethodSignature": "UnlockWithCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void UnlockWithCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tif (Interface.CallHook(\u0022OnCodeEntered\u0022, this, rpc.player, text) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = text == guestCode;\n\t\tbool flag2 = text == code;\n\t\tif (!(text == code) \u0026\u0026 (!hasGuestCode || !(text == guestCode)))\n\t\t{\n\t\t\tif (UnityEngine.Time.realtimeSinceStartup \u003E lastWrongTime \u002B 10f)\n\t\t\t{\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tDoEffect(effectDenied.resourcePath);\n\t\t\tDoEffect(effectShock.resourcePath);\n\t\t\trpc.player.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, this, useProtection: false);\n\t\t\twrongCodes\u002B\u002B;\n\t\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\treturn;\n\t\t}\n\t\tSendNetworkUpdate();\n\t\tif (flag2)\n\t\t{\n\t\t\tif (!whitelistPlayers.Contains(rpc.player.userID))\n\t\t\t{\n\t\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t}\n\t\telse if (flag \u0026\u0026 !guestPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnMapMarkerAdd(BasePlayer basePlayer, ProtoBuf.MapNote MapNoteDeserialize)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, MapNote.Deserialize(msg.read)) == null)\n\t\t{\n\t\t\tmsg.read.Position = 9L;\n\t\t\tServerCurrentMapNote?.Dispose();\n\t\t\tServerCurrentMapNote = MapNote.Deserialize(msg.read);\n\t\t\tDirtyPlayerState();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, ServerCurrentMapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVendingShopRename(VendingMachine vendingMachine, string obj, BasePlayer player)",
    "MethodSignature": "RPC_UpdateShopName(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_UpdateShopName(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tstring obj = msg.read.String(32);\n\t\tif (CanPlayerAdmin(player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopRename\u0022, this, obj, player) == null)\n\t\t{\n\t\t\tshopName = obj;\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerCanUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerCanUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNode\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerHasPathForUnlock(player, node))\n\t\t{\n\t\t\treturn !HasPlayerUnlocked(player, node);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggled(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnItemRepair(BasePlayer player, Item itemToRepair)",
    "MethodSignature": "RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)",
    "MethodSourseCode": "\n\tpublic static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)\n\t{\n\t\tif (itemToRepair == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition info = itemToRepair.info;\n\t\tItemBlueprint component = info.GetComponent\u003CItemBlueprint\u003E();\n\t\tif (!component || !info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (mustKnowBlueprint)\n\t\t{\n\t\t\tItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);\n\t\t\tif (!player.blueprints.HasUnlocked(itemDefinition) \u0026\u0026 (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnItemRepair\u0022, player, itemToRepair) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = RepairCostFraction(itemToRepair);\n\t\tbool flag = false;\n\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.GetList\u003CItemAmount\u003E();\n\t\tGetRepairCostList(component, obj);\n\t\tforeach (ItemAmount item in obj)\n\t\t{\n\t\t\tif (item.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount = player.inventory.GetAmount(item.itemDef.itemid);\n\t\t\t\tif (Mathf.CeilToInt(item.amount * num) \u003E amount)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount item2 in obj)\n\t\t{\n\t\t\tif (item2.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount2 = Mathf.CeilToInt(item2.amount * num);\n\t\t\t\tplayer.inventory.Take(null, item2.itemid, amount2);\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj);\n\t\titemToRepair.DoRepair(maxConditionLostOnRepair);\n\t\tif (Global.developer \u003E 0)\n\t\t{\n\t\t\tDebug.Log(\u0022Item repaired! condition : \u0022 \u002B itemToRepair.condition \u002B \u0022/\u0022 \u002B itemToRepair.maxCondition);\n\t\t}\n\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/repairbench/itemrepair.prefab\u0022, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnTurretClearList(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void ClearList(RPCMessage rpc)\n\t{\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTeamUpdate(ulong currentTeam, ulong newTeam, BasePlayer basePlayer)",
    "MethodSignature": "UpdateTeam(ulong newTeam)",
    "MethodSourseCode": "\n\tpublic void UpdateTeam(ulong newTeam)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamUpdate\u0022, currentTeam, newTeam, this) == null)\n\t\t{\n\t\t\tcurrentTeam = newTeam;\n\t\t\tSendNetworkUpdate();\n\t\t\tif (RelationshipManager.Instance.FindTeam(newTeam) == null)\n\t\t\t{\n\t\t\t\tClearTeam();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTeamUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnReactiveTargetReset(ReactiveTarget reactiveTarget)",
    "MethodSignature": "ResetTarget()",
    "MethodSourseCode": "\n\tpublic void ResetTarget()\n\t{\n\t\tif (IsKnockedDown() \u0026\u0026 CanToggle())\n\t\t{\n\t\t\tCancelInvoke(ResetTarget);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tknockdownHealth = 100f;\n\t\t\tSendPowerBurst();\n\t\t\tInterface.CallHook(\u0022OnReactiveTargetReset\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ReactiveTarget",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnItemCraftFinished(ItemCraftTask task, Item item)",
    "MethodSignature": "FinishCrafting(ItemCraftTask task)",
    "MethodSourseCode": "\n\tpublic void FinishCrafting(ItemCraftTask task)\n\t{\n\t\ttask.amount--;\n\t\ttask.numCrafted\u002B\u002B;\n\t\tulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);\n\t\tItem item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);\n\t\titem.amount = task.blueprint.amountToCreate;\n\t\tif (item.hasCondition \u0026\u0026 task.conditionScale != 1f)\n\t\t{\n\t\t\titem.maxCondition *= task.conditionScale;\n\t\t\titem.condition = item.maxCondition;\n\t\t}\n\t\titem.OnVirginSpawn();\n\t\tforeach (ItemAmount ingredient in task.blueprint.ingredients)\n\t\t{\n\t\t\tint num = (int)ingredient.amount;\n\t\t\tif (task.takenItems == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforeach (Item takenItem in task.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem.info == ingredient.itemDef)\n\t\t\t\t{\n\t\t\t\t\tint num2 = Mathf.Min(takenItem.amount, num);\n\t\t\t\t\ttakenItem.UseItem(num);\n\t\t\t\t\tnum -= num2;\n\t\t\t\t}\n\t\t\t\t_ = 0;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);\n\t\ttask.owner.Command(\u0022note.craft_done\u0022, task.taskUID, 1, task.amount);\n\t\tInterface.CallHook(\u0022OnItemCraftFinished\u0022, task, item);\n\t\tif (task.instanceData != null)\n\t\t{\n\t\t\titem.instanceData = task.instanceData;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\n\t\t{\n\t\t\ttask.owner.GiveAchievement(task.blueprint.UnlockAchievment);\n\t\t}\n\t\tif (task.owner.inventory.GiveItem(item))\n\t\t{\n\t\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, item.amount);\n\t\t\treturn;\n\t\t}\n\t\tItemContainer itemContainer = containers.First();\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, item.amount);\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, -item.amount);\n\t\titem.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnInventoryNetworkUpdate(PlayerInventory playerInventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool bSendInventoryToEveryone)",
    "MethodSignature": "SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone)",
    "MethodSourseCode": "\n\tpublic void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone = false)\n\t{\n\t\tusing UpdateItemContainer updateItemContainer = Facepunch.Pool.Get\u003CUpdateItemContainer\u003E();\n\t\tupdateItemContainer.type = (int)type;\n\t\tif (container != null)\n\t\t{\n\t\t\tcontainer.dirty = false;\n\t\t\tupdateItemContainer.container = Facepunch.Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tupdateItemContainer.container.Add(container.Save());\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnInventoryNetworkUpdate\u0022, this, container, updateItemContainer, type, bSendInventoryToEveryone) == null)\n\t\t{\n\t\t\tif (bSendInventoryToEveryone)\n\t\t\t{\n\t\t\t\tbase.baseEntity.ClientRPC(null, \u0022UpdatedItemContainer\u0022, updateItemContainer);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbase.baseEntity.ClientRPCPlayer(null, base.baseEntity, \u0022UpdatedItemContainer\u0022, updateItemContainer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerRecover(BasePlayer basePlayer, BasePlayer source)",
    "MethodSignature": "StopWounded(BasePlayer source)",
    "MethodSourseCode": "\n\tpublic void StopWounded(BasePlayer source = null)\n\t{\n\t\tif (IsDead() || Interface.CallHook(\u0022OnPlayerRecover\u0022, this, source) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRecoverFromWounded();\n\t\tCancelInvoke(WoundingTick);\n\t\tif (EACServer.playerTracker == null || net.connection == null || !(source != null) || source.net.connection == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022playerTracker.LogPlayerRevive\u0022))\n\t\t{\n\t\t\tEasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);\n\t\t\tEasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(source.net.connection);\n\t\t\tEACServer.playerTracker.LogPlayerRevive(client, client2);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSleepEnded(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void EndSleeping()\n\t{\n\t\tif (!IsSleeping())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\n\t\tsleepStartTime = -1f;\n\t\tsleepingPlayerList.Remove(this);\n\t\tCancelInvoke(ScheduledDeath);\n\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\n\t\tif (RelationshipManager.TeamsEnabled())\n\t\t{\n\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\n\t\t}\n\t\tEnablePlayerCollider();\n\t\tAddPlayerRigidbody();\n\t\tEnableServerFall(wantsOn: false);\n\t\tif (HasParent())\n\t\t{\n\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\tForceUpdateTriggers();\n\t\t}\n\t\tinventory.containerMain.OnChanged();\n\t\tinventory.containerBelt.OnChanged();\n\t\tinventory.containerWear.OnChanged();\n\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\n\t\tif (EACServer.playerTracker == null || net.connection == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022playerTracker.LogPlayerSpawn\u0022))\n\t\t{\n\t\t\tEasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);\n\t\t\tEACServer.playerTracker.LogPlayerSpawn(client, 0, 0);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnWeaponFired(BaseProjectile baseProjectile, BasePlayer msgPlayer, ItemModProjectile component, ProtoBuf.ProjectileShoot projectileShoot)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner]\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (primaryMagazine.contents \u003C= 0 \u0026\u0026 !UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022ammo_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;\n\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\n\t\tif (primaryMagazineAmmo.itemid != projectileShoot.ammoType)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Ammo mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022ammo_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tprimaryMagazine.contents--;\n\t\t}\n\t\tItemModProjectile component = primaryMagazineAmmo.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (projectileShoot.projectiles.Count \u003E component.numProjectiles)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.Log(this, \u0022count_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnWeaponFired\u0022, this, msg.player, component, projectileShoot);\n\t\tSignalBroadcast(Signal.Attack, string.Empty, msg.connection);\n\t\tplayer.CleanupExpiredProjectiles();\n\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t{\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.Log(this, \u0022duplicate_id\u0022);\n\t\t\t}\n\t\t\telse if (ValidateEyePos(player, projectile.startPos))\n\t\t\t{\n\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo);\n\t\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\n\t\t\t}\n\t\t}\n\t\tplayer.stats.Add(component.category \u002B \u0022_fired\u0022, projectileShoot.projectiles.Count(), (Stats)5);\n\t\tplayer.LifeStoryShotFired(this);\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay) \u002B animationDelay);\n\t\tplayer.MarkHostileFor();\n\t\tUpdateItemCondition();\n\t\tDidAttackServerside();\n\t\tfloat num = 0f;\n\t\tif (component.projectileObject != null)\n\t\t{\n\t\t\tGameObject gameObject = component.projectileObject.Get();\n\t\t\tif (gameObject != null)\n\t\t\t{\n\t\t\t\tProjectile component2 = gameObject.GetComponent\u003CProjectile\u003E();\n\t\t\t\tif (component2 != null)\n\t\t\t\t{\n\t\t\t\t\tforeach (DamageTypeEntry damageType in component2.damageTypes)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum \u002B= damageType.amount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfloat num2 = NoiseRadius;\n\t\tif (IsSilenced())\n\t\t{\n\t\t\tnum2 *= AI.npc_gun_noise_silencer_modifier;\n\t\t}\n\t\tSensation sensation = default(Sensation);\n\t\tsensation.Type = SensationType.Gunshot;\n\t\tsensation.Position = player.transform.position;\n\t\tsensation.Radius = num2;\n\t\tsensation.DamagePotential = num;\n\t\tsensation.InitiatorPlayer = player;\n\t\tsensation.Initiator = player;\n\t\tSense.Stimulate(sensation);\n\t\tif (EACServer.playerTracker == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022LogPlayerShooting\u0022))\n\t\t{\n\t\t\tUnityEngine.Vector3 networkPosition = player.GetNetworkPosition();\n\t\t\tUnityEngine.Quaternion networkRotation = player.GetNetworkRotation();\n\t\t\tint weaponID = GetItem()?.info.itemid ?? 0;\n\t\t\tEasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(player.net.connection);\n\t\t\tPlayerUseWeapon eventParams = default(PlayerUseWeapon);\n\t\t\teventParams.Position = new EasyAntiCheat.Server.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);\n\t\t\teventParams.ViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(networkRotation.w, networkRotation.x, networkRotation.y, networkRotation.z);\n\t\t\teventParams.WeaponID = weaponID;\n\t\t\tEACServer.playerTracker.LogPlayerUseWeapon(client, eventParams);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnVehiclePush(BaseVehicle baseVehicle, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_WantsPush(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server]\n\tpublic void RPC_WantsPush(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!player.isMounted \u0026\u0026 !RecentlyPushed \u0026\u0026 CanPushNow(player) \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)) \u0026\u0026 Interface.CallHook(\u0022OnVehiclePush\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tDoPushAction(player);\n\t\t\ttimeSinceLastPush = 0f;\n\t\t}\n\t}\n",
    "ClassName": "BaseVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnBoatPathGenerate()",
    "MethodSignature": "GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)",
    "MethodSourseCode": "\n\tpublic static List\u003CVector3\u003E GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBoatPathGenerate\u0022);\n\t\tif (obj is List\u003CVector3\u003E)\n\t\t{\n\t\t\treturn (List\u003CVector3\u003E)obj;\n\t\t}\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat num = x * 2f * (float)Math.PI;\n\t\tfloat num2 = 30f;\n\t\tint num3 = Mathf.CeilToInt(num / num2);\n\t\tList\u003CVector3\u003E list = new List\u003CVector3\u003E();\n\t\tfloat num4 = x;\n\t\tfloat y = 0f;\n\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t{\n\t\t\tfloat num5 = (float)i / (float)num3 * 360f;\n\t\t\tlist.Add(new Vector3(Mathf.Sin(num5 * ((float)Math.PI / 180f)) * num4, y, Mathf.Cos(num5 * ((float)Math.PI / 180f)) * num4));\n\t\t}\n\t\tfloat num6 = 4f;\n\t\tfloat num7 = 200f;\n\t\tbool flag = true;\n\t\tfor (int j = 0; j \u003C AI.ocean_patrol_path_iterations \u0026\u0026 flag; j\u002B\u002B)\n\t\t{\n\t\t\tflag = false;\n\t\t\tfor (int k = 0; k \u003C num3; k\u002B\u002B)\n\t\t\t{\n\t\t\t\tVector3 vector = list[k];\n\t\t\t\tint index = ((k == 0) ? (num3 - 1) : (k - 1));\n\t\t\t\tint index2 = ((k != num3 - 1) ? (k \u002B 1) : 0);\n\t\t\t\tVector3 b = list[index2];\n\t\t\t\tVector3 b2 = list[index];\n\t\t\t\tVector3 origin = vector;\n\t\t\t\tVector3 normalized = (Vector3.zero - vector).normalized;\n\t\t\t\tVector3 vector2 = vector \u002B normalized * num6;\n\t\t\t\tif (Vector3.Distance(vector2, b) \u003E num7 || Vector3.Distance(vector2, b2) \u003E num7)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag2 = true;\n\t\t\t\tint num8 = 16;\n\t\t\t\tfor (int l = 0; l \u003C num8; l\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tfloat num9 = (float)l / (float)num8 * 360f;\n\t\t\t\t\tVector3 normalized2 = new Vector3(Mathf.Sin(num9 * ((float)Math.PI / 180f)), y, Mathf.Cos(num9 * ((float)Math.PI / 180f))).normalized;\n\t\t\t\t\tVector3 vector3 = vector2 \u002B normalized2 * 1f;\n\t\t\t\t\tGetWaterDepth(vector3);\n\t\t\t\t\tVector3 direction = normalized;\n\t\t\t\t\tif (vector3 != Vector3.zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tdirection = (vector3 - vector2).normalized;\n\t\t\t\t\t}\n\t\t\t\t\tif (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1218511105))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tlist[k] = vector2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Failed to generate ocean patrol path\u0022);\n\t\t\treturn null;\n\t\t}\n\t\tList\u003Cint\u003E list2 = new List\u003Cint\u003E();\n\t\tLineUtility.Simplify(list, 5f, list2);\n\t\tList\u003CVector3\u003E list3 = list;\n\t\tlist = new List\u003CVector3\u003E();\n\t\tforeach (int item in list2)\n\t\t{\n\t\t\tlist.Add(list3[item]);\n\t\t}\n\t\tDebug.Log(\u0022Generated ocean patrol path with node count: \u0022 \u002B list.Count);\n\t\treturn list;\n\t}\n",
    "ClassName": "BaseBoat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBradleyApcHunt(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Hunt()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Hunt()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcHunt\u0022, this) != null || patrolPath == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTargetInfo targetInfo = targetList[0];\n\t\tif (!targetInfo.IsValid())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (HasPath() \u0026\u0026 targetInfo.IsVisible())\n\t\t{\n\t\t\tif (currentPath.Count \u003E 1)\n\t\t\t{\n\t\t\t\tVector3 item = currentPath[currentPathIndex];\n\t\t\t\tClearPath();\n\t\t\t\tcurrentPath.Add(item);\n\t\t\t\tfinalDestination = item;\n\t\t\t\tcurrentPathIndex = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(UnityEngine.Time.time \u003E nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tBasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t\tList\u003CBasePathNode\u003E nodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\n\t\t\tif (GetEngagementPath(ref nodes))\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tstart = nodes[nodes.Count - 1];\n\t\t\t}\n\t\t\tBasePathNode basePathNode = null;\n\t\t\tList\u003CBasePathNode\u003E nearNodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\n\t\t\tpatrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);\n\t\t\tStack\u003CBasePathNode\u003E stack = null;\n\t\t\tfloat num = float.PositiveInfinity;\n\t\t\tfloat y = mainTurretEyePos.localPosition.y;\n\t\t\tforeach (BasePathNode item2 in nearNodes)\n\t\t\t{\n\t\t\t\tStack\u003CBasePathNode\u003E path = new Stack\u003CBasePathNode\u003E();\n\t\t\t\tif (targetInfo.entity.IsVisible(item2.transform.position \u002B new Vector3(0f, y, 0f)) \u0026\u0026 AStarPath.FindPath(start, item2, out path, out var pathCost) \u0026\u0026 pathCost \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path;\n\t\t\t\t\tnum = pathCost;\n\t\t\t\t\tbasePathNode = item2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack == null \u0026\u0026 nearNodes.Count \u003E 0)\n\t\t\t{\n\t\t\t\tStack\u003CBasePathNode\u003E path2 = new Stack\u003CBasePathNode\u003E();\n\t\t\t\tBasePathNode basePathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];\n\t\t\t\tif (AStarPath.FindPath(start, basePathNode2, out path2, out var pathCost2) \u0026\u0026 pathCost2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path2;\n\t\t\t\t\tbasePathNode = basePathNode2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack != null)\n\t\t\t{\n\t\t\t\tcurrentPath.Clear();\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPath.Add(nodes[i].transform.position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforeach (BasePathNode item3 in stack)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(item3.transform.position);\n\t\t\t\t}\n\t\t\t\tcurrentPathIndex = -1;\n\t\t\t\tpathLooping = false;\n\t\t\t\tfinalDestination = basePathNode.transform.position;\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref nearNodes);\n\t\t\tFacepunch.Pool.FreeList(ref nodes);\n\t\t\tnextEngagementPathTime = UnityEngine.Time.time \u002B 5f;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanWearItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanWearItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tprivate bool CanWearItem(Item item, int targetSlot)\n\t{\n\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanWearItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tItem[] array = containerWear.itemList.ToArray();\n\t\tforeach (Item item2 in array)\n\t\t{\n\t\t\tif (item2 == item)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tItemModWearable component2 = item2.info.GetComponent\u003CItemModWearable\u003E();\n\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2))\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tif (item.parent == containerBelt)\n\t\t\t\t{\n\t\t\t\t\tflag = item2.MoveToContainer(containerBelt);\n\t\t\t\t}\n\t\t\t\tif (!flag \u0026\u0026 !item2.MoveToContainer(containerMain))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnBradleyApcInitialize(BradleyAPC bradleyAPC)",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcInitialize\u0022, this) == null)\n\t\t{\n\t\t\tmyRigidBody.centerOfMass = centerOfMass.localPosition;\n\t\t\tdestination = base.transform.position;\n\t\t\tfinalDestination = base.transform.position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDemoRecordingStop(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityTakeDamage(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (!base.isServer || isKilled || Interface.CallHook(\u0022OnEntityTakeDamage\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (resourceDispenser != null)\n\t\t{\n\t\t\tresourceDispenser.OnAttacked(info);\n\t\t}\n\t\tif (!info.DidGather)\n\t\t{\n\t\t\tif ((bool)baseProtection)\n\t\t\t{\n\t\t\t\tbaseProtection.Scale(info.damageTypes);\n\t\t\t}\n\t\t\tfloat num = info.damageTypes.Total();\n\t\t\thealth -= num;\n\t\t\tif (health \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnKilled(info);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOnHealthChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWireConnect(BasePlayer msgPlayer, IOEntity iOEntity, int num, IOEntity iOEntity2, int num2)",
    "MethodSignature": "MakeConnection(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tpublic void MakeConnection(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!CanPlayerUseWires(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint uid = msg.read.UInt32();\n\t\tint num = msg.read.Int32();\n\t\tuint uid2 = msg.read.UInt32();\n\t\tint num2 = msg.read.Int32();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tIOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent\u003CIOEntity\u003E());\n\t\tif (iOEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(uid2);\n\t\tIOEntity iOEntity2 = ((baseNetworkable2 == null) ? null : baseNetworkable2.GetComponent\u003CIOEntity\u003E());\n\t\tif (!(iOEntity2 == null) \u0026\u0026 !(Vector3.Distance(baseNetworkable2.transform.position, baseNetworkable.transform.position) \u003E maxWireLength) \u0026\u0026 num \u003C iOEntity.inputs.Length \u0026\u0026 num2 \u003C iOEntity2.outputs.Length \u0026\u0026 !(iOEntity.inputs[num].connectedTo.Get() != null) \u0026\u0026 !(iOEntity2.outputs[num2].connectedTo.Get() != null) \u0026\u0026 (!iOEntity.inputs[num].rootConnectionsOnly || iOEntity2.IsRootEntity()) \u0026\u0026 CanModifyEntity(player, iOEntity) \u0026\u0026 CanModifyEntity(player, iOEntity2))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnWireConnect\u0022, msg.player, iOEntity, num, iOEntity2, num2) != null)\n\t\t\t{\n\t\t\t\tiOEntity2.outputs[num2].linePoints = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tiOEntity.inputs[num].connectedTo.Set(iOEntity2);\n\t\t\tiOEntity.inputs[num].connectedToSlot = num2;\n\t\t\tiOEntity.inputs[num].connectedTo.Init();\n\t\t\tiOEntity2.outputs[num2].connectedTo.Set(iOEntity);\n\t\t\tiOEntity2.outputs[num2].connectedToSlot = num;\n\t\t\tiOEntity2.outputs[num2].connectedTo.Init();\n\t\t\tiOEntity2.MarkDirtyForceUpdateOutputs();\n\t\t\tiOEntity2.SendNetworkUpdate();\n\t\t\tiOEntity.SendNetworkUpdate();\n\t\t\tiOEntity2.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnHelicopterStrafeEnter(PatrolHelicopterAI patrolHelicopterAI, UnityEngine.Vector3 strafePos)",
    "MethodSignature": "State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm)",
    "MethodSourseCode": "\n\tpublic void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterStrafeEnter\u0022, this, strafePos) == null)\n\t\t{\n\t\t\tif (CanUseNapalm() \u0026\u0026 shouldUseNapalm)\n\t\t\t{\n\t\t\t\tuseNapalm = shouldUseNapalm;\n\t\t\t\tlastNapalmTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\tlastStrafeTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t_currentState = aiState.STRAFE;\n\t\t\tint mask = LayerMask.GetMask(\u0022Terrain\u0022, \u0022World\u0022, \u0022Construction\u0022, \u0022Water\u0022);\n\t\t\tif (TransformUtil.GetGroundInfo(strafePos, out var pos, out var _, 100f, mask, base.transform))\n\t\t\t{\n\t\t\t\tstrafe_target_position = pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrafe_target_position = strafePos;\n\t\t\t}\n\t\t\tnumRocketsLeft = 12;\n\t\t\tlastRocketTime = 0f;\n\t\t\tmovementLockingAiming = true;\n\t\t\tVector3 randomOffset = GetRandomOffset(strafePos, 175f, 192.5f);\n\t\t\tSetTargetDestination(randomOffset, 10f);\n\t\t\tSetIdealRotation(GetYawRotationTo(randomOffset));\n\t\t\tputtingDistance = true;\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)",
    "MethodSignature": "AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)",
    "MethodSourseCode": "\n\tpublic void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);\n\t\tif (!(itemDefinition == null) \u0026\u0026 !(itemDefinition2 == null))\n\t\t{\n\t\t\tcurrencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);\n\t\t\titemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);\n\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();\n\t\t\tsellOrder.ShouldPool = false;\n\t\t\tsellOrder.itemToSellID = itemToSellID;\n\t\t\tsellOrder.itemToSellAmount = itemToSellAmount;\n\t\t\tsellOrder.currencyID = currencyToUseID;\n\t\t\tsellOrder.currencyAmountPerItem = currencyAmount;\n\t\t\tsellOrder.currencyIsBP = bpState == 3 || bpState == 2;\n\t\t\tsellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;\n\t\t\tInterface.CallHook(\u0022OnAddVendingOffer\u0022, this, sellOrder);\n\t\t\tsellOrders.sellOrders.Add(sellOrder);\n\t\t\tRefreshSellOrderStockLevel(itemDefinition);\n\t\t\tUpdateMapMarker();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnTurretShutdown(AutoTurret autoTurret)",
    "MethodSignature": "InitiateShutdown()",
    "MethodSourseCode": "\n\tpublic void InitiateShutdown()\n\t{\n\t\tif ((!IsOffline() || booting) \u0026\u0026 Interface.CallHook(\u0022OnTurretShutdown\u0022, this) == null)\n\t\t{\n\t\t\tCancelInvoke(SetOnline);\n\t\t\tbooting = false;\n\t\t\tEffect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tSetIsOnline(online: false);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHorseHitch(RidableHorse horse, HitchTrough.HitchSpot hitch)",
    "MethodSignature": "AttemptToHitch(RidableHorse horse, HitchSpot hitch)",
    "MethodSourseCode": "\n\tpublic bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)\n\t{\n\t\tif (horse == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (hitch == null)\n\t\t{\n\t\t\thitch = GetClosest(horse.transform.position);\n\t\t}\n\t\tif (hitch != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnHorseHitch\u0022, horse, hitch);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\thitch.SetOccupiedBy(horse);\n\t\t\thorse.SetHitch(this);\n\t\t\thorse.transform.rotation = hitch.spot.transform.rotation;\n\t\t\thorse.transform.position = hitch.spot.transform.position;\n\t\t\thorse.DismountAllPlayers();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnRfFrequencyChanged(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnTrapDisarm(Landmine landmine, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Disarm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Disarm(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.net.ID != triggerPlayerID \u0026\u0026 Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapDisarm\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, b: false);\n\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 15)\n\t\t\t{\n\t\t\t\tInvoke(TryExplode, 0.05f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trpc.player.GiveItem(ItemManager.CreateByName(\u0022trap.landmine\u0022, 1, 0uL), GiveItemReason.PickedUp);\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSamSiteShoot(SamSite samSite)",
    "MethodSignature": "WeaponTick()",
    "MethodSourseCode": "\n\tpublic void WeaponTick()\n\t{\n\t\tif (IsDead() || Time.time \u003C lockOnTime || Time.time \u003C nextBurstTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (firedCount \u003E= 6)\n\t\t{\n\t\t\tnextBurstTime = Time.time \u002B 5f;\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tEnsureReloaded();\n\t\tif (HasAmmo() \u0026\u0026 Interface.CallHook(\u0022CanSamSiteShoot\u0022, this) == null)\n\t\t{\n\t\t\tif (!staticRespawn \u0026\u0026 ammoItem != null)\n\t\t\t{\n\t\t\t\tammoItem.UseItem();\n\t\t\t}\n\t\t\tfiredCount\u002B\u002B;\n\t\t\tFireProjectile(tubes[currentTubeIndex].position, currentAimDir, currentTarget);\n\t\t\tEffect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get(\u0022Tube \u0022 \u002B (currentTubeIndex \u002B 1)), Vector3.zero, Vector3.up);\n\t\t\tcurrentTubeIndex\u002B\u002B;\n\t\t\tif (currentTubeIndex \u003E= tubes.Length)\n\t\t\t{\n\t\t\t\tcurrentTubeIndex = 0;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer, ulong uLong)",
    "MethodSignature": "kickmember(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void kickmember(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam != null \u0026\u0026 !(playerTeam.GetLeader() != basePlayer))\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tif (basePlayer.userID != uLong \u0026\u0026 Interface.CallHook(\u0022OnTeamKick\u0022, playerTeam, basePlayer, uLong) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(uLong);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnMapMarkersCleared(BasePlayer basePlayer, ProtoBuf.MapNote ServerCurrentMapNote)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner]\n\t[RPC_Server]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, ServerCurrentMapNote) == null)\n\t\t{\n\t\t\tServerCurrentDeathNote?.Dispose();\n\t\t\tServerCurrentDeathNote = null;\n\t\t\tServerCurrentMapNote?.Dispose();\n\t\t\tServerCurrentMapNote = null;\n\t\t\tDirtyPlayerState();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this, ServerCurrentMapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPlayerLand(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tmetabolism.bleeding.Add(num * 0.5f);\n\t\t\tfloat num2 = num * 500f;\n\t\t\tHurt(num2, DamageType.Fall);\n\t\t\tif (num2 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnMessagePlayer(string msg, BasePlayer basePlayer)",
    "MethodSignature": "ChatMessage(string msg)",
    "MethodSourseCode": "\n\tpublic void ChatMessage(string msg)\n\t{\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnMessagePlayer\u0022, msg, this) == null)\n\t\t{\n\t\t\tSendConsoleCommand(\u0022chat.add\u0022, 2, 0, msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDestroy(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnKilled(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityDestroy\u0022, this) == null)\n\t\t{\n\t\t\tif (!OutOfCrates())\n\t\t\t{\n\t\t\t\tDropCrate();\n\t\t\t}\n\t\t\tbase.OnKilled(info);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnUserApprove(Network.Connection connection)",
    "MethodSignature": "OnNewConnection(Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnNewConnection(Connection connection)\n\t{\n\t\tconnection.connected = false;\n\t\tif (connection.token == null || connection.token.Length \u003C 32)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid Token\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.userid == 0L)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid SteamID\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.protocol != 2283)\n\t\t{\n\t\t\tif (!DeveloperList.Contains(connection.userid))\n\t\t\t{\n\t\t\t\tReject(connection, \u0022Incompatible Version\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022Not kicking \u0022 \u002B connection.userid \u002B \u0022 for incompatible protocol (is a developer)\u0022);\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))\n\t\t{\n\t\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\t\tstring text = user?.notes ?? \u0022no reason given\u0022;\n\t\t\tstring text2 = ((user != null \u0026\u0026 user.expiry \u003E 0) ? (\u0022 for \u0022 \u002B (user.expiry - Epoch.Current).FormatSecondsLong()) : \u0022\u0022);\n\t\t\tReject(connection, \u0022You are banned from this server\u0022 \u002B text2 \u002B \u0022 (\u0022 \u002B text \u002B \u0022)\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 1\u0022);\n\t\t\tconnection.authLevel = 1u;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 2\u0022);\n\t\t\tconnection.authLevel = 2u;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 is a developer\u0022);\n\t\t\tconnection.authLevel = 3u;\n\t\t}\n\t\tif (Interface.CallHook(\u0022IOnUserApprove\u0022, connection) == null)\n\t\t{\n\t\t\tm_AuthConnection.Add(connection);\n\t\t\tStartCoroutine(AuthorisationRoutine(connection));\n\t\t}\n\t}\n",
    "ClassName": "ConnectionAuth",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "CanHelicopterStrafeTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "ValidStrafeTarget(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool ValidStrafeTarget(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafeTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn !ply.IsNearEnemyBase();\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenCook(BaseOven baseOven, Item item)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tbase.inventory.OnCycle(0.5f);\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tItemModBurnable component = item.info.GetComponent\u003CItemModBurnable\u003E();\n\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t{\n\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\titem.MarkDirty();\n\t\t}\n\t\tif (item.fuel \u003C= 0f)\n\t\t{\n\t\t\tConsumeFuel(item, component);\n\t\t}\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnNpcTarget(HumanNPC humanNPC, BasePlayer component)",
    "MethodSignature": "UpdateTargets(float delta)",
    "MethodSourseCode": "\n\tpublic void UpdateTargets(float delta)\n\t{\n\t\tUpdateMemory();\n\t\tint num = -1;\n\t\tfloat num2 = -1f;\n\t\tVector3 position = base.transform.position;\n\t\tfor (int i = 0; i \u003C myMemory.All.Count; i\u002B\u002B)\n\t\t{\n\t\t\tSimpleAIMemory.SeenInfo seenInfo = myMemory.All[i];\n\t\t\tif (seenInfo.Entity == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat num3 = 0f;\n\t\t\tfloat value = Vector3.Distance(seenInfo.Entity.transform.position, position);\n\t\t\tif (!seenInfo.Entity.IsNpc \u0026\u0026 !(seenInfo.Entity.Health() \u003C= 0f))\n\t\t\t{\n\t\t\t\tnum3 \u002B= 1f - Mathf.InverseLerp(10f, sightRange, value);\n\t\t\t\tfloat value2 = Vector3.Dot((seenInfo.Entity.transform.position - eyes.position).normalized, eyes.BodyForward());\n\t\t\t\tnum3 \u002B= Mathf.InverseLerp(visionCone, 1f, value2);\n\t\t\t\tfloat value3 = seenInfo.Timestamp - UnityEngine.Time.realtimeSinceStartup;\n\t\t\t\tnum3 \u002B= 1f - Mathf.InverseLerp(0f, 3f, value3);\n\t\t\t\tif (num3 \u003E num2)\n\t\t\t\t{\n\t\t\t\t\tnum = i;\n\t\t\t\t\tnum2 = num3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num != -1)\n\t\t{\n\t\t\tSimpleAIMemory.SeenInfo seenInfo2 = myMemory.All[num];\n\t\t\tif (seenInfo2.Entity != null \u0026\u0026 seenInfo2.Entity is BasePlayer)\n\t\t\t{\n\t\t\t\tBasePlayer component = seenInfo2.Entity.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, this, component) == null)\n\t\t\t\t{\n\t\t\t\t\tcurrentTarget = component;\n\t\t\t\t\tcurrentTargetLOS = IsVisibleToUs(component);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentTarget = null;\n\t\t\tcurrentTargetLOS = false;\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "IOnUpdateServerInformation()",
    "MethodSignature": "UpdateServerInformation()",
    "MethodSourseCode": "\n\tprivate void UpdateServerInformation()\n\t{\n\t\tif (!SteamServer.IsValid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateServerInformation\u0022))\n\t\t{\n\t\t\tSteamServer.ServerName = ConVar.Server.hostname;\n\t\t\tSteamServer.MaxPlayers = ConVar.Server.maxplayers;\n\t\t\tSteamServer.Passworded = false;\n\t\t\tSteamServer.MapName = World.Name;\n\t\t\tstring text = \u0022stok\u0022;\n\t\t\tif (Restarting)\n\t\t\t{\n\t\t\t\ttext = \u0022strst\u0022;\n\t\t\t}\n\t\t\tstring text2 = $\u0022born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\u0022;\n\t\t\tstring text3 = $\u0022gm{GamemodeName()}\u0022;\n\t\t\tstring text4 = (ConVar.Server.pve ? \u0022,pve\u0022 : string.Empty);\n\t\t\tstring text5 = ConVar.Server.tags?.Trim(\u0027,\u0027) ?? \u0022\u0022;\n\t\t\tstring text6 = ((!string.IsNullOrWhiteSpace(text5)) ? (\u0022,\u0022 \u002B text5) : \u0022\u0022);\n\t\t\tSteamServer.GameTags = $\u0022mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent\u003CServerMgr\u003E.Instance.connectionQueue.Queued},v{2283}{text4}{text6},h{AssemblyHash},{text},{text2},{text3}\u0022;\n\t\t\tInterface.CallHook(\u0022IOnUpdateServerInformation\u0022);\n\t\t\tif (ConVar.Server.description != null \u0026\u0026 ConVar.Server.description.Length \u003E 100)\n\t\t\t{\n\t\t\t\tstring[] array = ConVar.Server.description.SplitToChunks(100).ToArray();\n\t\t\t\tInterface.CallHook(\u0022IOnUpdateServerDescription\u0022);\n\t\t\t\tfor (int i = 0; i \u003C 16; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (i \u003C array.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, array[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, string.Empty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSteamServer.SetKey(\u0022description_0\u0022, ConVar.Server.description);\n\t\t\t\tfor (int j = 1; j \u003C 16; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tSteamServer.SetKey($\u0022description_{j:00}\u0022, string.Empty);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022hash\u0022, AssemblyHash);\n\t\t\tSteamServer.SetKey(\u0022world.seed\u0022, World.Seed.ToString());\n\t\t\tSteamServer.SetKey(\u0022world.size\u0022, World.Size.ToString());\n\t\t\tSteamServer.SetKey(\u0022pve\u0022, ConVar.Server.pve.ToString());\n\t\t\tSteamServer.SetKey(\u0022headerimage\u0022, ConVar.Server.headerimage);\n\t\t\tSteamServer.SetKey(\u0022logoimage\u0022, ConVar.Server.logoimage);\n\t\t\tSteamServer.SetKey(\u0022url\u0022, ConVar.Server.url);\n\t\t\tSteamServer.SetKey(\u0022gmn\u0022, GamemodeName());\n\t\t\tSteamServer.SetKey(\u0022gmt\u0022, GamemodeTitle());\n\t\t\tSteamServer.SetKey(\u0022gmd\u0022, GamemodeDesc());\n\t\t\tSteamServer.SetKey(\u0022gmu\u0022, GamemodeUrl());\n\t\t\tSteamServer.SetKey(\u0022uptime\u0022, ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_mb\u0022, Performance.report.memoryAllocations.ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_cl\u0022, Performance.report.memoryCollections.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps\u0022, Performance.report.frameRate.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps_avg\u0022, Performance.report.frameRateAverage.ToString(\u00220.00\u0022));\n\t\t\tSteamServer.SetKey(\u0022ent_cnt\u0022, BaseNetworkable.serverEntities.Count.ToString());\n\t\t\tSteamServer.SetKey(\u0022build\u0022, BuildInfo.Current.Scm.ChangeId);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnTerrainInitialized()",
    "MethodSignature": "PostSetupComponents()",
    "MethodSourseCode": "\n\tpublic void PostSetupComponents()\n\t{\n\t\tTerrainExtension[] components = GetComponents\u003CTerrainExtension\u003E();\n\t\tfor (int i = 0; i \u003C components.Length; i\u002B\u002B)\n\t\t{\n\t\t\tcomponents[i].PostSetup();\n\t\t}\n\t\tInterface.CallHook(\u0022OnTerrainInitialized\u0022);\n\t}\n",
    "ClassName": "TerrainMeta",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEngineStarted(IEngineControllerUser owner, BasePlayer player)",
    "MethodSignature": "TryStartEngine(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void TryStartEngine(BasePlayer player)\n\t{\n\t\tif (isServer \u0026\u0026 !owner.IsDead() \u0026\u0026 CurEngineState == EngineState.Off \u0026\u0026 player.net != null)\n\t\t{\n\t\t\tif (!owner.CanRunEngines())\n\t\t\t{\n\t\t\t\towner.OnEngineStartFailed();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnEngineStart\u0022, owner, player) == null)\n\t\t\t{\n\t\t\t\towner.SetFlag(engineStartingFlag, b: true);\n\t\t\t\towner.SetFlag(BaseEntity.Flags.On, b: false);\n\t\t\t\towner.Invoke(FinishStartingEngine, engineStartupTime);\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, owner, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VehicleEngineController",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnEngineStatsRefreshed(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)",
    "MethodSignature": "CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free)",
    "MethodSourseCode": "\n\tpublic bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)\n\t{\n\t\tif (!CanCraft(bp, amount, free))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\ttaskUID\u002B\u002B;\n\t\tItemCraftTask itemCraftTask = Facepunch.Pool.Get\u003CItemCraftTask\u003E();\n\t\titemCraftTask.blueprint = bp;\n\t\tif (!free)\n\t\t{\n\t\t\tCollectIngredients(bp, itemCraftTask, amount, owner);\n\t\t}\n\t\titemCraftTask.endTime = 0f;\n\t\titemCraftTask.taskUID = taskUID;\n\t\titemCraftTask.owner = owner;\n\t\titemCraftTask.instanceData = instanceData;\n\t\tif (itemCraftTask.instanceData != null)\n\t\t{\n\t\t\titemCraftTask.instanceData.ShouldPool = false;\n\t\t}\n\t\titemCraftTask.amount = amount;\n\t\titemCraftTask.skinID = skinID;\n\t\tif (fromTempBlueprint != null \u0026\u0026 itemCraftTask.takenItems != null)\n\t\t{\n\t\t\tfromTempBlueprint.RemoveFromContainer();\n\t\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\n\t\t\titemCraftTask.conditionScale = 0.5f;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemCraft\u0022, itemCraftTask, owner, fromTempBlueprint);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tqueue.AddLast(itemCraftTask);\n\t\tif (itemCraftTask.owner != null)\n\t\t{\n\t\t\titemCraftTask.owner.Command(\u0022note.craft_add\u0022, itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnSignUpdated(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(5f)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanUpdateSign(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= paintableSources.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit() \u0026\u0026 !msg.player.IsAdmin)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022{msg.player} tried to upload a sign from a file but they aren\u0027t admin, ignoring\u0022);\n\t\t\treturn;\n\t\t}\n\t\tEnsureInitialized();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\n\t\t}\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnEntityLeave(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif ((bool)basePlayer \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\t_players.Remove(basePlayer);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanRenameBed(BasePlayer msgPlayer, SleepingBag sleepingBag, string text)",
    "MethodSignature": "Rename(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void Rename(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022CanRenameBed\u0022, msg.player, this, text) == null)\n\t\t{\n\t\t\ttext = WordFilter.Filter(text);\n\t\t\tif (string.IsNullOrEmpty(text))\n\t\t\t{\n\t\t\t\ttext = \u0022Unnamed Sleeping Bag\u0022;\n\t\t\t}\n\t\t\tif (text.Length \u003E 24)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 22) \u002B \u0022..\u0022;\n\t\t\t}\n\t\t\tniceName = text;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFBroadcaster rFBroadcaster, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 playerUsable \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (RFManager.IsReserved(num))\n\t\t\t{\n\t\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsPowered());\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnPlayerInput(BasePlayer basePlayer, InputState serverInput)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tlastInputTime = UnityEngine.Time.time;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(0u);\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(msg.activeItem);\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (!IsWounded())\n\t\t{\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t\t}\n\t\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\t\tUpdateRotationFromTick(msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnTeamInvite(BasePlayer basePlayer, BasePlayer component)",
    "MethodSignature": "sendinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void sendinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tPlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), out var hitInfo, 5f, 1218652417, QueryTriggerInteraction.Ignore))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\n\t\tif ((bool)entity)\n\t\t{\n\t\t\tBasePlayer component = entity.GetComponent\u003CBasePlayer\u003E();\n\t\t\tif ((bool)component \u0026\u0026 component != basePlayer \u0026\u0026 !component.IsNpc \u0026\u0026 component.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamInvite\u0022, basePlayer, component) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.SendInvite(component);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnCrateLanded(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "LandCheck()",
    "MethodSourseCode": "\n\tpublic void LandCheck()\n\t{\n\t\tRaycastHit hitInfo;\n\t\tif (hasLanded)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateLanded\u0022, this);\n\t\t}\n\t\telse if (UnityEngine.Physics.Raycast(new Ray(base.transform.position \u002B Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))\n\t\t{\n\t\t\tEffect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);\n\t\t\thasLanded = true;\n\t\t\tCancelInvoke(LandCheck);\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNodePath\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tNodeInstance entryNode = GetEntryNode();\n\t\tif (entryNode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn CheckChainRecursive(player, entryNode, node);\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRidableAnimalClaim(BaseRidableAnimal baseRidableAnimal, BasePlayer player)",
    "MethodSignature": "RPC_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player) == null \u0026\u0026 IsForSale())\n\t\t{\n\t\t\tItem item = GetPurchaseToken(player);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\titem.UseItem();\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnConstructionPlace(BaseEntity baseEntity, Construction component, Construction.Target placement, BasePlayer ownerPlayer)",
    "MethodSignature": "DoPlacement(Construction.Target placement, Construction component)",
    "MethodSourseCode": "\n\tpublic GameObject DoPlacement(Construction.Target placement, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tBaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tfloat num = 1f;\n\t\tfloat num2 = 0f;\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null)\n\t\t{\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tif (ownerItem.hasCondition)\n\t\t\t{\n\t\t\t\tnum = ownerItem.conditionNormalized;\n\t\t\t}\n\t\t}\n\t\tPoolableEx.AwakeFromInstantiate(baseEntity.gameObject);\n\t\tBuildingBlock buildingBlock = baseEntity as BuildingBlock;\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tbuildingBlock.blockDefinition = PrefabAttribute.server.Find\u003CConstruction\u003E(buildingBlock.prefabID);\n\t\t\tif (!buildingBlock.blockDefinition)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Placing a building block that has no block definition!\u0022);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbuildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);\n\t\t\tnum2 = buildingBlock.currentGrade.maxHealth;\n\t\t}\n\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\tif ((bool)baseCombatEntity)\n\t\t{\n\t\t\tnum2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);\n\t\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\n\t\t\tbaseCombatEntity.InitializeHealth(num2 * num, num2);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnConstructionPlace\u0022, baseEntity, component, placement, ownerPlayer) != null)\n\t\t{\n\t\t\tif (baseEntity.IsValid())\n\t\t\t{\n\t\t\t\tbaseEntity.KillMessage();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGameManager.Destroy(baseEntity);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tbaseEntity.gameObject.SendMessage(\u0022SetDeployedBy\u0022, ownerPlayer, SendMessageOptions.DontRequireReceiver);\n\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\tbaseEntity.Spawn();\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/build/frame_place.prefab\u0022, baseEntity, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t\tStabilityEntity stabilityEntity = baseEntity as StabilityEntity;\n\t\tif ((bool)stabilityEntity)\n\t\t{\n\t\t\tstabilityEntity.UpdateSurroundingEntities();\n\t\t}\n\t\treturn baseEntity.gameObject;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnDefaultItemsReceived(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tulong skin = 0uL;\n\t\tint infoInt = base.baseEntity.GetInfoInt(\u0022client.rockskin\u0022, 0);\n\t\tif (infoInt \u003E 0 \u0026\u0026 base.baseEntity.blueprints.steamInventory.HasItem(infoInt))\n\t\t{\n\t\t\tIPlayerItemDefinition itemDefinition = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\tif (itemDefinition != null)\n\t\t\t{\n\t\t\t\tskin = itemDefinition.WorkshopDownload;\n\t\t\t}\n\t\t}\n\t\tGiveItem(ItemManager.CreateByName(\u0022rock\u0022, 1, skin), containerBelt);\n\t\tGiveItem(ItemManager.CreateByName(\u0022torch\u0022, 1, 0uL), containerBelt);\n\t\tif (IsBirthday())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL), containerWear);\n\t\t}\n\t\tif (IsChristmas())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 37
  },
  {
    "HookSignature": "OnVehicleModulesAssigned(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\titemModVehicleModule.doNonUserSpawn = true;\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnTurretStartup(AutoTurret autoTurret)",
    "MethodSignature": "InitiateStartup()",
    "MethodSourseCode": "\n\tpublic void InitiateStartup()\n\t{\n\t\tif (!IsOnline() \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretStartup\u0022, this) == null)\n\t\t{\n\t\t\tEffect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInvoke(SetOnline, 2f);\n\t\t\tbooting = true;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)",
    "MethodSignature": "DoAction(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void DoAction(Item item, BasePlayer player)\n\t{\n\t\tif (item.amount \u003C 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGameObjectRef gameObjectRef = GetConsumeEffect();\n\t\tif (gameObjectRef.isValid)\n\t\t{\n\t\t\tVector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));\n\t\t\tEffect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);\n\t\t}\n\t\tplayer.metabolism.MarkConsumption();\n\t\tItemModConsumable consumable = GetConsumable();\n\t\tif (!string.IsNullOrEmpty(consumable.achievementWhenEaten))\n\t\t{\n\t\t\tplayer.GiveAchievement(consumable.achievementWhenEaten);\n\t\t}\n\t\tfloat num = Mathf.Max(consumable.amountToConsume, 1);\n\t\tfloat num2 = Mathf.Min(item.amount, num);\n\t\tfloat num3 = num2 / num;\n\t\tfloat num4 = item.conditionNormalized;\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\tnum4 = consumable.conditionFractionToLose;\n\t\t}\n\t\tforeach (ItemModConsumable.ConsumableEffect effect in consumable.effects)\n\t\t{\n\t\t\tif (Mathf.Clamp01(player.healthFraction \u002B player.metabolism.pending_health.Fraction()) \u003E effect.onlyIfHealthLessThan)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t{\n\t\t\t\tif (effect.amount \u003C 0f)\n\t\t\t\t{\n\t\t\t\t\tplayer.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position \u002B player.transform.forward * 1f));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount * num3 * num4;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);\n\t\t\t}\n\t\t}\n\t\tif (player.modifiers != null \u0026\u0026 Interface.CallHook(\u0022OnPlayerAddModifiers\u0022, player, item, consumable) == null)\n\t\t{\n\t\t\tplayer.modifiers.Add(consumable.modifiers);\n\t\t}\n\t\tif (product != null)\n\t\t{\n\t\t\tItemAmountRandom[] array = product;\n\t\t\tforeach (ItemAmountRandom itemAmountRandom in array)\n\t\t\t{\n\t\t\t\tint num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);\n\t\t\t\tif (num5 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tItem item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);\n\t\t\t\t\tplayer.GiveItem(item2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (string.IsNullOrEmpty(eatGesture))\n\t\t{\n\t\t\tplayer.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);\n\t\t}\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem((int)num2);\n\t\t}\n\t}\n",
    "ClassName": "ItemModConsume",
    "HookLineInvoke": 49
  },
  {
    "HookSignature": "ICanPickupEntity(BasePlayer rpcPlayer, DoorCloser doorCloser)",
    "MethodSignature": "RPC_Take(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_Take(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022ICanPickupEntity\u0022, rpc.player, this) != null || !rpc.player.CanInteract() || !rpc.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDoor door = GetDoor();\n\t\tif (!(door == null) \u0026\u0026 door.GetPlayerLockPermission(rpc.player))\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "DoorCloser",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)",
    "MethodSignature": "DoBuild(Construction.Target target, Construction component)",
    "MethodSourseCode": "\n\tpublic void DoBuild(Construction.Target target, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (target.socket != null)\n\t\t{\n\t\t\tif (!target.socket.female)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is not female. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (target.entity != null \u0026\u0026 target.entity.IsOccupied(target.socket))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is occupied. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (target.onTerrain)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target on terrain is not allowed when attaching to socket. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (ConVar.AntiHack.eye_protection \u003E= 2)\n\t\t{\n\t\t\tVector3 center = ownerPlayer.eyes.center;\n\t\t\tVector3 position = ownerPlayer.eyes.position;\n\t\t\tVector3 origin = target.ray.origin;\n\t\t\tVector3 p = ((target.entity != null \u0026\u0026 target.socket != null) ? target.GetWorldPosition() : target.position);\n\t\t\tif (target.entity != null)\n\t\t\t{\n\t\t\t\tDeployShell deployShell = PrefabAttribute.server.Find\u003CDeployShell\u003E(target.entity.prefabID);\n\t\t\t\tif (deployShell != null)\n\t\t\t\t{\n\t\t\t\t\tp \u002B= target.normal.normalized * deployShell.LineOfSightPadding();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = 2097152;\n\t\t\tint num2 = (ConVar.AntiHack.build_terraincheck ? 10551296 : 2162688);\n\t\t\tif (!GamePhysics.LineOfSight(padding: (target.socket != null) ? 0.5f : 0.01f, layerMask: (target.socket != null) ? num : num2, p0: center, p1: position, p2: origin, p3: p))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Line of sight blocked.\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tConstruction.lastPlacementError = \u0022No Error\u0022;\n\t\tGameObject gameObject = DoPlacement(target, component);\n\t\tif (gameObject == null)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t place: \u0022 \u002B Construction.lastPlacementError);\n\t\t}\n\t\tif (!(gameObject != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnEntityBuilt\u0022, this, gameObject);\n\t\tDeployable deployable = GetDeployable();\n\t\tif (deployable != null)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);\n\t\t\tif (deployable.setSocketParent \u0026\u0026 target.entity != null \u0026\u0026 target.entity.SupportsChildDeployables() \u0026\u0026 (bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SetParent(target.entity, worldPositionStays: true);\n\t\t\t}\n\t\t\tif (deployable.wantsInstanceData \u0026\u0026 GetOwnerItem().instanceData != null)\n\t\t\t{\n\t\t\t\t(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);\n\t\t\t}\n\t\t\tif (deployable.copyInventoryFromItem)\n\t\t\t{\n\t\t\t\tStorageContainer component2 = baseEntity.GetComponent\u003CStorageContainer\u003E();\n\t\t\t\tif ((bool)component2)\n\t\t\t\t{\n\t\t\t\t\tcomponent2.ReceiveInventoryFromItem(GetOwnerItem());\n\t\t\t\t}\n\t\t\t}\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\tif (modDeployable != null)\n\t\t\t{\n\t\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\t}\n\t\t\tbaseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer);\n\t\t}\n\t\tPayForPlacement(ownerPlayer, component);\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 58
  },
  {
    "HookSignature": "OnSendCommand(System.Collections.Generic.List\u003CNetwork.Connection\u003E cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(List\u003CConnection\u003E cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(List\u003CConnection\u003E cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args);\n\t\t\tNetwork.Net.sv.write.Start();\n\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.ConsoleCommand);\n\t\t\tNetwork.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tNetwork.Net.sv.write.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "acceptinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void acceptinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = Instance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamAcceptInvite\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.AcceptInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPhoneAnswer(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnCrateHack(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "StartHacking()",
    "MethodSourseCode": "\n\tpublic void StartHacking()\n\t{\n\t\tInterface.CallHook(\u0022OnCrateHack\u0022, this);\n\t\tBroadcastEntityMessage(\u0022HackingStarted\u0022, 20f, 256);\n\t\tSetFlag(Flags.Reserved1, b: true);\n\t\tInvokeRepeating(HackProgress, 1f, 1f);\n\t\tClientRPC(null, \u0022UpdateHackProgress\u0022, 0, (int)requiredHackSeconds);\n\t\tRefreshDecay();\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer basePlayer, BasePlayer.SpawnPoint spawnPoint)",
    "MethodSignature": "Respawn()",
    "MethodSourseCode": "\n\tpublic void Respawn()\n\t{\n\t\tSpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, this, spawnPoint);\n\t\tif (obj is SpawnPoint)\n\t\t{\n\t\t\tspawnPoint = (SpawnPoint)obj;\n\t\t}\n\t\tRespawnAt(spawnPoint.pos, spawnPoint.rot);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnFuelConsumed(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= 1)\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tfuel.amount--;\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnCreateWorldProjectile(HitInfo info, Item item)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnCreateWorldProjectile\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\tcomponent.WakeUp();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTrapTrigger(Landmine landmine, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (!base.isClient)\n\t\t{\n\t\t\tif (!Armed())\n\t\t\t{\n\t\t\t\tCancelInvoke(Arm);\n\t\t\t\tblocked = true;\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t\t{\n\t\t\t\tBasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;\n\t\t\t\tTrigger(ply);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_Broadcast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Broadcast(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tbool b = msg.read.Bit();\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tSetFlag(Flags.Reserved4, b);\n\t\t\tInterface.CallHook(\u0022OnToggleVendingBroadcast\u0022, this, player);\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnLootEntity(BasePlayer getComponent\u003CBasePlayer\u003E, BaseEntity targetEntity)",
    "MethodSignature": "StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\n\t{\n\t\tClear();\n\t\tif (!targetEntity)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!targetEntity.OnStartBeingLooted(base.baseEntity))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tAssert.IsTrue(targetEntity.isServer, \u0022Assure is server\u0022);\n\t\tPositionChecks = doPositionChecks;\n\t\tentitySource = targetEntity;\n\t\titemSource = null;\n\t\tInterface.CallHook(\u0022OnLootEntity\u0022, GetComponent\u003CBasePlayer\u003E(), targetEntity);\n\t\tMarkDirty();\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnSignUpdated(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tbyte[] array = msg.read.BytesWithSize();\n\t\t\tif (array != null \u0026\u0026 ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveAllByEntity(net.ID);\n\t\t\t\t_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnTurretRotate(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "FlipAim(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void FlipAim(RPCMessage rpc)\n\t{\n\t\tif (!IsOnline() \u0026\u0026 IsAuthed(rpc.player) \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretRotate\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (IsDead() || (IsImmortal() \u0026\u0026 info.damageTypes.Total() \u003E= 0f) || Interface.CallHook(\u0022IOnBasePlayerHurt\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Server.pve \u0026\u0026 (bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);\n\t\t\treturn;\n\t\t}\n\t\tif (info.damageTypes.Has(DamageType.Fun_Water))\n\t\t{\n\t\t\tbool flag = true;\n\t\t\tItem activeItem = GetActiveItem();\n\t\t\tif (activeItem != null \u0026\u0026 (activeItem.info.shortname == \u0022gun.water\u0022 || activeItem.info.shortname == \u0022pistol.water\u0022))\n\t\t\t{\n\t\t\t\tfloat value = metabolism.wetness.value;\n\t\t\t\tmetabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);\n\t\t\t\tbool flag2 = metabolism.wetness.value \u003E= ConVar.Server.funWaterDamageThreshold;\n\t\t\t\tflag = !flag2;\n\t\t\t\tif (info.InitiatorPlayer != null)\n\t\t\t\t{\n\t\t\t\t\tif (flag2 \u0026\u0026 value \u003C ConVar.Server.funWaterDamageThreshold)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_SOAKED\u0022);\n\t\t\t\t\t}\n\t\t\t\t\tif (metabolism.radiation_level.Fraction() \u003E 0.2f \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_RADICAL\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_RADICAL\u0022);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t}\n\t\tif (info.damageTypes.Get(DamageType.Drowned) \u003E 5f \u0026\u0026 drownEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(drownEffect.resourcePath, this, StringPool.Get(\u0022head\u0022), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);\n\t\t}\n\t\tif (modifiers != null)\n\t\t{\n\t\t\tif (info.damageTypes.Has(DamageType.Radiation))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));\n\t\t\t}\n\t\t\tif (info.damageTypes.Has(DamageType.RadiationExposure))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));\n\t\t\t}\n\t\t}\n\t\tmetabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\tif ((bool)initiatorPlayer \u0026\u0026 initiatorPlayer != this)\n\t\t{\n\t\t\tif (initiatorPlayer.InSafeZone() || InSafeZone())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.MarkHostileFor(1800f);\n\t\t\t}\n\t\t\tif (initiatorPlayer.IsNpc \u0026\u0026 initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer \u0026\u0026 info.damageTypes.Get(DamageType.Explosion) \u003E 0f)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);\n\t\t\t}\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif (EACServer.playerTracker != null \u0026\u0026 info.Initiator != null \u0026\u0026 info.Initiator is BasePlayer)\n\t\t{\n\t\t\tBasePlayer basePlayer = info.Initiator.ToPlayer();\n\t\t\tif (net.connection != null \u0026\u0026 basePlayer.net.connection != null)\n\t\t\t{\n\t\t\t\tEasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);\n\t\t\t\tEasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(basePlayer.net.connection);\n\t\t\t\tPlayerTakeDamage eventParams = default(PlayerTakeDamage);\n\t\t\t\teventParams.DamageTaken = (int)info.damageTypes.Total();\n\t\t\t\teventParams.HitBoneID = (int)info.HitBone;\n\t\t\t\teventParams.WeaponID = 0;\n\t\t\t\teventParams.DamageFlags = (info.isHeadshot ? PlayerTakeDamageFlags.PlayerTakeDamageCriticalHit : PlayerTakeDamageFlags.PlayerTakeDamageNormalHit);\n\t\t\t\tif (info.Weapon != null)\n\t\t\t\t{\n\t\t\t\t\tItem item = info.Weapon.GetItem();\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t{\n\t\t\t\t\t\teventParams.WeaponID = item.info.itemid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUnityEngine.Vector3 position = basePlayer.eyes.position;\n\t\t\t\tUnityEngine.Quaternion rotation = basePlayer.eyes.rotation;\n\t\t\t\tUnityEngine.Vector3 position2 = eyes.position;\n\t\t\t\tUnityEngine.Quaternion rotation2 = eyes.rotation;\n\t\t\t\teventParams.AttackerPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position.x, position.y, position.z);\n\t\t\t\teventParams.AttackerViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(rotation.w, rotation.x, rotation.y, rotation.z);\n\t\t\t\teventParams.VictimPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position2.x, position2.y, position2.z);\n\t\t\t\teventParams.VictimViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(rotation2.w, rotation2.x, rotation2.y, rotation2.z);\n\t\t\t\tEACServer.playerTracker.LogPlayerTakeDamage(client, client2, eventParams);\n\t\t\t}\n\t\t}\n\t\tmetabolism.SendChangesToClient();\n\t\tif (info.PointStart != UnityEngine.Vector3.zero \u0026\u0026 info.damageTypes.Total() \u003E= 0f)\n\t\t{\n\t\t\tClientRPCPlayer(null, this, \u0022DirectionalDamage\u0022, info.PointStart, (int)info.damageTypes.GetMajorityDamageType());\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMarkHostile(BasePlayer basePlayer, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic override void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tdouble currentTimestamp = TimeEx.currentTimestamp;\n\t\t\tdouble val = currentTimestamp \u002B (double)duration;\n\t\t\tState.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);\n\t\t\tDirtyPlayerState();\n\t\t\tdouble num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);\n\t\t\tClientRPCPlayer(null, this, \u0022SetHostileLength\u0022, (float)num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnProjectileRicochet(BasePlayer basePlayer, ProtoBuf.PlayerProjectileRicochet playerProjectileRicochet)",
    "MethodSignature": "OnProjectileRicochet(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void OnProjectileRicochet(RPCMessage msg)\n\t{\n\t\tPlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);\n\t\tif (playerProjectileRicochet != null)\n\t\t{\n\t\t\tFiredProjectile value;\n\t\t\tif (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnProjectileRicochet\u0022, this, playerProjectileRicochet) == null)\n\t\t\t{\n\t\t\t\tvalue.ricochets\u002B\u002B;\n\t\t\t\tfiredProjectiles[playerProjectileRicochet.projectileID] = value;\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnExperimentEnded(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnPlayerWantsMount(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsMount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_WantsMount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (DirectlyMountable() \u0026\u0026 Interface.CallHook(\u0022OnPlayerWantsMount\u0022, player, this) == null)\n\t\t{\n\t\t\tAttemptMount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnLootNetworkUpdate(PlayerLoot playerLoot)",
    "MethodSignature": "SendUpdate()",
    "MethodSourseCode": "\n\tprivate void SendUpdate()\n\t{\n\t\tisInvokingSendUpdate = false;\n\t\tif (!base.baseEntity.IsValid() || Interface.CallHook(\u0022OnLootNetworkUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing PlayerUpdateLoot playerUpdateLoot = Pool.Get\u003CPlayerUpdateLoot\u003E();\n\t\tif ((bool)entitySource \u0026\u0026 entitySource.net != null)\n\t\t{\n\t\t\tplayerUpdateLoot.entityID = entitySource.net.ID;\n\t\t}\n\t\tif (itemSource != null)\n\t\t{\n\t\t\tplayerUpdateLoot.itemID = itemSource.uid;\n\t\t}\n\t\tif (containers.Count \u003E 0)\n\t\t{\n\t\t\tplayerUpdateLoot.containers = Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tforeach (ItemContainer container in containers)\n\t\t\t{\n\t\t\t\tplayerUpdateLoot.containers.Add(container.Save());\n\t\t\t}\n\t\t}\n\t\tbase.baseEntity.ClientRPCPlayer(null, base.baseEntity, \u0022UpdateLoot\u0022, playerUpdateLoot);\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "RunMetabolism(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tprotected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRunPlayerMetabolism\u0022, this, ownerEntity, delta) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat currentTemperature = owner.currentTemperature;\n\t\tfloat fTarget = owner.currentComfort;\n\t\tfloat currentCraftLevel = owner.currentCraftLevel;\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());\n\t\tfloat num = currentTemperature;\n\t\tnum -= DeltaWet() * 34f;\n\t\tfloat num2 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);\n\t\tfloat num3 = Mathf.InverseLerp(20f, -50f, currentTemperature);\n\t\tfloat num4 = Mathf.InverseLerp(20f, 30f, currentTemperature);\n\t\tnum \u002B= num3 * 70f * num2;\n\t\tnum \u002B= num4 * 10f * Mathf.Abs(num2);\n\t\tnum \u002B= heartrate.value * 5f;\n\t\ttemperature.MoveTowards(num, delta * 5f);\n\t\tif (temperature.value \u003E= 40f)\n\t\t{\n\t\t\tfTarget = 0f;\n\t\t}\n\t\tcomfort.MoveTowards(fTarget, delta / 5f);\n\t\tfloat num5 = 0.6f \u002B 0.4f * comfort.value;\n\t\tif (calories.value \u003E 100f \u0026\u0026 owner.healthFraction \u003C num5 \u0026\u0026 radiation_poison.Fraction() \u003C 0.25f \u0026\u0026 owner.SecondsSinceAttacked \u003E 10f \u0026\u0026 !SignificantBleeding() \u0026\u0026 temperature.value \u003E= 10f \u0026\u0026 hydration.value \u003E 40f)\n\t\t{\n\t\t\tfloat num6 = Mathf.InverseLerp(calories.min, calories.max, calories.value);\n\t\t\tfloat num7 = 5f;\n\t\t\tfloat num8 = num7 * owner.MaxHealth() * 0.8f / 600f;\n\t\t\tnum8 \u002B= num8 * num6 * 0.5f;\n\t\t\tfloat num9 = num8 / num7;\n\t\t\tnum9 \u002B= num9 * comfort.value * 6f;\n\t\t\townerEntity.Heal(num9 * delta);\n\t\t\tcalories.Subtract(num8 * delta);\n\t\t\thydration.Subtract(num8 * delta * 0.2f);\n\t\t}\n\t\tfloat num10 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;\n\t\tfloat fTarget2 = Mathf.Clamp(0.05f \u002B num10, 0f, 1f);\n\t\theartrate.MoveTowards(fTarget2, delta * 0.1f);\n\t\tif (!owner.IsGod())\n\t\t{\n\t\t\tfloat num11 = heartrate.Fraction() * 0.375f;\n\t\t\tcalories.MoveTowards(0f, delta * num11);\n\t\t\tfloat num12 = 1f / 120f;\n\t\t\tnum12 \u002B= Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);\n\t\t\tnum12 \u002B= heartrate.value * (1f / 15f);\n\t\t\thydration.MoveTowards(0f, delta * num12);\n\t\t}\n\t\tbool b = hydration.Fraction() \u003C= 0f || radiation_poison.value \u003E= 100f;\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);\n\t\tif (temperature.value \u003E 40f)\n\t\t{\n\t\t\thydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);\n\t\t}\n\t\tif (temperature.value \u003C 10f)\n\t\t{\n\t\t\tfloat num13 = Mathf.InverseLerp(20f, -100f, temperature.value);\n\t\t\theartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num13), delta * 2f * num13);\n\t\t}\n\t\tfloat num14 = owner.WaterFactor();\n\t\tif (num14 \u003E 0.85f)\n\t\t{\n\t\t\toxygen.MoveTowards(0f, delta * 0.1f);\n\t\t}\n\t\telse\n\t\t{\n\t\t\toxygen.MoveTowards(1f, delta * 1f);\n\t\t}\n\t\tfloat f = 0f;\n\t\tfloat f2 = 0f;\n\t\tif (owner.IsOutside(owner.eyes.position))\n\t\t{\n\t\t\tf = Climate.GetRain(owner.eyes.position) * Weather.wetness_rain;\n\t\t\tf2 = Climate.GetSnow(owner.eyes.position) * Weather.wetness_snow;\n\t\t}\n\t\tbool flag = owner.baseProtection.amounts[4] \u003E 0f;\n\t\tfloat currentEnvironmentalWetness = owner.currentEnvironmentalWetness;\n\t\tcurrentEnvironmentalWetness = Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);\n\t\tif (!flag \u0026\u0026 num14 \u003E 0f)\n\t\t{\n\t\t\twetness.value = Mathf.Max(wetness.value, Mathf.Clamp(num14, wetness.min, wetness.max));\n\t\t}\n\t\tfloat num15 = Mathx.Max(wetness.value, f, f2, currentEnvironmentalWetness);\n\t\tnum15 = Mathf.Min(num15, flag ? 0f : num15);\n\t\twetness.MoveTowards(num15, delta * 0.05f);\n\t\tif (num14 \u003C wetness.value \u0026\u0026 currentEnvironmentalWetness \u003C= 0f)\n\t\t{\n\t\t\twetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, currentTemperature));\n\t\t}\n\t\tpoison.MoveTowards(0f, delta * (5f / 9f));\n\t\tif (wetness.Fraction() \u003E 0.4f \u0026\u0026 owner.estimatedSpeed \u003E 0.25f \u0026\u0026 radiation_level.Fraction() == 0f)\n\t\t{\n\t\t\tradiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);\n\t\t}\n\t\tif (ConVar.Server.radiation \u0026\u0026 !owner.IsGod())\n\t\t{\n\t\t\tradiation_level.value = owner.radiationLevel;\n\t\t\tif (radiation_level.value \u003E 0f)\n\t\t\t{\n\t\t\t\tradiation_poison.Add(radiation_level.value * delta);\n\t\t\t}\n\t\t}\n\t\tif (pending_health.value \u003E 0f)\n\t\t{\n\t\t\tfloat num16 = Mathf.Min(1f * delta, pending_health.value);\n\t\t\townerEntity.Heal(num16);\n\t\t\tif (ownerEntity.healthFraction == 1f)\n\t\t\t{\n\t\t\t\tpending_health.value = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpending_health.Subtract(num16);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamCreated(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = Instance.CreateTeam();\n\t\t\tplayerTeam.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam.AddPlayer(basePlayer);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnServerMessage(string message, string username, string color, ulong userid)",
    "MethodSignature": "Broadcast(string message, string username, string color, ulong userid)",
    "MethodSourseCode": "\n\tpublic static void Broadcast(string message, string username = \u0022SERVER\u0022, string color = \u0022#eee\u0022, ulong userid = 0uL)\n\t{\n\t\tif (Interface.CallHook(\u0022OnServerMessage\u0022, message, username, color, userid) == null)\n\t\t{\n\t\t\tstring text = username.EscapeRichText();\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=\u0022 \u002B color \u002B \u0022\u003E\u0022 \u002B text \u002B \u0022\u003C/color\u003E \u0022 \u002B message);\n\t\t\tChatEntry chatEntry = default(ChatEntry);\n\t\t\tchatEntry.Channel = ChatChannel.Server;\n\t\t\tchatEntry.Message = message;\n\t\t\tchatEntry.UserId = userid.ToString();\n\t\t\tchatEntry.Username = username;\n\t\t\tchatEntry.Color = color;\n\t\t\tchatEntry.Time = Epoch.Current;\n\t\t\tChatEntry chatEntry2 = chatEntry;\n\t\t\tHistory.Add(chatEntry2);\n\t\t\tRCon.Broadcast(RCon.LogType.Chat, chatEntry2);\n\t\t}\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnNpcTarget(BaseNpc baseNpc, BaseEntity AiContextAIAgentAttackTarget)",
    "MethodSignature": "AggroClosestEnemy()",
    "MethodSourseCode": "\n\tprivate void AggroClosestEnemy()\n\t{\n\t\tfloat num = float.MaxValue;\n\t\tBasePlayer basePlayer = null;\n\t\tBaseNpc baseNpc = null;\n\t\tAiContext.AIAgent.AttackTarget = null;\n\t\tVector3 vector = Vector3.zero;\n\t\tfloat num2 = 0f;\n\t\tfloat num3 = 0f;\n\t\tforeach (BasePlayer player in AiContext.Players)\n\t\t{\n\t\t\tif (player.IsDead() || player.IsDestroyed || (blockTargetingThisEnemy != null \u0026\u0026 player.net != null \u0026\u0026 blockTargetingThisEnemy.net != null \u0026\u0026 player.net.ID == blockTargetingThisEnemy.net.ID) || player.currentSafeLevel \u003E 0f)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVector3 vector2 = player.ServerPosition - ServerPosition;\n\t\t\tfloat sqrMagnitude = vector2.sqrMagnitude;\n\t\t\tnum2 \u002B= Mathf.Min(Mathf.Sqrt(sqrMagnitude), Stats.VisionRange) / Stats.VisionRange;\n\t\t\tif (sqrMagnitude \u003C num)\n\t\t\t{\n\t\t\t\tnum = sqrMagnitude;\n\t\t\t\tbasePlayer = player;\n\t\t\t\tbaseNpc = null;\n\t\t\t\tvector = vector2;\n\t\t\t\tif (num \u003C= AttackRange)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num \u003E AttackRange)\n\t\t{\n\t\t\tforeach (BaseNpc npc in AiContext.Npcs)\n\t\t\t{\n\t\t\t\tif (npc.IsDead() || npc.IsDestroyed || Stats.Family == npc.Stats.Family)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tVector3 vector3 = npc.ServerPosition - ServerPosition;\n\t\t\t\tfloat sqrMagnitude2 = vector3.sqrMagnitude;\n\t\t\t\tnum3 \u002B= Mathf.Min(Mathf.Sqrt(sqrMagnitude2), Stats.VisionRange) / Stats.VisionRange;\n\t\t\t\tif (sqrMagnitude2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tnum = sqrMagnitude2;\n\t\t\t\t\tbaseNpc = npc;\n\t\t\t\t\tbasePlayer = null;\n\t\t\t\t\tvector = vector3;\n\t\t\t\t\tif (num \u003C AttackRange)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num \u003E AttackRange)\n\t\t{\n\t\t\tif (AiContext.PlayersBehindUs.Count \u003E 0)\n\t\t\t{\n\t\t\t\tbasePlayer = AiContext.PlayersBehindUs[0];\n\t\t\t\tbaseNpc = null;\n\t\t\t}\n\t\t\telse if (AiContext.NpcsBehindUs.Count \u003E 0)\n\t\t\t{\n\t\t\t\tbasePlayer = null;\n\t\t\t\tbaseNpc = AiContext.NpcsBehindUs[0];\n\t\t\t}\n\t\t}\n\t\tif (AiContext.EnemyPlayer == null || AiContext.EnemyPlayer.IsDestroyed || AiContext.EnemyPlayer.IsDead() || num2 \u003E AiContext.LastEnemyPlayerScore \u002B DecisionMomentumPlayerTarget())\n\t\t{\n\t\t\tAiContext.EnemyPlayer = basePlayer;\n\t\t\tAiContext.LastEnemyPlayerScore = num2;\n\t\t\tplayerTargetDecisionStartTime = UnityEngine.Time.time;\n\t\t}\n\t\telse if (basePlayer == null \u0026\u0026 DecisionMomentumPlayerTarget() \u003C 0.01f)\n\t\t{\n\t\t\tAiContext.EnemyPlayer = basePlayer;\n\t\t\tAiContext.LastEnemyPlayerScore = 0f;\n\t\t\tplayerTargetDecisionStartTime = 0f;\n\t\t}\n\t\tif (AiContext.EnemyNpc == null || AiContext.EnemyNpc.IsDestroyed || AiContext.EnemyNpc.IsDead() || num3 \u003E AiContext.LastEnemyNpcScore \u002B DecisionMomentumAnimalTarget())\n\t\t{\n\t\t\tAiContext.EnemyNpc = baseNpc;\n\t\t\tAiContext.LastEnemyNpcScore = num3;\n\t\t\tanimalTargetDecisionStartTime = UnityEngine.Time.time;\n\t\t}\n\t\telse if (baseNpc == null \u0026\u0026 DecisionMomentumAnimalTarget() \u003C 0.01f)\n\t\t{\n\t\t\tAiContext.EnemyNpc = baseNpc;\n\t\t\tAiContext.LastEnemyNpcScore = 0f;\n\t\t\tanimalTargetDecisionStartTime = 0f;\n\t\t}\n\t\tif (basePlayer != null || baseNpc != null)\n\t\t{\n\t\t\tSetFact(Facts.HasEnemy, 1);\n\t\t\tif (basePlayer != null)\n\t\t\t{\n\t\t\t\tAiContext.AIAgent.AttackTarget = basePlayer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAiContext.AIAgent.AttackTarget = baseNpc;\n\t\t\t}\n\t\t\tfloat magnitude = vector.magnitude;\n\t\t\tif (Interface.CallHook(\u0022IOnNpcTarget\u0022, this, AiContext.AIAgent.AttackTarget) == null)\n\t\t\t{\n\t\t\t\tEnemyRangeEnum enemyRangeEnum = ToEnemyRangeEnum(magnitude);\n\t\t\t\tAfraidRangeEnum value = ToAfraidRangeEnum(magnitude);\n\t\t\t\tSetFact(Facts.EnemyRange, (byte)enemyRangeEnum);\n\t\t\t\tSetFact(Facts.AfraidRange, (byte)value);\n\t\t\t\tTryAggro(enemyRangeEnum);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetFact(Facts.HasEnemy, 0);\n\t\t\tSetFact(Facts.EnemyRange, 3);\n\t\t\tSetFact(Facts.AfraidRange, 1);\n\t\t}\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 104
  },
  {
    "HookSignature": "OnNpcEquipWeapon(ScientistNPC scientistNPC, Item item)",
    "MethodSignature": "EquipWeapon()",
    "MethodSourseCode": "\n\tpublic override void EquipWeapon()\n\t{\n\t\tbase.EquipWeapon();\n\t\tHeldEntity heldEntity = GetHeldEntity();\n\t\tif (!(heldEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = heldEntity.GetItem();\n\t\tif (item == null || item.contents == null || Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0, 3) == 0)\n\t\t{\n\t\t\tItem item2 = ItemManager.CreateByName(\u0022weapon.mod.flashlight\u0022, 1, 0uL);\n\t\t\tif (!item2.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem2.Remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlightsOn = false;\n\t\t\tInvokeRandomized(base.LightCheck, 0f, 30f, 5f);\n\t\t\tLightCheck();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tItem item3 = ItemManager.CreateByName(\u0022weapon.mod.lasersight\u0022, 1, 0uL);\n\t\t\tif (!item3.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem3.Remove();\n\t\t\t}\n\t\t\tLightToggle();\n\t\t\tlightsOn = true;\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTeamRejectInvite(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "rejectinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void rejectinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = Instance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamRejectInvite\u0022, basePlayer, playerTeam) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RejectInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnReloadWeapon(BasePlayer player, BaseProjectile baseProjectile)",
    "MethodSignature": "StartReload(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void StartReload(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientRPC(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treloadStarted = false;\n\t\t\treloadFinished = false;\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnReloadWeapon\u0022, player, this) == null)\n\t\t{\n\t\t\treloadFinished = false;\n\t\t\treloadStarted = true;\n\t\t\tfractionalInsertCounter = 0;\n\t\t\tif (CanRefundAmmo)\n\t\t\t{\n\t\t\t\tprimaryMagazine.SwitchAmmoTypesIfNeeded(player);\n\t\t\t}\n\t\t\tStartReloadCooldown(GetReloadDuration());\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnItemUse(Item item, int amountToConsume)",
    "MethodSignature": "UseItem(int amountToConsume)",
    "MethodSourseCode": "\n\tpublic void UseItem(int amountToConsume = 1)\n\t{\n\t\tif (amountToConsume \u003E 0)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemUse\u0022, this, amountToConsume);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tamountToConsume = (int)obj;\n\t\t\t}\n\t\t\tamount -= amountToConsume;\n\t\t\tif (amount \u003C= 0)\n\t\t\t{\n\t\t\t\tamount = 0;\n\t\t\t\tRemove();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSpectateTarget(BasePlayer basePlayer, string strName)",
    "MethodSignature": "UpdateSpectateTarget(string strName)",
    "MethodSourseCode": "\n\tpublic void UpdateSpectateTarget(string strName)\n\t{\n\t\tif (Interface.CallHook(\u0022CanSpectateTarget\u0022, this, strName) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tspectateFilter = strName;\n\t\tIEnumerable\u003CBaseEntity\u003E enumerable = null;\n\t\tif (spectateFilter.StartsWith(\u0022@\u0022))\n\t\t{\n\t\t\tstring filter = spectateFilter.Substring(1);\n\t\t\tenumerable = (from x in BaseNetworkable.serverEntities\n\t\t\t\twhere x.name.Contains(filter, CompareOptions.IgnoreCase)\n\t\t\t\twhere x != this\n\t\t\t\tselect x).Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIEnumerable\u003CBasePlayer\u003E source = activePlayerList.Where((BasePlayer x) =\u003E !x.IsSpectating() \u0026\u0026 !x.IsDead() \u0026\u0026 !x.IsSleeping());\n\t\t\tif (strName.Length \u003E 0)\n\t\t\t{\n\t\t\t\tsource = from x in source\n\t\t\t\t\twhere x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)\n\t\t\t\t\twhere x != this\n\t\t\t\t\tselect x;\n\t\t\t}\n\t\t\tsource = source.OrderBy((BasePlayer x) =\u003E x.displayName);\n\t\t\tenumerable = source.Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\tBaseEntity[] array = enumerable.ToArray();\n\t\tif (array.Length == 0)\n\t\t{\n\t\t\tChatMessage(\u0022No valid spectate targets!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = array[SpectateOffset % array.Length];\n\t\tif (!(baseEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (baseEntity is BasePlayer)\n\t\t{\n\t\t\tChatMessage(\u0022Spectating: \u0022 \u002B (baseEntity as BasePlayer).displayName);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tChatMessage(\u0022Spectating: \u0022 \u002B baseEntity.ToString());\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendEntitySnapshot\u0022))\n\t\t{\n\t\t\tSendEntitySnapshot(baseEntity);\n\t\t}\n\t\tUnityEngine.TransformEx.Identity(base.gameObject);\n\t\tusing (TimeWarning.New(\u0022SetParent\u0022))\n\t\t{\n\t\t\tSetParent(baseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneNameUpdate(PhoneController phoneController, string text, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 20)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 20);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTakeCurrencyItem(NPCVendingMachine nPCVendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic override void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null)\n\t\t{\n\t\t\ttakenCurrencyItem.MoveToContainer(base.inventory);\n\t\t\ttakenCurrencyItem.RemoveFromContainer();\n\t\t\ttakenCurrencyItem.Remove();\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanChangeCode(BasePlayer rpcPlayer, CodeLock codeLock, string text, bool flag)",
    "MethodSignature": "RPC_ChangeCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_ChangeCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tbool flag = rpc.read.Bit();\n\t\tif (IsLocked() || text.Length != 4 || !text.IsNumeric() || (!hasCode \u0026\u0026 flag))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!hasCode \u0026\u0026 !flag)\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t}\n\t\tif (Interface.CallHook(\u0022CanChangeCode\u0022, rpc.player, this, text, flag) == null)\n\t\t{\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcode = text;\n\t\t\t\thasCode = code.Length \u003E 0;\n\t\t\t\twhitelistPlayers.Clear();\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tguestCode = text;\n\t\t\t\thasGuestCode = guestCode.Length \u003E 0;\n\t\t\t\tguestPlayers.Clear();\n\t\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnStashHidden(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanEquipItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanEquipItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tprivate bool CanEquipItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEquipItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tItemModContainerRestriction component = item.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tItem[] array = containerBelt.itemList.ToArray();\n\t\tforeach (Item item2 in array)\n\t\t{\n\t\t\tif (item2 != item)\n\t\t\t{\n\t\t\t\tItemModContainerRestriction component2 = item2.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2) \u0026\u0026 !item2.MoveToContainer(containerMain))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable baseNetworkable, Network.Connection connection)",
    "MethodSignature": "SendAsSnapshot(Connection connection, bool justCreated)",
    "MethodSourseCode": "\n\tpublic void SendAsSnapshot(Connection connection, bool justCreated = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, this, connection) == null \u0026\u0026 Network.Net.sv.write.Start())\n\t\t{\n\t\t\tconnection.validate.entityUpdates\u002B\u002B;\n\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\tsaveInfo.forConnection = connection;\n\t\t\tsaveInfo.forDisk = false;\n\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.Entities);\n\t\t\tNetwork.Net.sv.write.UInt32(connection.validate.entityUpdates);\n\t\t\tToStreamForNetwork(Network.Net.sv.write, saveInfo2);\n\t\t\tNetwork.Net.sv.write.Send(new SendInfo(connection));\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTriggerParent triggerParent = player.FindTrigger\u003CTriggerParent\u003E();\n\t\t\tif ((bool)triggerParent)\n\t\t\t{\n\t\t\t\ttriggerParent.OnTriggerExit(player.GetComponent\u003CCollider\u003E());\n\t\t\t}\n\t\t\tplayer.MountObject(this);\n\t\t\tplayer.MovePosition(mountAnchor.transform.position);\n\t\t\tplayer.transform.rotation = mountAnchor.transform.rotation;\n\t\t\tplayer.ServerRotation = mountAnchor.transform.rotation;\n\t\t\tplayer.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, player.transform.position);\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnShopAcceptClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "AcceptClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void AcceptClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 !(vendorPlayer == null) \u0026\u0026 !(customerPlayer == null) \u0026\u0026 Interface.CallHook(\u0022OnShopAcceptClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tif (IsPlayerVendor(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\t\tvendorInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\telse if (IsPlayerCustomer(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tcustomerInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\tif (HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t\t\tInvoke(CompleteTrade, 2f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanAffordToPlace(BasePlayer ownerPlayer, Planner planner, Construction component)",
    "MethodSignature": "CanAffordToPlace(Construction component)",
    "MethodSourseCode": "\n\tpublic bool CanAffordToPlace(Construction component)\n\t{\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAffordToPlace\u0022, ownerPlayer, this, component);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount item in component.defaultGrade.costToBuild)\n\t\t{\n\t\t\tif ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnDispenserGather(ResourceDispenser resourceDispenser, BaseEntity entity, Item item)",
    "MethodSignature": "GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)",
    "MethodSourseCode": "\n\tprivate void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\n\t{\n\t\tif (itemAmt.amount == 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\n\t\tfloat num2 = itemAmt.startAmount / startingItemCounts;\n\t\tfloat num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\n\t\tfloat num4 = num3 * destroyFraction * 2f;\n\t\tif (itemAmt.amount \u003C= num3 \u002B num4)\n\t\t{\n\t\t\tfloat num5 = (num3 \u002B num4) / itemAmt.amount;\n\t\t\tnum3 /= num5;\n\t\t\tnum4 /= num5;\n\t\t}\n\t\titemAmt.amount -= Mathf.Floor(num3);\n\t\titemAmt.amount -= Mathf.Floor(num4);\n\t\tif (num3 \u003C 1f)\n\t\t{\n\t\t\tnum3 = ((UnityEngine.Random.Range(0f, 1f) \u003C= num3) ? 1f : 0f);\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (itemAmt.amount \u003C 0f)\n\t\t{\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (num3 \u003E= 1f)\n\t\t{\n\t\t\tint num6 = CalculateGatherBonus(entity, itemAmt, num3);\n\t\t\tint iAmount = Mathf.FloorToInt(num3) \u002B num6;\n\t\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnDispenserGather\u0022, this, entity, item) == null)\n\t\t\t{\n\t\t\t\tOverrideOwnership(item, attackWeapon);\n\t\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnPlayerWantsDismount(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsDismount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsDismount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (HasValidDismountPosition(player) \u0026\u0026 Interface.CallHook(\u0022OnPlayerWantsDismount\u0022, player, this) == null)\n\t\t{\n\t\t\tAttemptDismount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMixingTableToggle(MixingTable mixingTable, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMixingTableToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag != IsOn() \u0026\u0026 !(msg.player == null))\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tStartMixing(msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStopMixing();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MixingTable",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity ent)",
    "MethodSignature": "VisibilityTest(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic bool VisibilityTest(BaseEntity ent)\n\t{\n\t\tif (ent == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Vector3.Distance(ent.transform.position, base.transform.position) \u003C viewDistance))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = false;\n\t\tif (ent is BasePlayer)\n\t\t{\n\t\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\t\tVector3 position = mainTurret.transform.position;\n\t\t\tflag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position \u002B Vector3.up * 0.1f, position);\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tflag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Standard vis test!\u0022);\n\t\t\tflag = IsVisible(ent.CenterPoint());\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanBradleyApcTarget\u0022, this, ent);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnTakeCurrencyItem(VendingMachine vendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic virtual void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null \u0026\u0026 !takenCurrencyItem.MoveToContainer(base.inventory))\n\t\t{\n\t\t\ttakenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, FlameTurret flameTurret)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tif (Time.realtimeSinceStartup \u003C nextTriggerCheckTime)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tnextTriggerCheckTime = Time.realtimeSinceStartup \u002B 1f / triggerCheckRate;\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tbool flag = false;\n\t\tif (entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity item in entityContents)\n\t\t\t{\n\t\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (component.IsSleeping() || !component.IsAlive())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\t\tif (obj2 is bool)\n\t\t\t\t{\n\t\t\t\t\tPool.FreeList(ref obj);\n\t\t\t\t\treturn (bool)obj2;\n\t\t\t\t}\n\t\t\t\tif (!(component.transform.position.y \u003C= GetEyePosition().y \u002B 0.5f) || component.IsBuildingAuthed())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobj.Clear();\n\t\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "FlameTurret",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnItemSkinChange(int num, Item slot, RepairBench repairBench, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ChangeSkin(RPCMessage msg)\n\t{\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003C nextSkinChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tItem slot = base.inventory.GetSlot(0);\n\t\tif (slot == null || Interface.CallHook(\u0022OnItemSkinChange\u0022, num, slot, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (num != 0 \u0026\u0026 !flag \u0026\u0026 !player.blueprints.CheckSkinOwnership(num, player.userID))\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin player does not have item :\u0022 \u002B num \u002B \u0022:\u0022);\n\t\t\treturn;\n\t\t}\n\t\tulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);\n\t\tif (Skin == slot.skin \u0026\u0026 slot.info.isRedirectOf == null)\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin cannot apply same skin twice : \u0022 \u002B Skin \u002B \u0022: \u0022 \u002B slot.skin);\n\t\t\treturn;\n\t\t}\n\t\tnextSkinChangeTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.75f;\n\t\tItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\tif (slot.info.isRedirectOf != null)\n\t\t{\n\t\t\tSkin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);\n\t\t\tskin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\t}\n\t\tItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));\n\t\tif ((bool)itemSkin \u0026\u0026 (itemSkin.Redirect != null || slot.info.isRedirectOf != null))\n\t\t{\n\t\t\tItemDefinition template = itemSkin.Redirect;\n\t\t\tbool flag2 = false;\n\t\t\tif (itemSkin.Redirect == null \u0026\u0026 slot.info.isRedirectOf != null)\n\t\t\t{\n\t\t\t\ttemplate = slot.info.isRedirectOf;\n\t\t\t\tflag2 = num != 0;\n\t\t\t}\n\t\t\tfloat condition = slot.condition;\n\t\t\tfloat maxCondition = slot.maxCondition;\n\t\t\tslot.Remove();\n\t\t\tItemManager.DoRemoves();\n\t\t\tItem item = ItemManager.Create(template, 1, 0uL);\n\t\t\titem.MoveToContainer(base.inventory, 0, allowStack: false);\n\t\t\titem.maxCondition = maxCondition;\n\t\t\titem.condition = condition;\n\t\t\tif (flag2)\n\t\t\t{\n\t\t\t\tApplySkinToItem(item, Skin);\n\t\t\t}\n\t\t}\n\t\telse if (!itemSkin \u0026\u0026 slot.info.isRedirectOf != null)\n\t\t{\n\t\t\tItemDefinition isRedirectOf = slot.info.isRedirectOf;\n\t\t\tfloat condition2 = slot.condition;\n\t\t\tfloat maxCondition2 = slot.maxCondition;\n\t\t\tslot.Remove();\n\t\t\tItemManager.DoRemoves();\n\t\t\tItem item2 = ItemManager.Create(isRedirectOf, 1, Skin);\n\t\t\titem2.MoveToContainer(base.inventory, 0, allowStack: false);\n\t\t\titem2.maxCondition = maxCondition2;\n\t\t\titem2.condition = condition2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tApplySkinToItem(slot, Skin);\n\t\t}\n\t\tif (skinchangeEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanNpcEat(BaseNpc baseNpc, BaseEntity best)",
    "MethodSignature": "WantsToEat(BaseEntity best)",
    "MethodSourseCode": "\n\tpublic virtual bool WantsToEat(BaseEntity best)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNpcEat\u0022, this, best);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!best.HasTrait(TraitFlag.Food))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (best.HasTrait(TraitFlag.Alive))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoPlaneSignaled(BaseEntity baseEntity, SupplySignal supplySignal)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\n\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, base.transform.position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.Spawn();\n\t\t\tInterface.CallHook(\u0022OnCargoPlaneSignaled\u0022, baseEntity, this);\n\t\t}\n\t\tInvoke(FinishUp, 210f);\n\t\tSetFlag(Flags.On, b: true);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "SupplySignal",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanNetworkTo(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (IsSpectating() \u0026\u0026 player != this \u0026\u0026 !player.net.connection.info.GetBool(\u0022global.specnet\u0022))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn base.ShouldNetworkTo(player);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearch(ResearchTable researchTable, Item targetItem, BasePlayer player)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnSpinWheel(BasePlayer rpcPlayer, SpinnerWheel spinnerWheel)",
    "MethodSignature": "RPC_Spin(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Spin(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 AllowPlayerSpins() \u0026\u0026 (AnyoneSpin() || rpc.player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022OnSpinWheel\u0022, rpc.player, this) == null \u0026\u0026 !(velocity \u003E 15f))\n\t\t{\n\t\t\tvelocity \u002B= UnityEngine.Random.Range(4f, 7f);\n\t\t}\n\t}\n",
    "ClassName": "SpinnerWheel",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanHackCrate(BasePlayer msgPlayer, HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "RPC_Hack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Hack(RPCMessage msg)\n\t{\n\t\tif (!IsBeingHacked() \u0026\u0026 Interface.CallHook(\u0022CanHackCrate\u0022, msg.player, this) == null)\n\t\t{\n\t\t\tStartHacking();\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AddSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tAddPlayer(rpc.player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnWorldPrefabSpawned(UnityEngine.GameObject gameObject, string category)",
    "MethodSignature": "Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)",
    "MethodSourseCode": "\n\tprivate static void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)\n\t{\n\t\tif ((bool)prefab.Object)\n\t\t{\n\t\t\tif (!Cached)\n\t\t\t{\n\t\t\t\tprefab.ApplyTerrainPlacements(position, rotation, scale);\n\t\t\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\n\t\t\t}\n\t\t\tGameObject gameObject = prefab.Spawn(position, rotation, scale);\n\t\t\tif ((bool)gameObject)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnWorldPrefabSpawned\u0022, gameObject, category);\n\t\t\t\tGameObjectEx.SetHierarchyGroup(gameObject, category);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "World",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPhoneDialTimeout(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount, bool free)",
    "MethodSignature": "CanCraft(ItemBlueprint bp, int amount, bool free)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)\n\t{\n\t\tfloat num = (float)amount / (float)bp.targetItem.craftingStackable;\n\t\tforeach (ItemCraftTask item in queue)\n\t\t{\n\t\t\tif (!item.cancelled)\n\t\t\t{\n\t\t\t\tnum \u002B= (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;\n\t\t\t}\n\t\t}\n\t\tif (num \u003E 8f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (amount \u003C 1 || amount \u003E bp.targetItem.craftingStackable)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, bp, amount, free);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount ingredient in bp.ingredients)\n\t\t{\n\t\t\tif (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnCupboardProtectionCalculated(BuildingPrivlidge buildingPrivlidge, float cachedProtectedMinutes)",
    "MethodSignature": "GetProtectedMinutes(bool force)",
    "MethodSourseCode": "\n\tpublic float GetProtectedMinutes(bool force = false)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (!force \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003C nextProtectedCalcTime)\n\t\t\t{\n\t\t\t\treturn cachedProtectedMinutes;\n\t\t\t}\n\t\t\tnextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup \u002B 60f;\n\t\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.GetList\u003CItemAmount\u003E();\n\t\t\tCalculateUpkeepCostAmounts(obj);\n\t\t\tfloat num = CalculateUpkeepPeriodMinutes();\n\t\t\tfloat num2 = -1f;\n\t\t\tif (base.inventory != null)\n\t\t\t{\n\t\t\t\tforeach (ItemAmount item in obj)\n\t\t\t\t{\n\t\t\t\t\tint num3 = base.inventory.FindItemsByItemID(item.itemid).Sum((Item x) =\u003E x.amount);\n\t\t\t\t\tif (num3 \u003E 0 \u0026\u0026 item.amount \u003E 0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num4 = (float)num3 / item.amount * num;\n\t\t\t\t\t\tif (num2 == -1f || num4 \u003C num2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum2 = num4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2 = 0f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num2 == -1f)\n\t\t\t\t{\n\t\t\t\t\tnum2 = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\tcachedProtectedMinutes = num2;\n\t\t\tInterface.CallHook(\u0022OnCupboardProtectionCalculated\u0022, this, cachedProtectedMinutes);\n\t\t\treturn cachedProtectedMinutes;\n\t\t}\n\t\treturn 0f;\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnTurretToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetIsOnline(bool online)",
    "MethodSourseCode": "\n\tpublic void SetIsOnline(bool online)\n\t{\n\t\tif (online != HasFlag(Flags.On) \u0026\u0026 Interface.CallHook(\u0022OnTurretToggle\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, online);\n\t\t\tbooting = false;\n\t\t\tSendNetworkUpdate();\n\t\t\tif (IsOffline())\n\t\t\t{\n\t\t\t\tSetTarget(null);\n\t\t\t\tisLootable = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tisLootable = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemUpgrade(Item item, Item item2, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (!(command == \u0022upgrade_item\u0022) || item.amount \u003C numForUpgrade)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= upgradeSuccessChance)\n\t\t{\n\t\t\titem.UseItem(numForUpgrade);\n\t\t\tItem item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);\n\t\t\tInterface.CallHook(\u0022OnItemUpgrade\u0022, item, item2, player);\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem(numToLoseOnFail);\n\t\t\tif (failEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(failEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModUpgrade",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, ItemModDeployable modDeployable)",
    "MethodSignature": "DoDeploy_Regular(Deployable deployable, Ray ray)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Regular(Deployable deployable, Ray ray)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at player position!\u0022);\n\t\t}\n\t\telse if (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredAntiHack())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022AntiHack!\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tQuaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\tif (ownerPlayer.Distance(point) \u003E 3f)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Too far away!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at placement position!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tDebug.LogWarning(\u0022Couldn\u0027t create prefab:\u0022 \u002B modDeployable.entityPrefab.resourcePath);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tbaseEntity.SendMessage(\u0022SetDeployedBy\u0022, ownerPlayer, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity.Spawn();\n\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, modDeployable);\n\t\t\tUseItemAmount(1);\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection packetConnection, string itemName, string itemValue)",
    "MethodSignature": "ClientReady(Message packet)",
    "MethodSourseCode": "\n\tprivate void ClientReady(Message packet)\n\t{\n\t\tif (packet.connection.state != Network.Connection.State.Welcoming)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.decryptIncoming = true;\n\t\tusing (ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read))\n\t\t{\n\t\t\tforeach (ClientReady.ClientInfo item in clientReady.clientInfo)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, packet.connection, item.name, item.value);\n\t\t\t\tpacket.connection.info.Set(item.name, item.value);\n\t\t\t}\n\t\t\tconnectionQueue.JoinedGame(packet.connection);\n\t\t\tusing (TimeWarning.New(\u0022ClientReady\u0022))\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer;\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnPlayerSleeping\u0022))\n\t\t\t\t{\n\t\t\t\t\tbasePlayer = SpawnPlayerSleeping(packet.connection);\n\t\t\t\t}\n\t\t\t\tif (basePlayer == null)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022SpawnNewPlayer\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tbasePlayer = SpawnNewPlayer(packet.connection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (basePlayer != null)\n\t\t\t\t{\n\t\t\t\t\tUtil.SendSignedInNotification(basePlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendReplicatedVars(packet.connection);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnDieselEngineToggled(DieselEngine dieselEngine)",
    "MethodSignature": "EngineOff()",
    "MethodSourseCode": "\n\tpublic void EngineOff()\n\t{\n\t\tSetFlag(Flags.On, b: false);\n\t\tBroadcastEntityMessage(\u0022DieselEngineOff\u0022);\n\t\tInterface.CallHook(\u0022OnDieselEngineToggled\u0022, this);\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnNpcSenseVision(NPCPlayerApex nPCPlayerApex)",
    "MethodSignature": "_FindPlayersInVisionRange()",
    "MethodSourseCode": "\n\tprivate void _FindPlayersInVisionRange()\n\t{\n\t\tif (AI.ignoreplayers || base.transform == null || Interface.CallHook(\u0022IOnNpcSenseVision\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerQueryResultCount = Query.Server.GetPlayersInSphere(base.transform.position, Stats.VisionRange, PlayerQueryResults, delegate(BasePlayer player)\n\t\t{\n\t\t\tif (player == null || !player.isServer || player.IsDead())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (player.IsSleeping() \u0026\u0026 player.secondsSleeping \u003C NPCAutoTurret.sleeperhostiledelay)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfloat num = Stats.VisionRange * Stats.VisionRange;\n\t\t\treturn !((player.ServerPosition - ServerPosition).sqrMagnitude \u003E num);\n\t\t});\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureRepair(BaseCombatEntity baseCombatEntity, BasePlayer player)",
    "MethodSignature": "DoRepair(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void DoRepair(BasePlayer player)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tif (!repair.enabled || Interface.CallHook(\u0022OnStructureRepair\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 30f;\n\t\tif (SecondsSinceAttacked \u003C= num)\n\t\t{\n\t\t\tOnRepairFailed(player2, $\u0022Unable to repair: Recently damaged. Repairable in: {num - SecondsSinceAttacked:N0}s.\u0022);\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = MaxHealth() - Health();\n\t\tfloat num3 = num2 / MaxHealth();\n\t\tif (num2 \u003C= 0f || num3 \u003C= 0f)\n\t\t{\n\t\t\tOnRepairFailed(player2, \u0022Unable to repair: Not damaged.\u0022);\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItemAmount\u003E list = RepairCost(num3);\n\t\tif (list == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num4 = list.Sum((ItemAmount x) =\u003E x.amount);\n\t\tif (num4 \u003E 0f)\n\t\t{\n\t\t\tfloat a = list.Min((ItemAmount x) =\u003E Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));\n\t\t\ta = Mathf.Min(a, 50f / num2);\n\t\t\tif (a \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnRepairFailed(player2, \u0022Unable to repair: Insufficient resources.\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num5 = 0;\n\t\t\tforeach (ItemAmount item in list)\n\t\t\t{\n\t\t\t\tint amount = Mathf.CeilToInt(a * item.amount);\n\t\t\t\tint num6 = player2.inventory.Take(null, item.itemid, amount);\n\t\t\t\tif (num6 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tnum5 \u002B= num6;\n\t\t\t\t\tplayer2.Command(\u0022note.inv\u0022, item.itemid, num6 * -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat num7 = (float)num5 / num4;\n\t\t\thealth \u002B= num2 * num7;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\thealth \u002B= num2;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (Health() \u003E= MaxHealth())\n\t\t{\n\t\t\tOnRepairFinished();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnRepair();\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnHelicopterDropDoorOpen(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "SetDropDoorOpen(bool open)",
    "MethodSourseCode": "\n\tpublic void SetDropDoorOpen(bool open)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterDropDoorOpen\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved8, open);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnInputUpdate(IOEntity iOEntity, int inputAmount, int inputSlot)",
    "MethodSignature": "UpdateFromInput(int inputAmount, int inputSlot)",
    "MethodSourseCode": "\n\tpublic virtual void UpdateFromInput(int inputAmount, int inputSlot)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInputUpdate\u0022, this, inputAmount, inputSlot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (inputs[inputSlot].type != ioType)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\treturn;\n\t\t}\n\t\tUpdateHasPower(inputAmount, inputSlot);\n\t\tlastEnergy = currentEnergy;\n\t\tcurrentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);\n\t\tint passthroughAmount = GetPassthroughAmount();\n\t\tbool flag = lastPassthroughEnergy != passthroughAmount;\n\t\tlastPassthroughEnergy = passthroughAmount;\n\t\tif (currentEnergy != lastEnergy || flag)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\tensureOutputsUpdated = true;\n\t\t}\n\t\t_processQueue.Enqueue(this);\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopCompleteTrade(ShopFront shopFront)",
    "MethodSignature": "CompleteTrade()",
    "MethodSourseCode": "\n\tpublic void CompleteTrade()\n\t{\n\t\tif (vendorPlayer != null \u0026\u0026 customerPlayer != null \u0026\u0026 HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnShopCompleteTrade\u0022, this) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int num = vendorInventory.capacity - 1; num \u003E= 0; num--)\n\t\t\t{\n\t\t\t\tItem slot = vendorInventory.GetSlot(num);\n\t\t\t\tItem slot2 = customerInventory.GetSlot(num);\n\t\t\t\tif ((bool)customerPlayer \u0026\u0026 slot != null)\n\t\t\t\t{\n\t\t\t\t\tcustomerPlayer.GiveItem(slot);\n\t\t\t\t}\n\t\t\t\tif ((bool)vendorPlayer \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tvendorPlayer.GiveItem(slot2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tEffect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);\n\t\t}\n\t\tResetTrade();\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tTechTreeData.NodeInstance byID = techTree.GetByID(num);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTree.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTree.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint num2 = ResearchTable.ScrapForResearch(byID.itemDef);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num2)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num2);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnFireBallSpread(FireBall fireBall, BaseEntity baseEntity)",
    "MethodSignature": "TryToSpread()",
    "MethodSourseCode": "\n\tpublic void TryToSpread()\n\t{\n\t\tfloat num = 0.9f - generation * 0.1f;\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C num \u0026\u0026 spreadSubEntity.isValid)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.transform.position = base.transform.position \u002B Vector3.up * 0.25f;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallSpread\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\n\t\t\t\tbaseEntity.SendMessage(\u0022SetGeneration\u0022, generation \u002B 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnCounterModeToggle(PowerCounter powerCounter, BasePlayer msgPlayer, bool flag)",
    "MethodSignature": "ToggleDisplayMode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void ToggleDisplayMode(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnCounterModeToggle\u0022, this, msg.player, flag) == null \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tSetFlag(Flags.Reserved2, flag, recursive: false, networkupdate: false);\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerBehind(player))\n\t\t{\n\t\t\treturn OccupiedCheck(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTick()",
    "MethodSignature": "DoTick()",
    "MethodSourseCode": "\n\tprivate void DoTick()\n\t{\n\t\tInterface.CallHook(\u0022OnTick\u0022);\n\t\tRCon.Update();\n\t\tCompanionServer.Server.Update();\n\t\tCCTVRender.Manager.Update();\n\t\tfor (int i = 0; i \u003C Network.Net.sv.connections.Count; i\u002B\u002B)\n\t\t{\n\t\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\n\t\t\tif (!connection.isAuthenticated \u0026\u0026 !(connection.GetSecondsConnected() \u003C (float)ConVar.Server.authtimeout))\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022Authentication Timed Out\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSendModelState(BasePlayer basePlayer)",
    "MethodSignature": "SendModelState()",
    "MethodSourseCode": "\n\tprivate void SendModelState()\n\t{\n\t\tif (!wantsSendModelState || nextModelStateUpdate \u003E UnityEngine.Time.time)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\twantsSendModelState = false;\n\t\tnextModelStateUpdate = UnityEngine.Time.time \u002B 0.1f;\n\t\tif (!IsDead() \u0026\u0026 !IsSpectating())\n\t\t{\n\t\t\tmodelState.sleeping = IsSleeping();\n\t\t\tmodelState.mounted = isMounted;\n\t\t\tmodelState.relaxed = IsRelaxed();\n\t\t\tmodelState.onPhone = HasActiveTelephone;\n\t\t\tif (!base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSendModelState\u0022, this) == null)\n\t\t\t{\n\t\t\t\tClientRPC(null, \u0022OnModelState\u0022, modelState);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnSamSiteTarget(SamSite samSite, BaseCombatEntity item)",
    "MethodSignature": "TargetScan()",
    "MethodSourseCode": "\n\tpublic void TargetScan()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tlastTargetVisibleTime = 0f;\n\t\t\treturn;\n\t\t}\n\t\tif (Time.time \u003E lastTargetVisibleTime \u002B 3f)\n\t\t{\n\t\t\tcurrentTarget = null;\n\t\t}\n\t\tif (HasValidTarget() || IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CBaseCombatEntity\u003E obj = Pool.GetList\u003CBaseCombatEntity\u003E();\n\t\tVis.Entities(eyePoint.transform.position, scanRadius, obj, 32768, QueryTriggerInteraction.Ignore);\n\t\tBaseCombatEntity baseCombatEntity = null;\n\t\tforeach (BaseCombatEntity item in obj)\n\t\t{\n\t\t\tif (!item.isClient \u0026\u0026 !(EntityCenterPoint(item).y \u003C eyePoint.transform.position.y) \u0026\u0026 item.IsVisible(eyePoint.transform.position, scanRadius * 2f) \u0026\u0026 Interface.CallHook(\u0022OnSamSiteTarget\u0022, this, item) == null)\n\t\t\t{\n\t\t\t\tBaseVehicle component = item.GetComponent\u003CBaseVehicle\u003E();\n\t\t\t\tif ((staticRespawn || !(component != null) || !component.InSafeZone()) \u0026\u0026 (item.GetComponent\u003CISamSiteTarget\u003E()?.IsValidSAMTarget() ?? alltarget))\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity = item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (baseCombatEntity != null \u0026\u0026 currentTarget != baseCombatEntity)\n\t\t{\n\t\t\tlockOnTime = Time.time \u002B 0.5f;\n\t\t}\n\t\tcurrentTarget = baseCombatEntity;\n\t\tif (currentTarget != null)\n\t\t{\n\t\t\tlastTargetVisibleTime = Time.time;\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t\tif (currentTarget == null)\n\t\t{\n\t\t\tCancelInvoke(WeaponTick);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnCorpsePopulate(Scientist scientist, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(\u0022assets/prefabs/npc/scientist/scientist_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = LootPanelName;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int i = 0; i \u003C lootSpawnSlots.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];\n\t\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlot.numberToSpawn; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "Scientist",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnIORefCleared(IOEntity.IORef iOEntity.IORef, IOEntity obj)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\t\tpublic void Clear()\n\t\t{\n\t\t\tIOEntity obj = ioEnt;\n\t\t\tioEnt = null;\n\t\t\tentityRef.Set(null);\n\t\t\tInterface.CallHook(\u0022OnIORefCleared\u0022, this, obj);\n\t\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable ent, Network.Connection netConnection)",
    "MethodSignature": "SendEntitySnapshot(BaseNetworkable ent)",
    "MethodSourseCode": "\n\tpublic void SendEntitySnapshot(BaseNetworkable ent)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, ent, net.connection) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendEntitySnapshot\u0022))\n\t\t{\n\t\t\tif (!(ent == null) \u0026\u0026 ent.net != null \u0026\u0026 ent.ShouldNetworkTo(this) \u0026\u0026 Network.Net.sv.write.Start())\n\t\t\t{\n\t\t\t\tnet.connection.validate.entityUpdates\u002B\u002B;\n\t\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\t\tsaveInfo.forConnection = net.connection;\n\t\t\t\tsaveInfo.forDisk = false;\n\t\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\t\tNetwork.Net.sv.write.PacketID(Message.Type.Entities);\n\t\t\t\tNetwork.Net.sv.write.UInt32(net.connection.validate.entityUpdates);\n\t\t\t\tent.ToStreamForNetwork(Network.Net.sv.write, saveInfo2);\n\t\t\t\tNetwork.Net.sv.write.Send(new SendInfo(net.connection));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPayForPlacement(BasePlayer player, Planner planner, Construction component)",
    "MethodSignature": "PayForPlacement(BasePlayer player, Construction component)",
    "MethodSourseCode": "\n\tpublic void PayForPlacement(BasePlayer player, Construction component)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForPlacement\u0022, player, this, component) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\tGetItem().UseItem();\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount item in component.defaultGrade.costToBuild)\n\t\t{\n\t\t\tplayer.inventory.Take(list, item.itemDef.itemid, (int)item.amount);\n\t\t\tplayer.Command(\u0022note.inv\u0022, item.itemDef.itemid, item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in list)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBuild(Planner planner, Construction construction, Construction.Target target)",
    "MethodSignature": "DoBuild(CreateBuilding msg)",
    "MethodSourseCode": "\n\tpublic void DoBuild(CreateBuilding msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredAntiHack())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022AntiHack!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tConstruction construction = PrefabAttribute.server.Find\u003CConstruction\u003E(msg.blockID);\n\t\tif (construction == null)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find Construction \u0022 \u002B msg.blockID);\n\t\t\treturn;\n\t\t}\n\t\tif (!CanAffordToPlace(construction))\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t afford to place!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild() \u0026\u0026 !construction.canBypassBuildingPermission)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable();\n\t\tif (construction.deployable != deployable)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Deployable mismatch!\u0022);\n\t\t\tAntiHack.NoteAdminHack(ownerPlayer);\n\t\t\treturn;\n\t\t}\n\t\tConstruction.Target target = default(Construction.Target);\n\t\tBaseEntity baseEntity = null;\n\t\tif (msg.entity != 0)\n\t\t{\n\t\t\tbaseEntity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find entity \u0022 \u002B msg.entity);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsg.position = baseEntity.transform.TransformPoint(msg.position);\n\t\t\tmsg.normal = baseEntity.transform.TransformDirection(msg.normal);\n\t\t\tmsg.rotation = baseEntity.transform.rotation * msg.rotation;\n\t\t\tif (msg.socket == 0)\n\t\t\t{\n\t\t\t\tif ((bool)deployable \u0026\u0026 deployable.setSocketParent \u0026\u0026 baseEntity.Distance(msg.position) \u003E 1f)\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ChatMessage(\u0022Parent too far away: \u0022 \u002B baseEntity.Distance(msg.position));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (baseEntity is Door)\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t deploy on door\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget.entity = baseEntity;\n\t\t\tif (msg.socket != 0)\n\t\t\t{\n\t\t\t\tstring text = StringPool.Get(msg.socket);\n\t\t\t\tif (text != \u0022\u0022 \u0026\u0026 target.entity != null)\n\t\t\t\t{\n\t\t\t\t\ttarget.socket = FindSocket(text, target.entity.prefabID);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ChatMessage(\u0022Invalid Socket!\u0022);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget.ray = msg.ray;\n\t\ttarget.onTerrain = msg.onterrain;\n\t\ttarget.position = msg.position;\n\t\ttarget.normal = msg.normal;\n\t\ttarget.rotation = msg.rotation;\n\t\ttarget.player = ownerPlayer;\n\t\ttarget.valid = true;\n\t\tif (Interface.CallHook(\u0022CanBuild\u0022, this, construction, target) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ((bool)deployable \u0026\u0026 deployable.placeEffect.isValid)\n\t\t{\n\t\t\tif ((bool)baseEntity \u0026\u0026 msg.socket != 0)\n\t\t\t{\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.TransformPoint(target.socket.worldPosition), baseEntity.transform.up);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);\n\t\t\t}\n\t\t}\n\t\tDoBuild(target, construction);\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 83
  },
  {
    "HookSignature": "OnPhoneCallStarted(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnNpcTarget(NPCPlayerApex nPCPlayerApex, BaseEntity target)",
    "MethodSignature": "UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, Memory.ExtendedInfo extendedInfo)",
    "MethodSourseCode": "\n\tpublic Memory.SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, out Memory.ExtendedInfo extendedInfo)\n\t{\n\t\tif (target == null || Interface.CallHook(\u0022OnNpcTarget\u0022, this, target) != null)\n\t\t{\n\t\t\textendedInfo = default(Memory.ExtendedInfo);\n\t\t\treturn default(Memory.SeenInfo);\n\t\t}\n\t\tVector3 dir;\n\t\tfloat dot;\n\t\tif (base.isMounted)\n\t\t{\n\t\t\tBestMountedPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBestPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);\n\t\t}\n\t\tBestPlayerDistance.Evaluate(this, lastKnownPosition, out var distanceSqr, out var _);\n\t\tBasePlayer basePlayer = target.ToPlayer();\n\t\tint standing;\n\t\tint crouched;\n\t\tbyte b = (byte)((!basePlayer) ? 1 : ((!base.isMounted) ? BestLineOfSight.Evaluate(this, basePlayer, out standing, out crouched) : BestMountedLineOfSight.Evaluate(this, basePlayer)));\n\t\tSetFact(Facts.HasLineOfSight, b);\n\t\treturn AiContext.Memory.Update(target, lastKnownPosition, dmg, dir, dot, distanceSqr, b, lastAttacker == target, lastAttackedTime, out extendedInfo);\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneDialTimedOut(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnPlayerStudyBlueprint(BasePlayer player, Item item)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (item.GetOwnerPlayer() != player)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tforeach (ItemContainer container in player.inventory.loot.containers)\n\t\t\t{\n\t\t\t\tif (item.GetRootContainer() == container)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!(command == \u0022study\u0022) || !item.IsBlueprint())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition blueprintTargetDef = item.blueprintTargetDef;\n\t\tItemBlueprint blueprint = blueprintTargetDef.Blueprint;\n\t\tbool flag2 = player.blueprints.IsUnlocked(blueprintTargetDef);\n\t\tif (flag2 \u0026\u0026 blueprint != null \u0026\u0026 blueprint.additionalUnlocks != null \u0026\u0026 blueprint.additionalUnlocks.Count \u003E 0)\n\t\t{\n\t\t\tforeach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)\n\t\t\t{\n\t\t\t\tif (!player.blueprints.IsUnlocked(additionalUnlock))\n\t\t\t\t{\n\t\t\t\t\tflag2 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag2 || Interface.CallHook(\u0022OnPlayerStudyBlueprint\u0022, player, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = item;\n\t\tif (item.amount \u003E 1)\n\t\t{\n\t\t\titem2 = item.SplitItem(1);\n\t\t}\n\t\titem2.UseItem();\n\t\tplayer.blueprints.Unlock(blueprintTargetDef);\n\t\tif (blueprint != null \u0026\u0026 blueprint.additionalUnlocks != null \u0026\u0026 blueprint.additionalUnlocks.Count \u003E 0)\n\t\t{\n\t\t\tforeach (ItemDefinition additionalUnlock2 in blueprint.additionalUnlocks)\n\t\t\t{\n\t\t\t\tplayer.blueprints.Unlock(additionalUnlock2);\n\t\t\t}\n\t\t}\n\t\tif (studyEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(studyEffect.resourcePath, player, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "ItemModStudyBlueprint",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnBradleyApcPatrol(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Patrol()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Patrol()\n\t{\n\t\tif (patrolPath == null || UnityEngine.Time.time \u003C nextPatrolTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextPatrolTime = UnityEngine.Time.time \u002B 20f;\n\t\tif ((HasPath() \u0026\u0026 !IsAtFinalDestination()) || Interface.CallHook(\u0022OnBradleyApcPatrol\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);\n\t\tBasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);\n\t\tBasePathNode basePathNode = null;\n\t\tbool flag = false;\n\t\tList\u003CBasePathNode\u003E nodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\n\t\tif (GetEngagementPath(ref nodes))\n\t\t{\n\t\t\tflag = true;\n\t\t\tbasePathNode = nodes[nodes.Count - 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbasePathNode = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t}\n\t\tif (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) \u003E 2f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (closestToPoint == basePathNode)\n\t\t{\n\t\t\tcurrentPath.Clear();\n\t\t\tcurrentPath.Add(closestToPoint.transform.position);\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.transform.position;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentPath.Clear();\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(nodes[i].transform.position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (BasePathNode item in path)\n\t\t\t{\n\t\t\t\tcurrentPath.Add(item.transform.position);\n\t\t\t}\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.transform.position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnDoorClosed(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_CloseDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_CloseDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !canHandOpen || !IsOpen() || IsBusy() || IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t\t{\n\t\t\t\tSetNavMeshLinkEnabled(wantsOn: false);\n\t\t\t}\n\t\t\tStartCheckingForBlockages();\n\t\t\tInterface.CallHook(\u0022OnDoorClosed\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnTeamUpdated(ulong currentTeam, ProtoBuf.PlayerTeam playerTeam2, BasePlayer basePlayer)",
    "MethodSignature": "TeamUpdate()",
    "MethodSourseCode": "\n\tpublic void TeamUpdate()\n\t{\n\t\tif (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindTeam(currentTeam);\n\t\tif (playerTeam == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = 0;\n\t\tint num2 = 0;\n\t\tusing PlayerTeam playerTeam2 = Facepunch.Pool.Get\u003CPlayerTeam\u003E();\n\t\tplayerTeam2.teamLeader = playerTeam.teamLeader;\n\t\tplayerTeam2.teamID = playerTeam.teamID;\n\t\tplayerTeam2.teamName = playerTeam.teamName;\n\t\tplayerTeam2.members = Facepunch.Pool.GetList\u003CPlayerTeam.TeamMember\u003E();\n\t\tplayerTeam2.teamLifetime = playerTeam.teamLifetime;\n\t\tforeach (ulong member in playerTeam.members)\n\t\t{\n\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(member);\n\t\t\tPlayerTeam.TeamMember teamMember = Facepunch.Pool.Get\u003CPlayerTeam.TeamMember\u003E();\n\t\t\tteamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetPlayerName(member) ?? \u0022DEAD\u0022));\n\t\t\tteamMember.healthFraction = ((basePlayer != null) ? basePlayer.healthFraction : 0f);\n\t\t\tteamMember.position = ((basePlayer != null) ? basePlayer.transform.position : UnityEngine.Vector3.zero);\n\t\t\tteamMember.online = basePlayer != null \u0026\u0026 !basePlayer.IsSleeping();\n\t\t\tif ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) \u0026\u0026 basePlayer != null)\n\t\t\t{\n\t\t\t\tif ((bool)basePlayer.GetHeldEntity() \u0026\u0026 basePlayer.GetHeldEntity().IsInstrument())\n\t\t\t\t{\n\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t}\n\t\t\t\tif (basePlayer.isMounted)\n\t\t\t\t{\n\t\t\t\t\tif (basePlayer.GetMounted().IsInstrument())\n\t\t\t\t\t{\n\t\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t\tif (basePlayer.GetMounted().IsSummerDlcVehicle)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num \u003E= 4 \u0026\u0026 !sentInstrumentTeamAchievement)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022TEAM_INSTRUMENTS\u0022);\n\t\t\t\t\tsentInstrumentTeamAchievement = true;\n\t\t\t\t}\n\t\t\t\tif (num2 \u003E= 4)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022SUMMER_INFLATABLE\u0022);\n\t\t\t\t\tsentSummerTeamAchievement = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tteamMember.userID = member;\n\t\t\tplayerTeam2.members.Add(teamMember);\n\t\t}\n\t\tteamLeaderBuffer = FindByID(playerTeam.teamLeader);\n\t\tif (teamLeaderBuffer != null)\n\t\t{\n\t\t\tplayerTeam2.mapNote = teamLeaderBuffer.ServerCurrentMapNote;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnTeamUpdated\u0022, currentTeam, playerTeam2, this) == null)\n\t\t{\n\t\t\tClientRPCPlayer(null, this, \u0022CLIENT_ReceiveTeamInfo\u0022, playerTeam2);\n\t\t\tplayerTeam2.mapNote = null;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 64
  },
  {
    "HookSignature": "InitLogging()",
    "MethodSignature": "StartupShared()",
    "MethodSourseCode": "\n\tprivate void StartupShared()\n\t{\n\t\tInterface.CallHook(\u0022InitLogging\u0022);\n\t\tItemManager.Initialize();\n\t}\n",
    "ClassName": "Bootstrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022IOnBasePlayerAttacked\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat health_old = base.health;\n\t\tif (InSafeZone() \u0026\u0026 !IsHostile() \u0026\u0026 info.Initiator != null \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\tinfo.damageTypes.ScaleAll(0f);\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tHitArea boneArea = info.boneArea;\n\t\t\tif (boneArea != (HitArea)(-1))\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\t\t\tobj.AddRange(inventory.containerWear.itemList);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = obj[i];\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\n\t\t\t\t\t\tif (!(component == null) \u0026\u0026 component.ProtectsArea(boneArea))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.OnAttacked(info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t\tinventory.ServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t\tbase.OnAttacked(info);\n\t\tif (base.isServer \u0026\u0026 base.isServer \u0026\u0026 info.hasDamage)\n\t\t{\n\t\t\tif (!info.damageTypes.Has(DamageType.Bleeding) \u0026\u0026 info.damageTypes.IsBleedCausing() \u0026\u0026 !IsWounded() \u0026\u0026 !IsImmortal())\n\t\t\t{\n\t\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);\n\t\t\t}\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().MounteeTookDamage(this, info);\n\t\t\t}\n\t\t\tCheckDeathCondition(info);\n\t\t\tif (net != null \u0026\u0026 net.connection != null)\n\t\t\t{\n\t\t\t\tEffect effect = new Effect();\n\t\t\t\teffect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);\n\t\t\t\teffect.pooledString = \u0022assets/bundled/prefabs/fx/takedamage_hit.prefab\u0022;\n\t\t\t\tEffectNetwork.Send(effect, net.connection);\n\t\t\t}\n\t\t\tstring text = StringPool.Get(info.HitBone);\n\t\t\tbool flag = UnityEngine.Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) \u003E 0.4f;\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer \u0026\u0026 !info.damageTypes.IsMeleeType())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.LifeStoryShotHit(info.Weapon);\n\t\t\t}\n\t\t\tif (info.isHeadshot)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_RearHead, string.Empty);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_Head, string.Empty);\n\t\t\t\t}\n\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/headshot.prefab\u0022, this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);\n\t\t\t\tif ((bool)initiatorPlayer)\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.Add(\u0022headshot\u0022, 1, (Stats)5);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flag)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_RearTorso, string.Empty);\n\t\t\t}\n\t\t\telse if (text == \u0022spine\u0022 || text == \u0022spine2\u0022)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Stomach, string.Empty);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Chest, string.Empty);\n\t\t\t}\n\t\t}\n\t\tif (stats != null)\n\t\t{\n\t\t\tif (IsWounded())\n\t\t\t{\n\t\t\t\tstats.combat.Log(info, health_old, base.health, \u0022wounded\u0022);\n\t\t\t}\n\t\t\telse if (IsDead())\n\t\t\t{\n\t\t\t\tstats.combat.Log(info, health_old, base.health, \u0022killed\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.Log(info, health_old, base.health);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleModulesAssign(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\titemModVehicleModule.doNonUserSpawn = true;\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnGrowableGather(GrowableEntity growableEntity, BasePlayer player)",
    "MethodSignature": "PickFruit(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PickFruit(BasePlayer player)\n\t{\n\t\tif (!CanPick() || Interface.CallHook(\u0022OnGrowableGather\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tharvests\u002B\u002B;\n\t\tGiveFruit(player, CurrentPickAmount);\n\t\tResetSeason();\n\t\tif (Properties.pickEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t}\n\t\tif (harvests \u003E= Properties.maxHarvests)\n\t\t{\n\t\t\tif (Properties.disappearAfterHarvest)\n\t\t\t{\n\t\t\t\tDie();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tChangeState(PlantProperties.State.Dying, resetAge: true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tChangeState(PlantProperties.State.Mature, resetAge: true);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSensorDetect(HBHFSensor hBHFSensor, BasePlayer component)",
    "MethodSignature": "UpdatePassthroughAmount()",
    "MethodSourseCode": "\n\tpublic void UpdatePassthroughAmount()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = detectedPlayers;\n\t\tdetectedPlayers = 0;\n\t\tif (myTrigger.entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity entityContent in myTrigger.entityContents)\n\t\t\t{\n\t\t\t\tif (entityContent == null || !entityContent.IsVisible(base.transform.position \u002B base.transform.forward * 0.1f, 10f))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBasePlayer component = entityContent.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (Interface.CallHook(\u0022OnSensorDetect\u0022, this, component) == null)\n\t\t\t\t{\n\t\t\t\t\tbool flag = component.CanBuild();\n\t\t\t\t\tif ((!flag || ShouldIncludeAuthorized()) \u0026\u0026 (flag || ShouldIncludeOthers()) \u0026\u0026 component != null \u0026\u0026 component.IsAlive() \u0026\u0026 !component.IsSleeping() \u0026\u0026 component.isServer)\n\t\t\t\t\t{\n\t\t\t\t\t\tdetectedPlayers\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num != detectedPlayers \u0026\u0026 IsPowered())\n\t\t{\n\t\t\tMarkDirty();\n\t\t\tif (detectedPlayers \u003E num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\telse if (detectedPlayers \u003C num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HBHFSensor",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer, bool false)",
    "MethodSignature": "DoDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void DoDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanDemolish(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, false) == null)\n\t\t{\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntityControl(PoweredRemoteControlEntity poweredRemoteControlEntity)",
    "MethodSignature": "CanControl()",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\treturn IsStatic();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PoweredRemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPayForUpgrade(BasePlayer player, BuildingBlock buildingBlock, ConstructionGrade g)",
    "MethodSignature": "PayForUpgrade(ConstructionGrade g, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PayForUpgrade(ConstructionGrade g, BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForUpgrade\u0022, player, this, g) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount item in g.costToBuild)\n\t\t{\n\t\t\tplayer.inventory.Take(list, item.itemid, (int)item.amount);\n\t\t\tplayer.Command(\u0022note.inv \u0022 \u002B item.itemid \u002B \u0022 \u0022 \u002B item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in list)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcResume(NPCPlayerApex nPCPlayerApex)",
    "MethodSignature": "Resume()",
    "MethodSourseCode": "\n\tpublic override void Resume()\n\t{\n\t\tif (base.isMounted)\n\t\t{\n\t\t\tif (utilityAiComponent == null)\n\t\t\t{\n\t\t\t\tutilityAiComponent = Entity.GetComponent\u003CUtilityAIComponent\u003E();\n\t\t\t}\n\t\t\tif (utilityAiComponent != null)\n\t\t\t{\n\t\t\t\tutilityAiComponent.enabled = true;\n\t\t\t\tutilityAiComponent.Resume();\n\t\t\t}\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\treturn;\n\t\t}\n\t\tif (!GetNavAgent.isOnNavMesh)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnNpcResume\u0022, this) == null)\n\t\t\t{\n\t\t\t\tStartCoroutine(TryForceToNavmesh());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tGetNavAgent.enabled = true;\n\t\tStoppingDistance = 1f;\n\t\tif (utilityAiComponent == null)\n\t\t{\n\t\t\tutilityAiComponent = Entity.GetComponent\u003CUtilityAIComponent\u003E();\n\t\t}\n\t\tif (utilityAiComponent != null)\n\t\t{\n\t\t\tutilityAiComponent.enabled = true;\n\t\t\tutilityAiComponent.Resume();\n\t\t}\n\t\tInvokeRandomized(RadioChatter, RadioEffectRepeatRange.x, RadioEffectRepeatRange.x, RadioEffectRepeatRange.y - RadioEffectRepeatRange.x);\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnDemoRecordingStopped(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "IOnNpcSenseClose(NPCPlayerApex nPCPlayerApex)",
    "MethodSignature": "_FindEntitiesInCloseRange()",
    "MethodSourseCode": "\n\tprivate void _FindEntitiesInCloseRange()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnNpcSenseClose\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tEntityQueryResultCount = Query.Server.GetInSphere(base.transform.position, Stats.CloseRange, EntityQueryResults, delegate(BaseEntity entity)\n\t\t{\n\t\t\tif (entity == null || !entity.isServer || entity.IsDestroyed)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (entity is BaseNpc || entity is TimedExplosive) ? true : false;\n\t\t});\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRecyclerToggle(Recycler recycler, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag == IsOn() || msg.player == null || Interface.CallHook(\u0022OnRecyclerToggle\u0022, this, msg.player) != null || (flag \u0026\u0026 !HasRecyclable()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (Item item in base.inventory.itemList)\n\t\t\t{\n\t\t\t\titem.CollectedForCrafting(msg.player);\n\t\t\t}\n\t\t\tStartRecycling();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStopRecycling();\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityKill(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Kill(DestroyMode mode)",
    "MethodSourseCode": "\n\tpublic void Kill(DestroyMode mode = DestroyMode.None)\n\t{\n\t\tif (IsDestroyed)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Calling kill - but already IsDestroyed!? \u0022 \u002B this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnEntityKill\u0022, this) == null)\n\t\t{\n\t\t\tOnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);\n\t\t\tDoEntityDestroy();\n\t\t\tTerminateOnClient(mode);\n\t\t\tTerminateOnServer();\n\t\t\tEntityDestroy();\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnRfFrequencyChanged(Detonator detonator, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild() || GetOwnerPlayer() != msg.player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsOn());\n\t\t\tfrequency = num;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnBookmarksSendControl(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "SendControlBookmarks(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void SendControlBookmarks(BasePlayer player)\n\t{\n\t\tif (!(player == null))\n\t\t{\n\t\t\tstring text = GenerateControlBookmarkString();\n\t\t\tif (Interface.CallHook(\u0022OnBookmarksSendControl\u0022, this, player, text) == null)\n\t\t\t{\n\t\t\t\tClientRPCPlayer(null, player, \u0022ReceiveBookmarks\u0022, text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnDoorOpened(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_OpenDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_OpenDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !canHandOpen || IsOpen() || IsBusy() || IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (baseLock != null)\n\t\t{\n\t\t\tif (!baseLock.OnTryToOpen(rpc.player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (baseLock.IsLocked() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast \u003E 60f)\n\t\t\t{\n\t\t\t\tBuildingBlock buildingBlock = FindLinkedEntity\u003CBuildingBlock\u003E();\n\t\t\t\tif ((bool)buildingBlock)\n\t\t\t\t{\n\t\t\t\t\tDecay.BuildingDecayTouch(buildingBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDecay.RadialDecayTouch(base.transform.position, 40f, 2097408);\n\t\t\t\t}\n\t\t\t\tdecayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.Open, b: true);\n\t\tSendNetworkUpdateImmediate();\n\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t{\n\t\t\tSetNavMeshLinkEnabled(wantsOn: true);\n\t\t}\n\t\tif (checkPhysBoxesOnOpen)\n\t\t{\n\t\t\tStartCheckingForBlockages();\n\t\t}\n\t\tInterface.CallHook(\u0022OnDoorOpened\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "PlayerInit(Network.Connection c)",
    "MethodSourseCode": "\n\tpublic void PlayerInit(Network.Connection c)\n\t{\n\t\tusing (TimeWarning.New(\u0022PlayerInit\u0022, 10))\n\t\t{\n\t\t\tCancelInvoke(base.KillMessage);\n\t\t\tSetPlayerFlag(PlayerFlags.Connected, b: true);\n\t\t\tactivePlayerList.Add(this);\n\t\t\tbots.Remove(this);\n\t\t\tuserID = c.userid;\n\t\t\tUserIDString = userID.ToString();\n\t\t\tdisplayName = c.username;\n\t\t\tc.player = this;\n\t\t\tcurrentTeam = RelationshipManager.Instance.FindPlayersTeam(userID)?.teamID ?? 0;\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.persistance.SetPlayerName(userID, displayName);\n\t\t\ttickInterpolator.Reset(base.transform.position);\n\t\t\ttickHistory.Reset(base.transform.position);\n\t\t\tlastTickTime = 0f;\n\t\t\tlastInputTime = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tstats.Init();\n\t\t\tInvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));\n\t\t\tpreviousLifeStory = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetLastLifeStory(userID);\n\t\t\tSetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);\n\t\t\tSetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\n\t\t\tif (IsDead() \u0026\u0026 net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\n\t\t\t{\n\t\t\t\tSendNetworkGroupChange();\n\t\t\t}\n\t\t\tnet.OnConnected(c);\n\t\t\tnet.StartSubscriber();\n\t\t\tSendAsSnapshot(net.connection);\n\t\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);\n\t\t\t}\n\t\t\tif (net != null)\n\t\t\t{\n\t\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnPlayerConnected\u0022, this);\n\t\t\tif (IsAdmin)\n\t\t\t{\n\t\t\t\tif (ConVar.AntiHack.noclip_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.noclip_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.speedhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.speedhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.flyhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.flyhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.projectile_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.projectile_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.melee_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.eye_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 41
  },
  {
    "HookSignature": "OnNpcConversationRespond(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode != null \u0026\u0026 Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) == null)\n\t\t{\n\t\t\tif (responseNode.conditions.Length != 0)\n\t\t\t{\n\t\t\t\tUpdateFlags();\n\t\t\t}\n\t\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\t\tif (flag \u0026\u0026 !string.IsNullOrEmpty(responseNode.actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, responseNode.actionString);\n\t\t\t}\n\t\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\t\tif (speechNodeIndex == -1)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tForceSpeechNode(player, speechNodeIndex);\n\t\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, GunTrap gunTrap)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tbool flag = false;\n\t\tif (entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity item in entityContents)\n\t\t\t{\n\t\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (component.IsSleeping() || !component.IsAlive() || component.IsBuildingAuthed())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\t\tif (obj2 is bool)\n\t\t\t\t{\n\t\t\t\t\tPool.FreeList(ref obj);\n\t\t\t\t\treturn (bool)obj2;\n\t\t\t\t}\n\t\t\t\tobj.Clear();\n\t\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "GunTrap",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnContainerDropItems(ItemContainer container)",
    "MethodSignature": "DropItems(ItemContainer container, Vector3 position, float chance)",
    "MethodSourseCode": "\tpublic static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)\n\t{\n\t\tif (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook(\u0022OnContainerDropItems\u0022, container) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 0.25f;\n\t\tItem[] array = container.itemList.ToArray();\n\t\tforeach (Item item in array)\n\t\t{\n\t\t\tif (!(UnityEngine.Random.Range(0f, 1f) \u003E chance))\n\t\t\t{\n\t\t\t\tfloat num2 = UnityEngine.Random.Range(0f, 2f);\n\t\t\t\titem.RemoveFromContainer();\n\t\t\t\tBaseEntity baseEntity = item.CreateWorldObject(position \u002B new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));\n\t\t\t\tif (baseEntity == null)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t\telse if (num2 \u003E 0f)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);\n\t\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DropUtil",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignLocked(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnDemoRecordingStarted(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnEntityDestroy(BradleyAPC bradleyAPC)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnKilled(HitInfo info)\n\t{\n\t\tif (base.isClient || Interface.CallHook(\u0022OnEntityDestroy\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCreateExplosionMarker(10f);\n\t\tEffect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);\n\t\tVector3 zero = Vector3.zero;\n\t\tGameObject gibSource = servergibs.Get().GetComponent\u003CServerGib\u003E()._gibSource;\n\t\tList\u003CServerGib\u003E list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);\n\t\tfor (int i = 0; i \u003C 12 - maxCratesToSpawn; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat min = 3f;\n\t\t\tfloat max = 10f;\n\t\t\tVector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\n\t\t\tbaseEntity.transform.position = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\n\t\t\tCollider component = baseEntity.GetComponent\u003CCollider\u003E();\n\t\t\tbaseEntity.Spawn();\n\t\t\tbaseEntity.SetVelocity(zero \u002B onUnitSphere * UnityEngine.Random.Range(min, max));\n\t\t\tforeach (ServerGib item in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C maxCratesToSpawn; j\u002B\u002B)\n\t\t{\n\t\t\tVector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\n\t\t\tonUnitSphere2.y = 0f;\n\t\t\tonUnitSphere2.Normalize();\n\t\t\tVector3 pos = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));\n\t\t\tbaseEntity2.Spawn();\n\t\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\n\t\t\tif ((bool)lootContainer)\n\t\t\t{\n\t\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\n\t\t\t}\n\t\t\tCollider component2 = baseEntity2.GetComponent\u003CCollider\u003E();\n\t\t\tRigidbody rigidbody = baseEntity2.gameObject.AddComponent\u003CRigidbody\u003E();\n\t\t\trigidbody.useGravity = true;\n\t\t\trigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;\n\t\t\trigidbody.mass = 2f;\n\t\t\trigidbody.interpolation = RigidbodyInterpolation.Interpolate;\n\t\t\trigidbody.velocity = zero \u002B onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\n\t\t\trigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);\n\t\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\n\t\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\n\t\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\n\t\t\tif ((bool)fireBall)\n\t\t\t{\n\t\t\t\tfireBall.SetParent(baseEntity2);\n\t\t\t\tfireBall.Spawn();\n\t\t\t\tfireBall.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t\tfireBall.GetComponent\u003CCollider\u003E().enabled = false;\n\t\t\t}\n\t\t\tbaseEntity2.SendMessage(\u0022SetLockingEnt\u0022, fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tbase.OnKilled(info);\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHelicopterTarget(HelicopterTurret helicopterTurret, BaseCombatEntity newTarget)",
    "MethodSignature": "SetTarget(BaseCombatEntity newTarget)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity newTarget)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterTarget\u0022, this, newTarget) == null)\n\t\t{\n\t\t\t_target = newTarget;\n\t\t\tUpdateTargetVisibility();\n\t\t}\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "DropCrate()",
    "MethodSourseCode": "\n\tpublic void DropCrate()\n\t{\n\t\tif (numCrates \u003E 0)\n\t\t{\n\t\t\tVector3 pos = base.transform.position \u002B Vector3.down * 5f;\n\t\t\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnHelicopterDropCrate\u0022, this);\n\t\t\t\tbaseEntity.SendMessage(\u0022SetWasDropped\u0022);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tnumCrates--;\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnNpcRadioChatter(ScientistNPC scientistNPC)",
    "MethodSignature": "PlayRadioChatter()",
    "MethodSourseCode": "\n\tpublic void PlayRadioChatter()\n\t{\n\t\tif (RadioChatterEffects.Length != 0)\n\t\t{\n\t\t\tif (base.IsDestroyed || base.transform == null)\n\t\t\t{\n\t\t\t\tCancelInvoke(PlayRadioChatter);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnNpcRadioChatter\u0022, this) == null)\n\t\t\t{\n\t\t\t\tEffect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t\t\tQueueRadioChatter();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade)",
    "MethodSignature": "CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAffordUpgrade\u0022, player, this, iGrade);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount item in GetGrade(iGrade).costToBuild)\n\t\t{\n\t\t\tif ((float)player.inventory.GetAmount(item.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tif (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)\n\t\t{\n\t\t\tKill();\n\t\t\treturn;\n\t\t}\n\t\tResetRemovalTime();\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanMountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTriggerParent triggerParent = player.FindTrigger\u003CTriggerParent\u003E();\n\t\t\tif ((bool)triggerParent)\n\t\t\t{\n\t\t\t\ttriggerParent.OnTriggerExit(player.GetComponent\u003CCollider\u003E());\n\t\t\t}\n\t\t\tplayer.MountObject(this);\n\t\t\tplayer.MovePosition(mountAnchor.transform.position);\n\t\t\tplayer.transform.rotation = mountAnchor.transform.rotation;\n\t\t\tplayer.ServerRotation = mountAnchor.transform.rotation;\n\t\t\tplayer.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, player.transform.position);\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardDeauthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 CanAdministrate(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTurretModeToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetPeacekeepermode(bool isOn)",
    "MethodSourseCode": "\n\tpublic void SetPeacekeepermode(bool isOn)\n\t{\n\t\tif (PeacekeeperMode() != isOn)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, isOn);\n\t\t\tEffect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInterface.CallHook(\u0022OnTurretModeToggle\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnTeamDisband(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tPool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ResourceContainer resourceContainer)",
    "MethodSignature": "StartLootingContainer(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server]\n\t[BaseEntity.RPC_Server.IsVisible(3f)]\n\tprivate void StartLootingContainer(BaseEntity.RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 lootable \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(base.baseEntity))\n\t\t{\n\t\t\tlastAccessTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tplayer.inventory.loot.AddContainer(container);\n\t\t}\n\t}\n",
    "ClassName": "ResourceContainer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnHammerHit(BasePlayer ownerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void DoAttackShared(HitInfo info)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\n\t\tif (baseCombatEntity != null \u0026\u0026 ownerPlayer != null \u0026\u0026 base.isServer)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHammerHit\u0022, ownerPlayer, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022DoRepair\u0022, 50))\n\t\t\t{\n\t\t\t\tbaseCombatEntity.DoRepair(ownerPlayer);\n\t\t\t}\n\t\t}\n\t\tinfo.DoDecals = false;\n\t\tif (base.isServer)\n\t\t{\n\t\t\tEffect.server.ImpactEffect(info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEffect.client.ImpactEffect(info);\n\t\t}\n\t}\n",
    "ClassName": "Hammer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnSignLocked(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHelicopterOutOfCrates(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OutOfCrates()",
    "MethodSourseCode": "\n\tpublic bool OutOfCrates()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnHelicopterOutOfCrates\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003C= 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnNpcTarget(BaseNpc baseNpc, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\n\tpublic float GetWantsToAttack(BaseEntity target)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022IOnNpcTarget\u0022, this, target);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\treturn WantsToAttack(target);\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcEquipWeapon(NPCPlayer nPCPlayer, Item slot)",
    "MethodSignature": "EquipWeapon()",
    "MethodSourseCode": "\n\tpublic virtual void EquipWeapon()\n\t{\n\t\tItem slot = inventory.containerBelt.GetSlot(0);\n\t\tif (slot == null || Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, slot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (heldEntity != null)\n\t\t{\n\t\t\tAttackEntity component = heldEntity.GetComponent\u003CAttackEntity\u003E();\n\t\t\tif (component != null)\n\t\t\t{\n\t\t\t\tcomponent.TopUpAmmo();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnExperimentStarted(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer playerInfo = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetPlayerInfo(player.userID);\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !playerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 54
  },
  {
    "HookSignature": "OnDieselEngineToggle(BasePlayer msgPlayer, DieselEngine dieselEngine)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(6f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnDieselEngineToggle\u0022, msg.player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (msg.read.Bit())\n\t\t{\n\t\t\tif (GetFuelAmount() \u003E 0)\n\t\t\t{\n\t\t\t\tEngineOn();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEngineOff();\n\t\t}\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcDuck(HumanNPC humanNPC)",
    "MethodSignature": "SetDucked(bool wantsDucked)",
    "MethodSourseCode": "\n\tpublic void SetDucked(bool wantsDucked)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcDuck\u0022, this) == null)\n\t\t{\n\t\t\tpendingDucked = wantsDucked;\n\t\t\tApplyPendingDucked();\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChange(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnBigWheelWin(BigWheelGame bigWheelGame, Item slot, BigWheelBettingTerminal terminal, int num)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(null, \u0022WinOrLoseSound\u0022, flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnBookmarkInput(ComputerStation computerStation, BasePlayer player, InputState inputState)",
    "MethodSignature": "PlayerServerInput(InputState inputState, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void PlayerServerInput(InputState inputState, BasePlayer player)\n\t{\n\t\tbase.PlayerServerInput(inputState, player);\n\t\tif (currentlyControllingEnt.IsValid(serverside: true) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkInput\u0022, this, player, inputState) == null)\n\t\t{\n\t\t\tcurrentlyControllingEnt.Get(serverside: true).GetComponent\u003CIRemoteControllable\u003E().UserInput(inputState, player);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "IOnRconInitialize()",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic static void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRconInitialize\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (Port == 0)\n\t\t{\n\t\t\tPort = Server.port;\n\t\t}\n\t\tPassword = CommandLine.GetSwitch(\u0022-rcon.password\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.password\u0022, \u0022\u0022));\n\t\tif (Password == \u0022password\u0022 || Password == \u0022\u0022)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tOutput.OnMessage \u002B= OnMessage;\n\t\tif (Web)\n\t\t{\n\t\t\tlistenerNew = new Listener();\n\t\t\tif (!string.IsNullOrEmpty(Ip))\n\t\t\t{\n\t\t\t\tlistenerNew.Address = Ip;\n\t\t\t}\n\t\t\tlistenerNew.Password = Password;\n\t\t\tlistenerNew.Port = Port;\n\t\t\tlistenerNew.SslCertificate = CommandLine.GetSwitch(\u0022-rcon.ssl\u0022, null);\n\t\t\tlistenerNew.SslCertificatePassword = CommandLine.GetSwitch(\u0022-rcon.sslpwd\u0022, null);\n\t\t\tlistenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)\n\t\t\t{\n\t\t\t\tlock (Commands)\n\t\t\t\t{\n\t\t\t\t\tCommand item = JsonConvert.DeserializeObject\u003CCommand\u003E(msg);\n\t\t\t\t\titem.Ip = ip;\n\t\t\t\t\titem.ConnectionId = id;\n\t\t\t\t\tCommands.Enqueue(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlistenerNew.Start();\n\t\t\tDebug.Log(\u0022WebSocket RCon Started on \u0022 \u002B Port);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlistener = new RConListener();\n\t\t\tDebug.Log(\u0022RCon Started on \u0022 \u002B Port);\n\t\t\tDebug.Log(\u0022Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityActiveCheck(BaseEntity ent, BasePlayer player, uint id, string debugName)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityActiveCheck\u0022, ent, player, id, debugName);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tItem activeItem = player.GetActiveItem();\n\t\t\t\tif (activeItem == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (activeItem.GetHeldEntity() != ent)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnBookmarkAdd(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "AddBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AddBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003C nextAddTime)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Slow down...\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (controlBookmarks.Count \u003E= 128)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Too many bookmarks, delete some\u0022);\n\t\t\treturn;\n\t\t}\n\t\tnextAddTime = UnityEngine.Time.realtimeSinceStartup \u002B 1f;\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (KeyValuePair\u003Cstring, uint\u003E controlBookmark in controlBookmarks)\n\t\t{\n\t\t\tif (controlBookmark.Key == text)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tuint num = 0u;\n\t\tbool flag = false;\n\t\tforeach (IRemoteControllable allControllable in RemoteControlEntity.allControllables)\n\t\t{\n\t\t\tif (allControllable != null \u0026\u0026 allControllable.GetIdentifier() == text)\n\t\t\t{\n\t\t\t\tif (!(allControllable.GetEnt() == null))\n\t\t\t\t{\n\t\t\t\t\tnum = allControllable.GetEnt().net.ID;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDebug.LogWarning(\u0022Computer station added bookmark with missing ent, likely a static CCTV (wipe the server)\u0022);\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(num);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable component = baseNetworkable.GetComponent\u003CIRemoteControllable\u003E();\n\t\tif (component != null \u0026\u0026 Interface.CallHook(\u0022OnBookmarkAdd\u0022, this, player, text) == null)\n\t\t{\n\t\t\tstring identifier = component.GetIdentifier();\n\t\t\tif (text == identifier)\n\t\t\t{\n\t\t\t\tcontrolBookmarks.Add(text, num);\n\t\t\t}\n\t\t\tSendControlBookmarks(player);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 57
  },
  {
    "HookSignature": "OnEntityDistanceCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityDistanceCheck\u0022, ent, player, id, debugName, maximumDistance);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\treturn ent.Distance(player.eyes.position) \u003C= maximumDistance;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanEntityBeHostile(BasePlayer basePlayer)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic override bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn State.unHostileTimestamp \u003E TimeEx.currentTimestamp;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (HasLockPermission(player))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn !IsLocked();\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnPlayerSpectate(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StartSpectating()",
    "MethodSourseCode": "\n\tpublic void StartSpectating()\n\t{\n\t\tif (!IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectate\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: true);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tChatMessage(\u0022Becoming Spectator\u0022);\n\t\t\tUpdateSpectateTarget(spectateFilter);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity baseEntity)",
    "MethodSignature": "FlameTick()",
    "MethodSourseCode": "\n\tpublic void FlameTick()\n\t{\n\t\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;\n\t\tlastFlameTick = UnityEngine.Time.realtimeSinceStartup;\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tReduceAmmo(num);\n\t\tSendNetworkUpdate();\n\t\tRay ray = ownerPlayer.eyes.BodyRay();\n\t\tVector3 origin = ray.origin;\n\t\tRaycastHit hitInfo;\n\t\tbool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);\n\t\tif (!num2)\n\t\t{\n\t\t\thitInfo.point = origin \u002B ray.direction * flameRange;\n\t\t}\n\t\tfloat num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);\n\t\tfloat amount = damagePerSec[0].amount;\n\t\tdamagePerSec[0].amount = amount * num * num3;\n\t\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2279681, useLineOfSight: true);\n\t\tdamagePerSec[0].amount = amount;\n\t\tif (num2 \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003E= nextFlameTime \u0026\u0026 hitInfo.distance \u003E 1.1f)\n\t\t{\n\t\t\tnextFlameTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.45f;\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnFlameThrowerBurn\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.creatorEntity = ownerPlayer;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t\tif (ammo == 0)\n\t\t{\n\t\t\tSetFlameState(wantsOn: false);\n\t\t}\n\t\tGetOwnerItem()?.LoseCondition(num);\n\t}\n",
    "ClassName": "FlameThrower",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnEntityLeave(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tif (entityContents != null \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\tentityContents.Remove(ent);\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneAnswered(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnItemAddedToContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Insert(Item item)",
    "MethodSourseCode": "\n\tpublic bool Insert(Item item)\n\t{\n\t\tif (itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsFull())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemList.Add(item);\n\t\titem.parent = this;\n\t\tif (!FindPosition(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tMarkDirty();\n\t\tif (onItemAddedRemoved != null)\n\t\t{\n\t\t\tonItemAddedRemoved(item, arg2: true);\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemAddedToContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnRfListenerRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tlistenList.Remove(obj);\n\t\t\t}\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnResearchCostDetermine(Item item, ResearchTable researchTable)",
    "MethodSignature": "ScrapForResearch(Item item)",
    "MethodSourseCode": "\n\tpublic int ScrapForResearch(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, item, this);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint result = 0;\n\t\tif (item.info.rarity == Rarity.Common)\n\t\t{\n\t\t\tresult = 20;\n\t\t}\n\t\tif (item.info.rarity == Rarity.Uncommon)\n\t\t{\n\t\t\tresult = 75;\n\t\t}\n\t\tif (item.info.rarity == Rarity.Rare)\n\t\t{\n\t\t\tresult = 125;\n\t\t}\n\t\tif (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)\n\t\t{\n\t\t\tresult = 500;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfListenerAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tDebug.Log(\u0022adding same listener twice\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenList.Add(obj);\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnQuarryToggled(MiningQuarry miningQuarry, BasePlayer msgPlayer)",
    "MethodSignature": "StopEngine(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void StopEngine(RPCMessage msg)\n\t{\n\t\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\n\t\tif ((bool)miningQuarry)\n\t\t{\n\t\t\tminingQuarry.EngineSwitch(isOn: false);\n\t\t\tInterface.CallHook(\u0022OnQuarryToggled\u0022, miningQuarry, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "EngineSwitch",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnLootSpawn(LootContainer lootContainer)",
    "MethodSignature": "SpawnLoot()",
    "MethodSourseCode": "\n\tpublic virtual void SpawnLoot()\n\t{\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\tDebug.Log(\u0022CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tbase.inventory.Clear();\n\t\tItemManager.DoRemoves();\n\t\tif (Interface.CallHook(\u0022OnLootSpawn\u0022, this) == null)\n\t\t{\n\t\t\tPopulateLoot();\n\t\t\tif (shouldRefreshContents)\n\t\t\t{\n\t\t\t\tInvoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTrapArm(BearTrap bearTrap, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Arm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Arm(RPCMessage rpc)\n\t{\n\t\tif (!Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapArm\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tArm();\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVehicleModuleDeselected(ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_DeselectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_DeselectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player.inventory.loot.IsLooting() \u0026\u0026 !(player.inventory.loot.entitySource != this))\n\t\t{\n\t\t\tif (player.inventory.loot.RemoveContainerAt(3))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnVehicleModuleDeselected\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnSolarPanelSunUpdate(SolarPanel solarPanel, int num)",
    "MethodSignature": "SunUpdate()",
    "MethodSourseCode": "\n\tpublic void SunUpdate()\n\t{\n\t\tint num = currentEnergy;\n\t\tif (TOD_Sky.Instance.IsNight)\n\t\t{\n\t\t\tnum = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVector3 normalized = (TOD_Sky.Instance.Components.Sun.transform.position - sunSampler.transform.position).normalized;\n\t\t\tfloat value = Vector3.Dot(sunSampler.transform.forward, normalized);\n\t\t\tfloat num2 = Mathf.InverseLerp(dot_minimum, dot_maximum, value);\n\t\t\tif (num2 \u003E 0f \u0026\u0026 !IsVisible(sunSampler.transform.position \u002B normalized * 100f, 101f))\n\t\t\t{\n\t\t\t\tnum2 = 0f;\n\t\t\t}\n\t\t\tnum = Mathf.FloorToInt((float)maximalPowerOutput * num2 * base.healthFraction);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSolarPanelSunUpdate\u0022, this, num) == null)\n\t\t{\n\t\t\tbool num3 = currentEnergy != num;\n\t\t\tcurrentEnergy = num;\n\t\t\tif (num3)\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SolarPanel",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnEntityEnter(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif ((bool)basePlayer \u0026\u0026 Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t{\n\t\t\t_players.Add(basePlayer);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanAssignBed(BasePlayer msgPlayer, SleepingBag sleepingBag, ulong num)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 deployerUserID == msg.player.userID)\n\t\t{\n\t\t\tulong num = msg.read.UInt64();\n\t\t\tif (num != 0L \u0026\u0026 Interface.CallHook(\u0022CanAssignBed\u0022, msg.player, this, num) == null)\n\t\t\t{\n\t\t\t\tdeployerUserID = num;\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnFuelCheck(EntityFuelSystem entityFuelSystem)",
    "MethodSignature": "HasFuel(bool forceCheck)",
    "MethodSourseCode": "\n\tpublic bool HasFuel(bool forceCheck = false)\n\t{\n\t\tif (Time.time \u003E nextFuelCheckTime || forceCheck)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnFuelCheck\u0022, this);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tcachedHasFuel = (float)GetFuelAmount() \u003E 0f;\n\t\t\tnextFuelCheckTime = Time.time \u002B UnityEngine.Random.Range(1f, 2f);\n\t\t}\n\t\treturn cachedHasFuel;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, Signage signage)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBuildingSplit(BuildingManager.Building building, uint newID)",
    "MethodSignature": "Split(Building building)",
    "MethodSourseCode": "\n\tprivate void Split(Building building)\n\t{\n\t\twhile (building.HasBuildingBlocks())\n\t\t{\n\t\t\tBuildingBlock buildingBlock = building.buildingBlocks[0];\n\t\t\tuint newID = BuildingManager.server.NewBuildingID();\n\t\t\tInterface.CallHook(\u0022OnBuildingSplit\u0022, building, newID);\n\t\t\tbuildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)\n\t\t\t{\n\t\t\t\tb.AttachToBuilding(newID);\n\t\t\t});\n\t\t}\n\t\twhile (building.HasBuildingPrivileges())\n\t\t{\n\t\t\tBuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];\n\t\t\tBuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();\n\t\t\tbuildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);\n\t\t}\n\t\twhile (building.HasDecayEntities())\n\t\t{\n\t\t\tDecayEntity decayEntity = building.decayEntities[0];\n\t\t\tBuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();\n\t\t\tdecayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);\n\t\t}\n\t\tif (AI.nav_carve_use_building_optimization)\n\t\t{\n\t\t\tbuilding.isNavMeshCarvingDirty = true;\n\t\t\tint ticks = 2;\n\t\t\tUpdateNavMeshCarver(building, ref ticks, 0);\n\t\t}\n\t}\n",
    "ClassName": "ServerBuildingManager",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanUseHelicopter(BasePlayer player, CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "AttemptMount(BasePlayer player, bool doMountChecks)",
    "MethodSourseCode": "\n\tpublic override void AttemptMount(BasePlayer player, bool doMountChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanUseHelicopter\u0022, player, this) == null)\n\t\t{\n\t\t\tbase.AttemptMount(player, doMountChecks);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, CodeLock codeLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsLocked())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\n\t\t{\n\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\treturn true;\n\t\t}\n\t\tDoEffect(effectDenied.resourcePath);\n\t\treturn false;\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFBroadcaster rFBroadcaster, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 playerUsable \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (RFManager.IsReserved(num))\n\t\t\t{\n\t\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsPowered());\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSignature": "LoseCondition(float amount)",
    "MethodSourseCode": "\n\tpublic void LoseCondition(float amount)\n\t{\n\t\tif (hasCondition \u0026\u0026 !Debugging.disablecondition \u0026\u0026 Interface.CallHook(\u0022IOnLoseCondition\u0022, this, amount) == null)\n\t\t{\n\t\t\tfloat num = condition;\n\t\t\tcondition -= amount;\n\t\t\tif (ConVar.Global.developer \u003E 0)\n\t\t\t{\n\t\t\t\tDebug.Log(info.shortname \u002B \u0022 was damaged by: \u0022 \u002B amount \u002B \u0022cond is: \u0022 \u002B condition \u002B \u0022/\u0022 \u002B maxCondition);\n\t\t\t}\n\t\t\tif (condition \u003C= 0f \u0026\u0026 condition \u003C num)\n\t\t\t{\n\t\t\t\tOnBroken();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBigWheelLoss(BigWheelGame bigWheelGame, Item slot2, BigWheelBettingTerminal terminal)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(null, \u0022WinOrLoseSound\u0022, flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnItemDropped(Item item, BaseEntity baseEntity)",
    "MethodSignature": "Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)",
    "MethodSourseCode": "\n\tpublic BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))\n\t{\n\t\tRemoveFromWorld();\n\t\tBaseEntity baseEntity = null;\n\t\tif (vPos != Vector3.zero \u0026\u0026 !info.HasFlag(ItemDefinition.Flag.NoDropping))\n\t\t{\n\t\t\tbaseEntity = CreateWorldObject(vPos, rotation);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(vVelocity);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRemove();\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemDropped\u0022, this, baseEntity);\n\t\tRemoveFromContainer();\n\t\treturn baseEntity;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnRfListenerRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tlistenList.Remove(obj);\n\t\t\t}\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "OnProjectileAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void OnProjectileAttack(RPCMessage msg)\n\t{\n\t\tPlayerProjectileAttack playerProjectileAttack = PlayerProjectileAttack.Deserialize(msg.read);\n\t\tif (playerProjectileAttack == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerAttack playerAttack = playerProjectileAttack.playerAttack;\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\thitInfo.Initiator = this;\n\t\thitInfo.ProjectileID = playerAttack.projectileID;\n\t\thitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;\n\t\thitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;\n\t\thitInfo.Predicted = msg.connection;\n\t\tif (hitInfo.IsNaNOrInfinity() || float.IsNaN(playerProjectileAttack.travelTime) || float.IsInfinity(playerProjectileAttack.travelTime))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_nan\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_invalid\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Integrity is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_integrity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_lifetime\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.ricochets \u003E 0)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile is ricochet (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_ricochet\u0022);\n\t\t\treturn;\n\t\t}\n\t\thitInfo.Weapon = value.weaponSource;\n\t\thitInfo.WeaponPrefab = value.weaponPrefab;\n\t\thitInfo.ProjectilePrefab = value.projectilePrefab;\n\t\thitInfo.damageProperties = value.projectilePrefab.damageProperties;\n\t\tUnityEngine.Vector3 position = value.position;\n\t\tUnityEngine.Vector3 velocity = value.velocity;\n\t\tfloat partialTime = value.partialTime;\n\t\tfloat travelTime = value.travelTime;\n\t\tfloat num = Mathf.Clamp(playerProjectileAttack.travelTime, 0f, 8f);\n\t\tUnityEngine.Vector3 gravity = UnityEngine.Physics.gravity * value.projectilePrefab.gravityModifier;\n\t\tfloat drag = value.projectilePrefab.drag;\n\t\tint layerMask = (ConVar.AntiHack.projectile_terraincheck ? 10551296 : 2162688);\n\t\tBaseEntity hitEntity = hitInfo.HitEntity;\n\t\tBasePlayer basePlayer = hitEntity as BasePlayer;\n\t\tbool flag = basePlayer != null;\n\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\tbool flag5 = hitEntity != null;\n\t\tbool flag6 = flag5 \u0026\u0026 hitEntity.IsNpc;\n\t\tbool flag7 = hitInfo.HitMaterial == Projectile.WaterMaterialID();\n\t\tif (value.protection \u003E 0)\n\t\t{\n\t\t\tbool flag8 = true;\n\t\t\tfloat num2 = 1f \u002B ConVar.AntiHack.projectile_forgiveness;\n\t\t\tfloat projectile_clientframes = ConVar.AntiHack.projectile_clientframes;\n\t\t\tfloat projectile_serverframes = ConVar.AntiHack.projectile_serverframes;\n\t\t\tfloat num3 = Mathx.Decrement(value.firedTime);\n\t\t\tfloat num4 = Mathf.Clamp(Mathx.Increment(UnityEngine.Time.realtimeSinceStartup) - num3, 0f, 8f);\n\t\t\tfloat num5 = num;\n\t\t\tfloat num6 = Mathf.Abs(num4 - num5);\n\t\t\tfloat num7 = Mathf.Min(num4, num5);\n\t\t\tfloat num8 = projectile_clientframes / 60f;\n\t\t\tfloat num9 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\tfloat num10 = (desyncTimeClamped \u002B num7 \u002B num8 \u002B num9) * num2;\n\t\t\tfloat num11 = ((value.protection \u003E= 6) ? ((desyncTimeClamped \u002B num8 \u002B num9) * num2) : num10);\n\t\t\tif (flag \u0026\u0026 hitInfo.boneArea == (HitArea)(-1))\n\t\t\t{\n\t\t\t\tstring text = hitInfo.ProjectilePrefab.name;\n\t\t\t\tstring text2 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Bone is invalid (\u0022 \u002B text \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 bone \u0022 \u002B hitInfo.HitBone \u002B \u0022)\u0022);\n\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_bone\u0022);\n\t\t\t\tflag8 = false;\n\t\t\t}\n\t\t\tif (flag7)\n\t\t\t{\n\t\t\t\tif (flag5)\n\t\t\t\t{\n\t\t\t\t\tstring text3 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text4 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water hit on entity (\u0022 \u002B text3 \u002B \u0022 on \u0022 \u002B text4 \u002B \u0022)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022water_entity\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (!WaterLevel.Test(hitInfo.HitPositionWorld, 0.5f, waves: false, this))\n\t\t\t\t{\n\t\t\t\t\tstring text5 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text6 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water level (\u0022 \u002B text5 \u002B \u0022 on \u0022 \u002B text6 \u002B \u0022)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022water_level\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 2)\n\t\t\t{\n\t\t\t\tif (flag5)\n\t\t\t\t{\n\t\t\t\t\tfloat num12 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num13 = hitEntity.BoundsPadding() \u002B num11 * num12;\n\t\t\t\t\tfloat num14 = hitEntity.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\tif (num14 \u003E num13)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text7 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName = hitEntity.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Entity too far away (\u0022 \u002B text7 \u002B \u0022 on \u0022 \u002B shortPrefabName \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num13 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tstats.combat.Log(hitInfo, \u0022entity_distance\u0022);\n\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value.protection \u003E= 6 \u0026\u0026 flag8 \u0026\u0026 flag \u0026\u0026 !flag6 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4)\n\t\t\t\t{\n\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num15 = basePlayer.BoundsPadding() \u002B num11 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\tfloat num16 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);\n\t\t\t\t\tif (num16 \u003E num15)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text8 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName2 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Player too far away (\u0022 \u002B text8 \u002B \u0022 on \u0022 \u002B shortPrefabName2 \u002B \u0022 with \u0022 \u002B num16 \u002B \u0022m \u003E \u0022 \u002B num15 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tstats.combat.Log(hitInfo, \u0022player_distance\u0022);\n\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 1)\n\t\t\t{\n\t\t\t\tfloat magnitude2 = value.initialVelocity.magnitude;\n\t\t\t\tfloat num17 = hitInfo.ProjectilePrefab.initialDistance \u002B num10 * magnitude2;\n\t\t\t\tfloat num18 = hitInfo.ProjectileDistance \u002B 1f;\n\t\t\t\tfloat num19 = UnityEngine.Vector3.Distance(value.initialPosition, hitInfo.HitPositionWorld);\n\t\t\t\tif (num19 \u003E num17)\n\t\t\t\t{\n\t\t\t\t\tstring text9 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text10 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too fast (\u0022 \u002B text9 \u002B \u0022 on \u0022 \u002B text10 \u002B \u0022 with \u0022 \u002B num19 \u002B \u0022m \u003E \u0022 \u002B num17 \u002B \u0022m in \u0022 \u002B num10 \u002B \u0022s)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_speed\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (num19 \u003E num18)\n\t\t\t\t{\n\t\t\t\t\tstring text11 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text12 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too far away (\u0022 \u002B text11 \u002B \u0022 on \u0022 \u002B text12 \u002B \u0022 with \u0022 \u002B num19 \u002B \u0022m \u003E \u0022 \u002B num18 \u002B \u0022m in \u0022 \u002B num10 \u002B \u0022s)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_distance\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (num6 \u003E ConVar.AntiHack.projectile_desync)\n\t\t\t\t{\n\t\t\t\t\tstring text13 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text14 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile desync (\u0022 \u002B text13 \u002B \u0022 on \u0022 \u002B text14 \u002B \u0022 with \u0022 \u002B num6 \u002B \u0022s \u003E \u0022 \u002B ConVar.AntiHack.projectile_desync \u002B \u0022s)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_desync\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 3)\n\t\t\t{\n\t\t\t\tUnityEngine.Vector3 position2 = value.position;\n\t\t\t\tUnityEngine.Vector3 pointStart = hitInfo.PointStart;\n\t\t\t\tUnityEngine.Vector3 hitPositionWorld = hitInfo.HitPositionWorld;\n\t\t\t\tUnityEngine.Vector3 vector = hitInfo.PositionOnRay(hitPositionWorld);\n\t\t\t\tif (!flag7)\n\t\t\t\t{\n\t\t\t\t\thitPositionWorld \u002B= hitInfo.HitNormalWorld.normalized * 0.001f;\n\t\t\t\t}\n\t\t\t\tbool num20 = GamePhysics.LineOfSight(position2, pointStart, vector, hitPositionWorld, layerMask);\n\t\t\t\tif (!num20)\n\t\t\t\t{\n\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B (flag5 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B (flag5 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t}\n\t\t\t\tif (!num20)\n\t\t\t\t{\n\t\t\t\t\tstring text15 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text16 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(\u0022Line of sight (\u0022, text15, \u0022 on \u0022, text16, \u0022) \u0022, position2, \u0022 \u0022, pointStart, \u0022 \u0022, vector, \u0022 \u0022, hitPositionWorld));\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_los\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (flag8 \u0026\u0026 flag \u0026\u0026 !flag6)\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Vector3 hitPositionWorld2 = hitInfo.HitPositionWorld;\n\t\t\t\t\tUnityEngine.Vector3 position3 = basePlayer.eyes.position;\n\t\t\t\t\tUnityEngine.Vector3 vector2 = basePlayer.CenterPoint();\n\t\t\t\t\tif (!flag7)\n\t\t\t\t\t{\n\t\t\t\t\t\thitPositionWorld2 \u002B= hitInfo.HitNormalWorld.normalized * 0.001f;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!GamePhysics.LineOfSight(hitPositionWorld2, position3, layerMask, 0f, ConVar.AntiHack.losforgiveness) || !GamePhysics.LineOfSight(position3, hitPositionWorld2, layerMask, ConVar.AntiHack.losforgiveness, 0f)) \u0026\u0026 (!GamePhysics.LineOfSight(hitPositionWorld2, vector2, layerMask, 0f, ConVar.AntiHack.losforgiveness) || !GamePhysics.LineOfSight(vector2, hitPositionWorld2, layerMask, ConVar.AntiHack.losforgiveness, 0f)))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text17 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring text18 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(\u0022Line of sight (\u0022, text17, \u0022 on \u0022, text18, \u0022) \u0022, hitPositionWorld2, \u0022 \u0022, position3, \u0022 or \u0022, hitPositionWorld2, \u0022 \u0022, vector2));\n\t\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_los\u0022);\n\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 4)\n\t\t\t{\n\t\t\t\tSimulateProjectile(ref position, ref velocity, ref partialTime, num - travelTime, gravity, drag, out var prevPosition, out var prevVelocity);\n\t\t\t\tUnityEngine.Vector3 vector3 = prevVelocity * (1f / 32f);\n\t\t\t\tLine line = new Line(prevPosition - vector3, position \u002B vector3);\n\t\t\t\tfloat num21 = line.Distance(hitInfo.PointStart);\n\t\t\t\tfloat num22 = line.Distance(hitInfo.HitPositionWorld);\n\t\t\t\tif (num21 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text19 = value.projectilePrefab.name;\n\t\t\t\t\tstring text20 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Start position trajectory (\u0022 \u002B text19 \u002B \u0022 on \u0022 \u002B text20 \u002B \u0022 with \u0022 \u002B num21 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022trajectory_start\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (num22 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text21 = value.projectilePrefab.name;\n\t\t\t\t\tstring text22 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022End position trajectory (\u0022 \u002B text21 \u002B \u0022 on \u0022 \u002B text22 \u002B \u0022 with \u0022 \u002B num22 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022trajectory_end\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\thitInfo.ProjectileVelocity = velocity;\n\t\t\t\tif (playerProjectileAttack.hitVelocity != UnityEngine.Vector3.zero \u0026\u0026 velocity != UnityEngine.Vector3.zero)\n\t\t\t\t{\n\t\t\t\t\tfloat num23 = UnityEngine.Vector3.Angle(playerProjectileAttack.hitVelocity, velocity);\n\t\t\t\t\tfloat num24 = playerProjectileAttack.hitVelocity.magnitude / velocity.magnitude;\n\t\t\t\t\tif (num23 \u003E ConVar.AntiHack.projectile_anglechange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text23 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text24 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory angle change (\u0022 \u002B text23 \u002B \u0022 on \u0022 \u002B text24 \u002B \u0022 with \u0022 \u002B num23 \u002B \u0022deg \u003E \u0022 \u002B ConVar.AntiHack.projectile_anglechange \u002B \u0022deg)\u0022);\n\t\t\t\t\t\tstats.combat.Log(hitInfo, \u0022angle_change\u0022);\n\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (num24 \u003E ConVar.AntiHack.projectile_velocitychange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text25 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text26 = (flag5 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory velocity change (\u0022 \u002B text25 \u002B \u0022 on \u0022 \u002B text26 \u002B \u0022 with \u0022 \u002B num24 \u002B \u0022 \u003E \u0022 \u002B ConVar.AntiHack.projectile_velocitychange \u002B \u0022)\u0022);\n\t\t\t\t\t\tstats.combat.Log(hitInfo, \u0022velocity_change\u0022);\n\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag8)\n\t\t\t{\n\t\t\t\tAntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);\n\t\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\t\tplayerProjectileAttack = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvalue.position = hitInfo.HitPositionWorld;\n\t\tvalue.velocity = playerProjectileAttack.hitVelocity;\n\t\tvalue.travelTime = num;\n\t\tvalue.partialTime = partialTime;\n\t\tvalue.hits\u002B\u002B;\n\t\thitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);\n\t\tif (value.integrity \u003C 1f)\n\t\t{\n\t\t\tvalue.integrity = 0f;\n\t\t}\n\t\telse if (flag7)\n\t\t{\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - 0.1f);\n\t\t}\n\t\telse if (hitInfo.ProjectilePrefab.penetrationPower \u003C= 0f || !flag5)\n\t\t{\n\t\t\tvalue.integrity = 0f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat num25 = hitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - num25);\n\t\t\tvalue.position \u002B= playerProjectileAttack.hitVelocity.normalized * 0.001f;\n\t\t}\n\t\tif (flag5)\n\t\t{\n\t\t\tstats.Add(value.itemMod.category \u002B \u0022_hit_\u0022 \u002B hitEntity.Categorize(), 1);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, this, hitInfo) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tif (value.hits \u003C= 1)\n\t\t\t{\n\t\t\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\n\t\t\t}\n\t\t\tif (hitInfo.ProjectilePrefab.remainInWorld)\n\t\t\t{\n\t\t\t\tCreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);\n\t\t\t}\n\t\t}\n\t\tfiredProjectiles[playerAttack.projectileID] = value;\n\t\tif (flag5)\n\t\t{\n\t\t\tif (value.hits \u003C= 1 || flag6 || (flag \u0026\u0026 !flag2))\n\t\t\t{\n\t\t\t\thitEntity.OnAttacked(hitInfo);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.Log(hitInfo, \u0022ricochet\u0022);\n\t\t\t}\n\t\t}\n\t\thitInfo.DoHitEffects = hitInfo.ProjectilePrefab.doDefaultHitEffects;\n\t\tEffect.server.ImpactEffect(hitInfo);\n\t\tplayerProjectileAttack.ResetToPool();\n\t\tplayerProjectileAttack = null;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 311
  },
  {
    "HookSignature": "OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable component)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.ContainsKey(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint uid = controlBookmarks[text];\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable component = baseNetworkable.GetComponent\u003CIRemoteControllable\u003E();\n\t\tif (component.CanControl() \u0026\u0026 !(component.GetIdentifier() != text) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, component) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E()?.StopControl();\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(baseNetworkable.net.group);\n\t\t\tcurrentlyControllingEnt.uid = baseNetworkable.net.ID;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tcomponent.InitializeControl(player);\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, component);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "CanEntityBeHostile(BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic virtual bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn unHostileTime \u003E UnityEngine.Time.realtimeSinceStartup;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Network.Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnDisconnected(string strReason, Network.Connection connection)\n\t{\n\t\tconnectionQueue.RemoveConnection(connection);\n\t\tConnectionAuth.OnDisconnect(connection);\n\t\tPlatformService.Instance.EndPlayerSession(connection.userid);\n\t\tEACServer.OnLeaveGame(connection);\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif ((bool)basePlayer)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDisconnected\u0022, basePlayer, strReason);\n\t\t\tbasePlayer.OnDisconnected();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl();\n\t\t\tif ((bool)ply)\n\t\t\t{\n\t\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t\t}\n\t\t}\n\t\tcurrentlyControllingEnt.uid = 0u;\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnServerInitialize()",
    "MethodSignature": "Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)",
    "MethodSourseCode": "\n\tpublic void Initialize(bool loadSave = true, string saveFile = \u0022\u0022, bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\n\t{\n\t\tInterface.CallHook(\u0022OnServerInitialize\u0022);\n\t\tpersistance = new UserPersistance(ConVar.Server.rootFolder);\n\t\tplayerStateManager = new PlayerStateManager(persistance);\n\t\tSpawnMapEntities();\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.UpdateDistributions\u0022))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.UpdateDistributions();\n\t\t\t}\n\t\t}\n\t\tif (loadSave)\n\t\t{\n\t\t\tskipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves);\n\t\t}\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tif (!skipInitialSpawn)\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.InitialSpawn\u0022, 200))\n\t\t\t\t{\n\t\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.InitialSpawn();\n\t\t\t\t}\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.StartSpawnTick\u0022, 200))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.StartSpawnTick();\n\t\t\t}\n\t\t}\n\t\tCreateImportantEntities();\n\t\tauth = GetComponent\u003CConnectionAuth\u003E();\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControl(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable component)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.ContainsKey(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint uid = controlBookmarks[text];\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable component = baseNetworkable.GetComponent\u003CIRemoteControllable\u003E();\n\t\tif (component.CanControl() \u0026\u0026 !(component.GetIdentifier() != text) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, component) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E()?.StopControl();\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(baseNetworkable.net.group);\n\t\t\tcurrentlyControllingEnt.uid = baseNetworkable.net.ID;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tcomponent.InitializeControl(player);\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, component);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnAirdrop(CargoPlane cargoPlane, UnityEngine.Vector3 newDropPosition)",
    "MethodSignature": "UpdateDropPosition(Vector3 newDropPosition)",
    "MethodSourseCode": "\n\tpublic void UpdateDropPosition(Vector3 newDropPosition)\n\t{\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat y = TerrainMeta.HighestPoint.y \u002B 250f;\n\t\tstartPos = Vector3Ex.Range(-1f, 1f);\n\t\tstartPos.y = 0f;\n\t\tstartPos.Normalize();\n\t\tstartPos *= x * 2f;\n\t\tstartPos.y = y;\n\t\tendPos = startPos * -1f;\n\t\tendPos.y = startPos.y;\n\t\tstartPos \u002B= newDropPosition;\n\t\tendPos \u002B= newDropPosition;\n\t\tsecondsToTake = Vector3.Distance(startPos, endPos) / 50f;\n\t\tsecondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\n\t\tbase.transform.position = startPos;\n\t\tbase.transform.rotation = Quaternion.LookRotation(endPos - startPos);\n\t\tdropPosition = newDropPosition;\n\t\tInterface.CallHook(\u0022OnAirdrop\u0022, this, newDropPosition);\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "ToStream(Stream stream, SaveInfo saveInfo)",
    "MethodSourseCode": "\n\tprivate void ToStream(Stream stream, SaveInfo saveInfo)\n\t{\n\t\tusing (saveInfo.msg = Facepunch.Pool.Get\u003CProtoBuf.Entity\u003E())\n\t\t{\n\t\t\tSave(saveInfo);\n\t\t\tif (saveInfo.msg.baseEntity == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(string.Concat(this, \u0022: ToStream - no BaseEntity!?\u0022));\n\t\t\t}\n\t\t\tif (saveInfo.msg.baseNetworkable == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(string.Concat(this, \u0022: ToStream - no baseNetworkable!?\u0022));\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnEntitySaved\u0022, this, saveInfo);\n\t\t\tsaveInfo.msg.ToProto(stream);\n\t\t\tPostSave(saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnNpcDestinationSet(NPCPlayerApex nPCPlayerApex, UnityEngine.Vector3 newDestination)",
    "MethodSignature": "SetDestination(Vector3 newDestination)",
    "MethodSourseCode": "\n\tpublic override void SetDestination(Vector3 newDestination)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcDestinationSet\u0022, this, newDestination) == null)\n\t\t{\n\t\t\tbase.SetDestination(newDestination);\n\t\t\tDestination = newDestination;\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)",
    "MethodSignature": "RefreshSellOrderStockLevel(ItemDefinition itemDef)",
    "MethodSourseCode": "\n\tpublic void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)\n\t{\n\t\tforeach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)\n\t\t{\n\t\t\tif (!(itemDef == null) \u0026\u0026 itemDef.itemid != sellOrder.itemToSellID)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\t\tGetItemsToSell(sellOrder, obj);\n\t\t\tint inStock;\n\t\t\tif (obj.Count \u003C 0)\n\t\t\t{\n\t\t\t\tinStock = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E source = obj;\n\t\t\t\tFunc\u003CItem, int\u003E selector = (Item x) =\u003E x.amount;\n\t\t\t\tInterface.CallHook(\u0022OnRefreshVendingStock\u0022, this, itemDef);\n\t\t\t\tinStock = source.Sum(selector) / sellOrder.itemToSellAmount;\n\t\t\t}\n\t\t\tsellOrder.inStock = inStock;\n\t\t\tfloat itemCondition = 0f;\n\t\t\tfloat itemConditionMax = 0f;\n\t\t\tif (obj.Count \u003E 0 \u0026\u0026 obj[0].hasCondition)\n\t\t\t{\n\t\t\t\titemCondition = obj[0].condition;\n\t\t\t\titemConditionMax = obj[0].maxCondition;\n\t\t\t}\n\t\t\tsellOrder.itemCondition = itemCondition;\n\t\t\tsellOrder.itemConditionMax = itemConditionMax;\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnTeamPromote(RelationshipManager.PlayerTeam playerTeam, BasePlayer lookingAtPlayer)",
    "MethodSignature": "promote(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void promote(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);\n\t\tif (!(lookingAtPlayer == null) \u0026\u0026 !lookingAtPlayer.IsDead() \u0026\u0026 !(lookingAtPlayer == basePlayer) \u0026\u0026 lookingAtPlayer.currentTeam == basePlayer.currentTeam)\n\t\t{\n\t\t\tPlayerTeam playerTeam = Instance.teams[basePlayer.currentTeam];\n\t\t\tif (playerTeam != null \u0026\u0026 playerTeam.teamLeader == basePlayer.userID \u0026\u0026 Interface.CallHook(\u0022OnTeamPromote\u0022, playerTeam, lookingAtPlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.SetTeamLeader(lookingAtPlayer.userID);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnNpcConversationEnded(NPCTalking nPCTalking, BasePlayer msgPlayer)",
    "MethodSignature": "Server_EndTalking(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_EndTalking(RPCMessage msg)\n\t{\n\t\tOnConversationEnded(msg.player);\n\t\tInterface.CallHook(\u0022OnNpcConversationEnded\u0022, this, msg.player);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneCallStart(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnElevatorMove(Elevator elevator, int targetFloor)",
    "MethodSignature": "RequestMoveLiftTo(int targetFloor, float timeToTravel)",
    "MethodSourseCode": "\n\tpublic bool RequestMoveLiftTo(int targetFloor, out float timeToTravel)\n\t{\n\t\ttimeToTravel = 0f;\n\t\tif (Interface.CallHook(\u0022OnElevatorMove\u0022, this, targetFloor) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsStatic \u0026\u0026 ioEntity != null \u0026\u0026 !ioEntity.IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValidFloor(targetFloor))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!liftEntity.CanMove())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (LiftPositionToFloor() == targetFloor)\n\t\t{\n\t\t\tOnLiftCalledWhenAtTargetFloor();\n\t\t\treturn false;\n\t\t}\n\t\tOnMoveBegin();\n\t\tVector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);\n\t\tVector3 vector = base.transform.InverseTransformPoint(worldSpaceFloorPosition);\n\t\ttimeToTravel = TimeToTravelDistance(Mathf.Abs(liftEntity.transform.localPosition.y - vector.y));\n\t\tLeanTween.moveLocalY(liftEntity.gameObject, vector.y, timeToTravel);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tif (targetFloor \u003C Floor)\n\t\t{\n\t\t\tliftEntity.ToggleHurtTrigger(state: true);\n\t\t}\n\t\tInvoke(ClearBusy, timeToTravel);\n\t\tif (ioEntity != null)\n\t\t{\n\t\t\tioEntity.SetFlag(Flags.Busy, b: true);\n\t\t\tioEntity.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Elevator",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCargoShipEgress(CargoShip cargoShip)",
    "MethodSignature": "StartEgress()",
    "MethodSourseCode": "\n\tpublic void StartEgress()\n\t{\n\t\tif (!egressing \u0026\u0026 Interface.CallHook(\u0022OnCargoShipEgress\u0022, this) == null)\n\t\t{\n\t\t\tegressing = true;\n\t\t\tCancelInvoke(PlayHorn);\n\t\t\tradiation.SetActive(value: true);\n\t\t\tSetFlag(Flags.Reserved8, b: true);\n\t\t\tInvokeRepeating(UpdateRadiation, 10f, 1f);\n\t\t\tInvoke(DelayedDestroy, 60f * egress_duration_minutes);\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Remove(obj);\n\t\t\t}\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnMapMarkerRemove(BasePlayer basePlayer, ProtoBuf.MapNote ServerCurrentMapNote)",
    "MethodSignature": "Server_RemovePointOfInterest(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void Server_RemovePointOfInterest(RPCMessage msg)\n\t{\n\t\tif (ServerCurrentMapNote != null \u0026\u0026 Interface.CallHook(\u0022OnMapMarkerRemove\u0022, this, ServerCurrentMapNote) == null)\n\t\t{\n\t\t\tServerCurrentMapNote.Dispose();\n\t\t\tServerCurrentMapNote = null;\n\t\t\tDirtyPlayerState();\n\t\t\tTeamUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(null, \u0022ClientOnDialFailed\u0022, (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnExcavatorMiningToggled(ExcavatorArm excavatorArm)",
    "MethodSignature": "BeginMining()",
    "MethodSourseCode": "\n\tpublic void BeginMining()\n\t{\n\t\tif (IsPowered())\n\t\t{\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);\n\t\t\tExcavatorServerEffects.SetMining(isMining: true);\n\t\t\tFacepunch.Rust.Analytics.ExcavatorStarted();\n\t\t\texcavatorStartTime = GetNetworkTime();\n\t\t\tInterface.CallHook(\u0022OnExcavatorMiningToggled\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHelicopterRetire(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "Retire()",
    "MethodSourseCode": "\n\tpublic void Retire()\n\t{\n\t\tif (!isRetiring \u0026\u0026 Interface.CallHook(\u0022OnHelicopterRetire\u0022, this) == null)\n\t\t{\n\t\t\tisRetiring = true;\n\t\t\tInvoke(DestroyMe, 240f);\n\t\t\tfloat x = TerrainMeta.Size.x;\n\t\t\tfloat y = 200f;\n\t\t\tVector3 newPos = Vector3Ex.Range(-1f, 1f);\n\t\t\tnewPos.y = 0f;\n\t\t\tnewPos.Normalize();\n\t\t\tnewPos *= x * 20f;\n\t\t\tnewPos.y = y;\n\t\t\tExitCurrentState();\n\t\t\tState_Move_Enter(newPos);\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnServerUsersRemove(ulong uid)",
    "MethodSignature": "Remove(ulong uid)",
    "MethodSourseCode": "\n\tpublic static void Remove(ulong uid)\n\t{\n\t\tInterface.CallHook(\u0022IOnServerUsersRemove\u0022, uid);\n\t\tusers.Remove(uid);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModConsumable component = GetOwnerItemDefinition().GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tif (player != ownerPlayer \u0026\u0026 player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnPlayerLanded(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tmetabolism.bleeding.Add(num * 0.5f);\n\t\t\tfloat num2 = num * 500f;\n\t\t\tHurt(num2, DamageType.Fall);\n\t\t\tif (num2 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, KeyLock keyLock)",
    "MethodSignature": "RPC_Unlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Unlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null \u0026\u0026 HasLockPermission(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnExplosiveThrown(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoThrow(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tprivate void DoThrow(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tfloat num = Mathf.Clamp01(msg.read.Float());\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity.creatorEntity = msg.player;\n\t\tbaseEntity.skinID = skinID;\n\t\tbaseEntity.SetVelocity(GetInheritedVelocity(msg.player) \u002B normalized * maxThrowVelocity * num \u002B msg.player.estimatedVelocity * 0.5f);\n\t\tif (tumbleVelocity \u003E 0f)\n\t\t{\n\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);\n\t\t}\n\t\tbaseEntity.Spawn();\n\t\tSetUpThrownWeapon(baseEntity);\n\t\tStartAttackCooldown(repeatDelay);\n\t\tInterface.CallHook(\u0022OnExplosiveThrown\u0022, msg.player, baseEntity, this);\n\t\tUseItemAmount(1);\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\n\t\tif (timedExplosive != null)\n\t\t{\n\t\t\tfloat num2 = 0f;\n\t\t\tforeach (DamageTypeEntry damageType in timedExplosive.damageTypes)\n\t\t\t{\n\t\t\t\tnum2 \u002B= damageType.amount;\n\t\t\t}\n\t\t\tSensation sensation = default(Sensation);\n\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\tsensation.Position = player.transform.position;\n\t\t\tsensation.Radius = 50f;\n\t\t\tsensation.DamagePotential = num2;\n\t\t\tsensation.InitiatorPlayer = player;\n\t\t\tsensation.Initiator = player;\n\t\t\tsensation.UsedEntity = timedExplosive;\n\t\t\tSense.Stimulate(sensation);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSensation sensation = default(Sensation);\n\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\tsensation.Position = player.transform.position;\n\t\t\tsensation.Radius = 50f;\n\t\t\tsensation.DamagePotential = 0f;\n\t\t\tsensation.InitiatorPlayer = player;\n\t\t\tsensation.Initiator = player;\n\t\t\tsensation.UsedEntity = this;\n\t\t\tSense.Stimulate(sensation);\n\t\t}\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "OnEngineStatsRefresh(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer msgPlayer, BuildingGrade.Enum @enum)",
    "MethodSignature": "DoUpgradeToGrade(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void DoUpgradeToGrade(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract())\n\t\t{\n\t\t\tBuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();\n\t\t\tConstructionGrade constructionGrade = GetGrade(@enum);\n\t\t\tif (!(constructionGrade == null) \u0026\u0026 CanChangeToGrade(@enum, msg.player) \u0026\u0026 CanAffordUpgrade(@enum, msg.player) \u0026\u0026 !(base.SecondsSinceAttacked \u003C 30f) \u0026\u0026 Interface.CallHook(\u0022OnStructureUpgrade\u0022, this, msg.player, @enum) == null)\n\t\t\t{\n\t\t\t\tPayForUpgrade(constructionGrade, msg.player);\n\t\t\t\tSetGrade(@enum);\n\t\t\t\tSetHealthToMax();\n\t\t\t\tStartBeingRotatable();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tUpdateSkin();\n\t\t\t\tResetUpkeepTime();\n\t\t\t\tUpdateSurroundingEntities();\n\t\t\t\tBuildingManager.server.GetBuilding(buildingID)?.Dirty();\n\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/build/promote_\u0022 \u002B @enum.ToString().ToLower() \u002B \u0022.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanUseFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, float seconds, float fuelUsedPerSecond)",
    "MethodSignature": "TryUseFuel(float seconds, float fuelUsedPerSecond)",
    "MethodSourseCode": "\n\tpublic int TryUseFuel(float seconds, float fuelUsedPerSecond)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanUseFuel\u0022, this, fuelContainer, seconds, fuelUsedPerSecond);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tItem slot = fuelContainer.inventory.GetSlot(0);\n\t\tif (slot == null || slot.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tpendingFuel \u002B= seconds * fuelUsedPerSecond;\n\t\tif (pendingFuel \u003E= 1f)\n\t\t{\n\t\t\tint num = Mathf.FloorToInt(pendingFuel);\n\t\t\tslot.UseItem(num);\n\t\t\tpendingFuel -= num;\n\t\t\treturn num;\n\t\t}\n\t\treturn 0;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnSleepingBagDestroy(SleepingBag sleepingBag2, BasePlayer player)",
    "MethodSignature": "DestroyBag(BasePlayer player, uint sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(BasePlayer player, uint sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (sleepingBag2.canBePublic)\n\t\t{\n\t\t\tsleepingBag2.SetPublic(isPublic: true);\n\t\t\tsleepingBag2.deployerUserID = 0uL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\tplayer.SendRespawnOptions();\n\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, player);\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnVehicleModuleSelect(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tuint itemUID = msg.read.UInt32();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result) \u0026\u0026 result is VehicleModuleStorage vehicleModuleStorage)\n\t\t{\n\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnCreateWorldProjectile\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));\n\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\tcomponent.WakeUp();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRidableAnimalClaimed(BaseRidableAnimal baseRidableAnimal, BasePlayer player)",
    "MethodSignature": "RPC_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player) == null \u0026\u0026 IsForSale())\n\t\t{\n\t\t\tItem item = GetPurchaseToken(player);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\titem.UseItem();\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnActiveItemChanged(BasePlayer basePlayer, Item activeItem, Item activeItem2)",
    "MethodSignature": "UpdateActiveItem(uint itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(uint itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = 0u;\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = 0u;\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = 0u;\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnPlayerViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSignature": "AddViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSourseCode": "\n\tpublic static void AddViolation(BasePlayer ply, AntiHackType type, float amount)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerViolation\u0022, ply, type, amount) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022AntiHack.AddViolation\u0022))\n\t\t{\n\t\t\tply.lastViolationType = type;\n\t\t\tply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tply.violationLevel \u002B= amount;\n\t\t\tif ((ConVar.AntiHack.debuglevel \u003E= 2 \u0026\u0026 amount \u003E 0f) || ConVar.AntiHack.debuglevel \u003E= 3)\n\t\t\t{\n\t\t\t\tLogToConsole(ply, type, \u0022Added violation of \u0022 \u002B amount \u002B \u0022 in frame \u0022 \u002B UnityEngine.Time.frameCount \u002B \u0022 (now has \u0022 \u002B ply.violationLevel \u002B \u0022)\u0022);\n\t\t\t}\n\t\t\tEnforceViolations(ply);\n\t\t}\n\t}\n",
    "ClassName": "AntiHack",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSeeStash(BasePlayer rpcPlayer, StashContainer stashContainer)",
    "MethodSignature": "RPC_WantsUnhide(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_WantsUnhide(RPCMessage rpc)\n\t{\n\t\tif (IsHidden())\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif (PlayerInRange(player) \u0026\u0026 Interface.CallHook(\u0022CanSeeStash\u0022, rpc.player, this) == null)\n\t\t\t{\n\t\t\t\tSetHidden(isHidden: false);\n\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, this, rpc.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPhoneDialFail(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(null, \u0022ClientOnDialFailed\u0022, (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerCorpseSpawned(BasePlayer basePlayer, PlayerCorpse playerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(\u0022assets/prefabs/player/player_corpse.prefab\u0022) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tplayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "RPC_LootPlayer(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_LootPlayer(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanBeLooted(player) \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerMain);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerWear);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerBelt);\n\t\t\tInterface.CallHook(\u0022OnLootPlayer\u0022, this, player);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, \u0022player_corpse\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanCheckFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, BasePlayer player)",
    "MethodSignature": "IsInFuelInteractionRange(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool IsInFuelInteractionRange(BasePlayer player)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanCheckFuel\u0022, this, fuelContainer, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (fuelContainer != null)\n\t\t{\n\t\t\tfloat num = 0f;\n\t\t\tif (isServer)\n\t\t\t{\n\t\t\t\tnum = 3f;\n\t\t\t}\n\t\t\treturn fuelContainer.Distance(player.eyes.position) \u003C= num;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnReloadMagazine(BasePlayer ownerPlayer, BaseProjectile baseProjectile, int desiredAmount)",
    "MethodSignature": "ReloadMagazine(int desiredAmount)",
    "MethodSourseCode": "\n\tprotected virtual void ReloadMagazine(int desiredAmount = -1)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif ((bool)ownerPlayer \u0026\u0026 Interface.CallHook(\u0022OnReloadMagazine\u0022, ownerPlayer, this, desiredAmount) == null)\n\t\t{\n\t\t\tprimaryMagazine.Reload(ownerPlayer, desiredAmount);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItemManager.DoRemoves();\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerSleep(BasePlayer basePlayer)",
    "MethodSignature": "StartSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void StartSleeping()\n\t{\n\t\tif (!IsSleeping())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSleep\u0022, this);\n\t\t\tif (InSafeZone() \u0026\u0026 !IsInvoking(ScheduledDeath))\n\t\t\t{\n\t\t\t\tInvoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);\n\t\t\t}\n\t\t\tEnsureDismounted();\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: true);\n\t\t\tsleepStartTime = UnityEngine.Time.time;\n\t\t\tsleepingPlayerList.Add(this);\n\t\t\tbots.Remove(this);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tCancelInvoke(TeamUpdate);\n\t\t\tinventory.loot.Clear();\n\t\t\tinventory.crafting.CancelAll(returnItems: true);\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tTurnOffAllLights();\n\t\t\tEnablePlayerCollider();\n\t\t\tRemovePlayerRigidbody();\n\t\t\tEnableServerFall(wantsOn: true);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNetworkGroupEntered(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupEnter(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupEnter(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupEntered\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcConversationEnded(NPCTalking nPCTalking, BasePlayer player)",
    "MethodSignature": "ForceEndConversation(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void ForceEndConversation(BasePlayer player)\n\t{\n\t\tClientRPCPlayer(null, player, \u0022Client_EndConversation\u0022);\n\t\tInterface.CallHook(\u0022OnNpcConversationEnded\u0022, this, player);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnLiftUse(ProceduralLift proceduralLift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null \u0026\u0026 !IsBusy())\n\t\t{\n\t\t\tMoveToFloor((floorIndex \u002B 1) % stops.Length);\n\t\t}\n\t}\n",
    "ClassName": "ProceduralLift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntityControl(AutoTurret autoTurret)",
    "MethodSignature": "CanControl()",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapSnapped(BaseTrapTrigger baseTrapTrigger, UnityEngine.GameObject obj, UnityEngine.Collider col)",
    "MethodSignature": "OnObjectAdded(GameObject obj, Collider col)",
    "MethodSourseCode": "\n\tinternal override void OnObjectAdded(GameObject obj, Collider col)\n\t{\n\t\tInterface.CallHook(\u0022OnTrapSnapped\u0022, this, obj, col);\n\t\tbase.OnObjectAdded(obj, col);\n\t\t_trap.ObjectEntered(obj);\n\t}\n",
    "ClassName": "BaseTrapTrigger",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretDeauthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnLootItem(BasePlayer getComponent\u003CBasePlayer\u003E, Item item)",
    "MethodSignature": "StartLootingItem(Item item)",
    "MethodSourseCode": "\n\tpublic void StartLootingItem(Item item)\n\t{\n\t\tClear();\n\t\tif (item != null \u0026\u0026 item.contents != null)\n\t\t{\n\t\t\tPositionChecks = true;\n\t\t\tcontainers.Add(item.contents);\n\t\t\titem.contents.onDirty \u002B= MarkDirty;\n\t\t\titemSource = item;\n\t\t\tentitySource = item.GetWorldEntity();\n\t\t\tInterface.CallHook(\u0022OnLootItem\u0022, GetComponent\u003CBasePlayer\u003E(), item);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnWireClear(BasePlayer msgPlayer, IOEntity iOEntity, int num, IOEntity iOEntity2, bool flag)",
    "MethodSignature": "RequestClear(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server]\n\tpublic void RequestClear(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!CanPlayerUseWires(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint uid = msg.read.UInt32();\n\t\tint num = msg.read.Int32();\n\t\tbool flag = msg.read.Bit();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tIOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent\u003CIOEntity\u003E());\n\t\tif (iOEntity == null || !CanModifyEntity(player, iOEntity) || num \u003E= (flag ? iOEntity.inputs.Length : iOEntity.outputs.Length))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs[num] : iOEntity.outputs[num]);\n\t\tif (iOSlot.connectedTo.Get() == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\n\t\tif (Interface.CallHook(\u0022OnWireClear\u0022, msg.player, iOEntity, num, iOEntity2, flag) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity.IOSlot obj = (flag ? iOEntity2.outputs[iOSlot.connectedToSlot] : iOEntity2.inputs[iOSlot.connectedToSlot]);\n\t\tif (flag)\n\t\t{\n\t\t\tiOEntity.UpdateFromInput(0, num);\n\t\t}\n\t\telse if ((bool)iOEntity2)\n\t\t{\n\t\t\tiOEntity2.UpdateFromInput(0, iOSlot.connectedToSlot);\n\t\t}\n\t\tiOSlot.Clear();\n\t\tobj.Clear();\n\t\tiOEntity.MarkDirtyForceUpdateOutputs();\n\t\tiOEntity.SendNetworkUpdate();\n\t\tif (flag \u0026\u0026 iOEntity2 != null)\n\t\t{\n\t\t\tiOEntity2.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t\telse if (!flag)\n\t\t{\n\t\t\tIOEntity.IOSlot[] inputs = iOEntity.inputs;\n\t\t\tforeach (IOEntity.IOSlot iOSlot2 in inputs)\n\t\t\t{\n\t\t\t\tif (iOSlot2.mainPowerSlot \u0026\u0026 (bool)iOSlot2.connectedTo.Get())\n\t\t\t\t{\n\t\t\t\t\tiOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tiOEntity2.SendNetworkUpdate();\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (inventory != null)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnHorseLead(BaseRidableAnimal baseRidableAnimal, BasePlayer player)",
    "MethodSignature": "RPC_Lead(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Lead(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 !HasDriver() \u0026\u0026 !IsForSale())\n\t\t{\n\t\t\tbool num = IsLeading();\n\t\t\tbool flag = msg.read.Bit();\n\t\t\tif (num != flag \u0026\u0026 Interface.CallHook(\u0022OnHorseLead\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tSetLeading(flag ? player : null);\n\t\t\t\tLeadingChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRfFrequencyChange(Detonator detonator, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild() || GetOwnerPlayer() != msg.player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsOn());\n\t\t\tfrequency = num;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSignature": "RespawnAt(UnityEngine.Vector3 position, UnityEngine.Quaternion rotation)",
    "MethodSourseCode": "\n\tpublic void RespawnAt(UnityEngine.Vector3 position, UnityEngine.Quaternion rotation)\n\t{\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (!activeGameMode || activeGameMode.CanPlayerRespawn(this))\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Unused2, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Unused1, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tSetPlayerFlag(PlayerFlags.DisplaySash, b: false);\n\t\t\tServerPerformance.spawns\u002B\u002B;\n\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\tbase.transform.SetPositionAndRotation(position, rotation);\n\t\t\ttickInterpolator.Reset(position);\n\t\t\ttickHistory.Reset(position);\n\t\t\tlastTickTime = 0f;\n\t\t\tStopWounded();\n\t\t\tStopSpectating();\n\t\t\tUpdateNetworkGroup();\n\t\t\tEnablePlayerCollider();\n\t\t\tRemovePlayerRigidbody();\n\t\t\tStartSleeping();\n\t\t\tLifeStoryStart();\n\t\t\tmetabolism.Reset();\n\t\t\tif (modifiers != null)\n\t\t\t{\n\t\t\t\tmodifiers.RemoveAll();\n\t\t\t}\n\t\t\tInitializeHealth(StartHealth(), StartMaxHealth());\n\t\t\tinventory.GiveDefaultItems();\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\n\t\t\tif ((bool)activeGameMode)\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);\n\t\t\t}\n\t\t\tif (net != null)\n\t\t\t{\n\t\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerRespawned\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 41
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnPlayerChat(ulong userId, string username, string text, ConVar.Chat.ChatChannel targetChannel, BasePlayer player)",
    "MethodSignature": "sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\tplayer = null;\n\t\t}\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;\n\t\tif (userGroup == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (text.Length \u003E 128)\n\t\t{\n\t\t\ttext = text.Substring(0, 128);\n\t\t}\n\t\tif (text.Length \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (text.StartsWith(\u0022/\u0022) || text.StartsWith(\u0022\\\\\u0022))\n\t\t{\n\t\t\tInterface.CallHook(\u0022IOnPlayerCommand\u0022, player, message);\n\t\t\treturn false;\n\t\t}\n\t\ttext = text.EscapeRichText();\n\t\tobject obj = Interface.CallHook(\u0022IOnPlayerChat\u0022, userId, username, text, targetChannel, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (serverlog)\n\t\t{\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat(\u0022[\u0022, targetChannel, \u0022] \u0022, username, \u0022: \u0022), ConsoleColor.DarkGreen, text);\n\t\t\tstring text2 = player?.ToString() ?? $\u0022{username}[{userId}]\u0022;\n\t\t\tif (targetChannel == ChatChannel.Team)\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022[TEAM CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDebugEx.Log(\u0022[CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t}\n\t\t}\n\t\tbool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;\n\t\tbool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));\n\t\tstring text3 = \u0022#5af\u0022;\n\t\tif (flag)\n\t\t{\n\t\t\ttext3 = \u0022#af5\u0022;\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\ttext3 = \u0022#fa5\u0022;\n\t\t}\n\t\tstring text4 = username.EscapeRichText();\n\t\tChatEntry chatEntry = default(ChatEntry);\n\t\tchatEntry.Channel = targetChannel;\n\t\tchatEntry.Message = text;\n\t\tchatEntry.UserId = ((player != null) ? player.UserIDString : userId.ToString());\n\t\tchatEntry.Username = username;\n\t\tchatEntry.Color = text3;\n\t\tchatEntry.Time = Epoch.Current;\n\t\tChatEntry chatEntry2 = chatEntry;\n\t\tHistory.Add(chatEntry2);\n\t\tRCon.Broadcast(RCon.LogType.Chat, chatEntry2);\n\t\tswitch (targetChannel)\n\t\t{\n\t\tcase ChatChannel.Global:\n\t\t\tif (Server.globalchat)\n\t\t\t{\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, 0, userId, text, text4, text3, 1f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ChatChannel.Team:\n\t\t{\n\t\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindPlayersTeam(userId);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\n\t\t\tif (onlineMemberConnections != null)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \u0022chat.add2\u0022, 1, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tplayerTeam.BroadcastTeamChat(userId, text4, text, text3);\n\t\t\treturn true;\n\t\t}\n\t\t}\n\t\tif (player != null)\n\t\t{\n\t\t\tfloat num2 = 2500f;\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\n\t\t\t\tif (!(sqrMagnitude \u003E num2))\n\t\t\t\t{\n\t\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, 0, userId, text, text4, text3, Mathf.Clamp01(num2 - sqrMagnitude \u002B 0.2f));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, BaseRidableAnimal baseRidableAnimal)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (inventory != null)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanOpenStorage(player) \u0026\u0026 (!needsBuildingPrivilegeToUse || player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEngineStop(VehicleEngineController vehicleEngineController)",
    "MethodSignature": "StopEngine()",
    "MethodSourseCode": "\n\tpublic void StopEngine()\n\t{\n\t\tif (isServer \u0026\u0026 CurEngineState != 0 \u0026\u0026 Interface.CallHook(\u0022OnEngineStop\u0022, this) == null)\n\t\t{\n\t\t\tCancelEngineStart();\n\t\t\towner.SetFlag(BaseEntity.Flags.On, b: false);\n\t\t\towner.SetFlag(engineStartingFlag, b: false);\n\t\t\tInterface.CallHook(\u0022OnEngineStopped\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "VehicleEngineController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnActiveItemChange(BasePlayer basePlayer, Item activeItem, uint itemID)",
    "MethodSignature": "UpdateActiveItem(uint itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(uint itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = 0u;\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = 0u;\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = 0u;\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "IOnUpdateServerDescription()",
    "MethodSignature": "UpdateServerInformation()",
    "MethodSourseCode": "\n\tprivate void UpdateServerInformation()\n\t{\n\t\tif (!SteamServer.IsValid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateServerInformation\u0022))\n\t\t{\n\t\t\tSteamServer.ServerName = ConVar.Server.hostname;\n\t\t\tSteamServer.MaxPlayers = ConVar.Server.maxplayers;\n\t\t\tSteamServer.Passworded = false;\n\t\t\tSteamServer.MapName = World.Name;\n\t\t\tstring text = \u0022stok\u0022;\n\t\t\tif (Restarting)\n\t\t\t{\n\t\t\t\ttext = \u0022strst\u0022;\n\t\t\t}\n\t\t\tstring text2 = $\u0022born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\u0022;\n\t\t\tstring text3 = $\u0022gm{GamemodeName()}\u0022;\n\t\t\tstring text4 = (ConVar.Server.pve ? \u0022,pve\u0022 : string.Empty);\n\t\t\tstring text5 = ConVar.Server.tags?.Trim(\u0027,\u0027) ?? \u0022\u0022;\n\t\t\tstring text6 = ((!string.IsNullOrWhiteSpace(text5)) ? (\u0022,\u0022 \u002B text5) : \u0022\u0022);\n\t\t\tSteamServer.GameTags = $\u0022mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent\u003CServerMgr\u003E.Instance.connectionQueue.Queued},v{2283}{text4}{text6},h{AssemblyHash},{text},{text2},{text3}\u0022;\n\t\t\tInterface.CallHook(\u0022IOnUpdateServerInformation\u0022);\n\t\t\tif (ConVar.Server.description != null \u0026\u0026 ConVar.Server.description.Length \u003E 100)\n\t\t\t{\n\t\t\t\tstring[] array = ConVar.Server.description.SplitToChunks(100).ToArray();\n\t\t\t\tInterface.CallHook(\u0022IOnUpdateServerDescription\u0022);\n\t\t\t\tfor (int i = 0; i \u003C 16; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (i \u003C array.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, array[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, string.Empty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSteamServer.SetKey(\u0022description_0\u0022, ConVar.Server.description);\n\t\t\t\tfor (int j = 1; j \u003C 16; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tSteamServer.SetKey($\u0022description_{j:00}\u0022, string.Empty);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022hash\u0022, AssemblyHash);\n\t\t\tSteamServer.SetKey(\u0022world.seed\u0022, World.Seed.ToString());\n\t\t\tSteamServer.SetKey(\u0022world.size\u0022, World.Size.ToString());\n\t\t\tSteamServer.SetKey(\u0022pve\u0022, ConVar.Server.pve.ToString());\n\t\t\tSteamServer.SetKey(\u0022headerimage\u0022, ConVar.Server.headerimage);\n\t\t\tSteamServer.SetKey(\u0022logoimage\u0022, ConVar.Server.logoimage);\n\t\t\tSteamServer.SetKey(\u0022url\u0022, ConVar.Server.url);\n\t\t\tSteamServer.SetKey(\u0022gmn\u0022, GamemodeName());\n\t\t\tSteamServer.SetKey(\u0022gmt\u0022, GamemodeTitle());\n\t\t\tSteamServer.SetKey(\u0022gmd\u0022, GamemodeDesc());\n\t\t\tSteamServer.SetKey(\u0022gmu\u0022, GamemodeUrl());\n\t\t\tSteamServer.SetKey(\u0022uptime\u0022, ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_mb\u0022, Performance.report.memoryAllocations.ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_cl\u0022, Performance.report.memoryCollections.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps\u0022, Performance.report.frameRate.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps_avg\u0022, Performance.report.frameRateAverage.ToString(\u00220.00\u0022));\n\t\t\tSteamServer.SetKey(\u0022ent_cnt\u0022, BaseNetworkable.serverEntities.Count.ToString());\n\t\t\tSteamServer.SetKey(\u0022build\u0022, BuildInfo.Current.Scm.ChangeId);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnNpcGiveSoldItem(NPCVendingMachine nPCVendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic override void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\tbase.GiveSoldItem(soldItem, buyer);\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tResetRemovalTime();\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLock(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "Lock(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void Lock(BasePlayer player)\n\t{\n\t\tif (!(player == null) \u0026\u0026 player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, player, this) == null \u0026\u0026 HasLockPermission(player))\n\t\t{\n\t\t\tLockLock(player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntitySpawned(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Spawn()",
    "MethodSourseCode": "\n\tpublic virtual void Spawn()\n\t{\n\t\tSpawnShared();\n\t\tif (net == null)\n\t\t{\n\t\t\tnet = Network.Net.sv.CreateNetworkable();\n\t\t}\n\t\tcreationFrame = UnityEngine.Time.frameCount;\n\t\tPreInitShared();\n\t\tInitShared();\n\t\tServerInit();\n\t\tPostInitShared();\n\t\tUpdateNetworkGroup();\n\t\tisSpawned = true;\n\t\tInterface.CallHook(\u0022OnEntitySpawned\u0022, this);\n\t\tSendNetworkUpdateImmediate(justCreated: true);\n\t\tif (Rust.Application.isLoading \u0026\u0026 !Rust.Application.isLoadingSave)\n\t\t{\n\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnSwitchToggle(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection netConnection, string key, string val)",
    "MethodSignature": "SetInfo(string key, string val)",
    "MethodSourseCode": "\n\tpublic virtual void SetInfo(string key, string val)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, net.connection, key, val);\n\t\t\tnet.connection.info.Set(key, val);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeWounded(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "EligibleForWounding(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual bool EligibleForWounding(HitInfo info)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeWounded\u0022, this, info);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!ConVar.Server.woundingenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (isMounted)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (info == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime \u003C ConVar.Server.rewounddelay)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (info.WeaponPrefab is BaseMelee)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (info.WeaponPrefab is BaseProjectile)\n\t\t{\n\t\t\treturn !info.isHeadshot;\n\t\t}\n\t\treturn info.damageTypes.GetMajorityDamageType() switch\n\t\t{\n\t\t\tDamageType.Suicide =\u003E false, \n\t\t\tDamageType.Fall =\u003E true, \n\t\t\tDamageType.Bite =\u003E true, \n\t\t\tDamageType.Bleeding =\u003E true, \n\t\t\tDamageType.Hunger =\u003E true, \n\t\t\tDamageType.Thirst =\u003E true, \n\t\t\tDamageType.Poison =\u003E true, \n\t\t\t_ =\u003E false, \n\t\t};\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamDisbanded(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tPool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnSupplyDropLanded(SupplyDrop supplyDrop)",
    "MethodSignature": "OnCollisionEnter(Collision collision)",
    "MethodSourseCode": "\n\tprivate void OnCollisionEnter(Collision collision)\n\t{\n\t\tif (((1 \u003C\u003C collision.collider.gameObject.layer) \u0026 0x40A10111) \u003E 0)\n\t\t{\n\t\t\tRemoveParachute();\n\t\t\tMakeLootable();\n\t\t}\n\t\tInterface.CallHook(\u0022OnSupplyDropLanded\u0022, this);\n\t}\n",
    "ClassName": "SupplyDrop",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnRecycleItem(Recycler recycler, Item slot)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\n\tpublic void RecycleThink()\n\t{\n\t\tbool flag = false;\n\t\tfloat num = recycleEfficiency;\n\t\tint num2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (num2 \u003C 6)\n\t\t\t{\n\t\t\t\tItem slot = base.inventory.GetSlot(num2);\n\t\t\t\tif (slot == null)\n\t\t\t\t{\n\t\t\t\t\tgoto IL_034f;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnRecycleItem\u0022, this, slot) != null)\n\t\t\t\t{\n\t\t\t\t\tif (!HasRecyclable())\n\t\t\t\t\t{\n\t\t\t\t\t\tStopRecycling();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(slot.info.Blueprint != null))\n\t\t\t\t{\n\t\t\t\t\tgoto IL_034f;\n\t\t\t\t}\n\t\t\t\tif (slot.hasCondition)\n\t\t\t\t{\n\t\t\t\t\tnum = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\n\t\t\t\t}\n\t\t\t\tint num3 = 1;\n\t\t\t\tif (slot.amount \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tnum3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tint num4 = slot.info.Blueprint.scrapFromRecycle * num3;\n\t\t\t\t\tif (slot.info.stackable == 1 \u0026\u0026 slot.hasCondition)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);\n\t\t\t\t\t}\n\t\t\t\t\tif (num4 \u003E= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem newItem = ItemManager.CreateByName(\u0022scrap\u0022, num4, 0uL);\n\t\t\t\t\t\tMoveItemToOutput(newItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBasePlayer\u003E obj = Facepunch.Pool.GetList\u003CBasePlayer\u003E();\n\t\t\t\t\tVis.Entities(base.transform.position, 3f, obj, 131072);\n\t\t\t\t\tforeach (BasePlayer item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item.IsAlive() \u0026\u0026 !item.IsSleeping() \u0026\u0026 item.inventory.loot.entitySource == this)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);\n\t\t\t\t\t\t\titem.stats.Save();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t\t}\n\t\t\t\tslot.UseItem(num3);\n\t\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.ingredients)\n\t\t\t\t{\n\t\t\t\t\tif (ingredient.itemDef.shortname == \u0022scrap\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;\n\t\t\t\t\tint num6 = 0;\n\t\t\t\t\tif (num5 \u003C= 1f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= num5 * num)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum6\u002B\u002B;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;\n\t\t\t\t\t}\n\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);\n\t\t\t\t\tfor (int j = 0; j \u003C num7; j\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num8 = ((num6 \u003E ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);\n\t\t\t\t\t\tItem newItem2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);\n\t\t\t\t\t\tif (!MoveItemToOutput(newItem2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum6 -= num8;\n\t\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || !HasRecyclable())\n\t\t\t{\n\t\t\t\tStopRecycling();\n\t\t\t}\n\t\t\tbreak;\n\t\t\tIL_034f:\n\t\t\tnum2\u002B\u002B;\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnExperimentEnd(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnHotAirBalloonToggle(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity potentialtarget, HelicopterTurret helicopterTurret)",
    "MethodSignature": "InFiringArc(BaseCombatEntity potentialtarget)",
    "MethodSourseCode": "\n\tpublic bool InFiringArc(BaseCombatEntity potentialtarget)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeTargeted\u0022, potentialtarget, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn AngleToTarget(potentialtarget) \u003C 80f;\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchAmmo(BasePlayer ownerPlayer, BaseProjectile baseProjectile)",
    "MethodSignature": "SwitchAmmoTo(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void SwitchAmmoTo(RPCMessage msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num == primaryMagazine.ammoType.itemid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = itemDefinition.GetComponent\u003CItemModProjectile\u003E();\n\t\tif ((bool)component \u0026\u0026 component.IsAmmo(primaryMagazine.definition.ammoTypes) \u0026\u0026 Interface.CallHook(\u0022OnSwitchAmmo\u0022, ownerPlayer, this) == null)\n\t\t{\n\t\t\tif (primaryMagazine.contents \u003E 0)\n\t\t\t{\n\t\t\t\townerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));\n\t\t\t\tprimaryMagazine.contents = 0;\n\t\t\t}\n\t\t\tprimaryMagazine.ammoType = itemDefinition;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItemManager.DoRemoves();\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnItemCraftCancelled(ItemCraftTask itemCraftTask)",
    "MethodSignature": "CancelTask(int iID, bool ReturnItems)",
    "MethodSourseCode": "\n\tpublic bool CancelTask(int iID, bool ReturnItems)\n\t{\n\t\tif (queue.Count == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) =\u003E x.taskUID == iID \u0026\u0026 !x.cancelled);\n\t\tif (itemCraftTask == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemCraftTask.cancelled = true;\n\t\tif (itemCraftTask.owner == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemCraftCancelled\u0022, itemCraftTask);\n\t\titemCraftTask.owner.Command(\u0022note.craft_done\u0022, itemCraftTask.taskUID, 0);\n\t\tif (itemCraftTask.takenItems != null \u0026\u0026 itemCraftTask.takenItems.Count \u003E 0 \u0026\u0026 ReturnItems)\n\t\t{\n\t\t\tforeach (Item takenItem in itemCraftTask.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem != null \u0026\u0026 takenItem.amount \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tif (takenItem.IsBlueprint() \u0026\u0026 takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.UseItem(itemCraftTask.numCrafted);\n\t\t\t\t\t}\n\t\t\t\t\tif (takenItem.amount \u003E 0 \u0026\u0026 !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition \u002B UnityEngine.Random.value * Vector3.down \u002B UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);\n\t\t\t\t\t\titemCraftTask.owner.Command(\u0022note.inv\u0022, takenItem.info.itemid, -takenItem.amount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnEntityEnter(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tif (!(ent == null))\n\t\t{\n\t\t\tif (entityContents == null)\n\t\t\t{\n\t\t\t\tentityContents = new HashSet\u003CBaseEntity\u003E();\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t\t{\n\t\t\t\tentityContents.Add(ent);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnMaxStackable(Item item)",
    "MethodSignature": "MaxStackable()",
    "MethodSourseCode": "\n\tpublic int MaxStackable()\n\t{\n\t\tint num = info.stackable;\n\t\tif (parent != null \u0026\u0026 parent.maxStackSize \u003E 0)\n\t\t{\n\t\t\tnum = Mathf.Min(parent.maxStackSize, num);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnMaxStackable\u0022, this);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEngineStart(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer rpcPlayer, int num, int num2)",
    "MethodSignature": "BuyItem(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void BuyItem(RPCMessage rpc)\n\t{\n\t\tif (OccupiedCheck(rpc.player))\n\t\t{\n\t\t\tint num = rpc.read.Int32();\n\t\t\tint num2 = rpc.read.Int32();\n\t\t\tif (IsVending())\n\t\t\t{\n\t\t\t\trpc.player.ShowToast(1, WaitForVendingMessage);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnBuyVendingItem\u0022, this, rpc.player, num, num2) == null)\n\t\t\t{\n\t\t\t\tSetPendingOrder(rpc.player, num, num2);\n\t\t\t\tInvoke(CompletePendingOrder, GetBuyDuration());\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\tplayer.ShowToast(1, LockedMessage);\n\t\t\treturn false;\n\t\t}\n\t\tif (onlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ShowToast(1, InUseMessage);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = panelName;\n\t\t}\n\t\tif (!CanOpenLootPanel(player, panelToOpen))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tAddContainers(player.inventory.loot);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, panelToOpen);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFlameExplosion(FlameExplosive flameExplosive, BaseEntity baseEntity)",
    "MethodSignature": "Explode(Vector3 surfaceNormal)",
    "MethodSourseCode": "\n\tpublic void Explode(Vector3 surfaceNormal)\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; (float)i \u003C numToCreate; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, base.transform.position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, surfaceNormal);\n\t\t\t\tbaseEntity.transform.SetPositionAndRotation(base.transform.position, Quaternion.LookRotation(modifiedAimConeDirection));\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tInterface.CallHook(\u0022OnFlameExplosion\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(minVelocity, maxVelocity));\n\t\t\t}\n\t\t}\n\t\tbase.Explode();\n\t}\n",
    "ClassName": "FlameExplosive",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanHelicopterStrafe(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanStrafe()",
    "MethodSourseCode": "\n\tpublic bool CanStrafe()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafe\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime \u003E= 20f)\n\t\t{\n\t\t\treturn CanInterruptState();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcTarget(BaseEntity npcBody, BasePlayer infoPlayer)",
    "MethodSignature": "RememberEnemyPlayer(IHTNAgent npc, NpcPlayerInfo info, float time, float uncertainty, string debugStr)",
    "MethodSourseCode": "\n\tpublic void RememberEnemyPlayer(IHTNAgent npc, ref NpcPlayerInfo info, float time, float uncertainty = 0f, string debugStr = \u0022ENEMY!\u0022)\n\t{\n\t\tif (info.Player == null || info.Player.transform == null || info.Player.IsDestroyed || info.Player.IsDead() || info.Player.IsWounded() || Interface.CallHook(\u0022OnNpcTarget\u0022, npc.Body, info.Player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (Mathf.Approximately(info.SqrDistance, 0f))\n\t\t{\n\t\t\tinfo.SqrDistance = (npc.BodyPosition - info.Player.transform.position).sqrMagnitude;\n\t\t}\n\t\tfor (int i = 0; i \u003C KnownEnemyPlayers.Count; i\u002B\u002B)\n\t\t{\n\t\t\tEnemyPlayerInfo enemyPlayerInfo = KnownEnemyPlayers[i];\n\t\t\tif (enemyPlayerInfo.PlayerInfo.Player == info.Player)\n\t\t\t{\n\t\t\t\tenemyPlayerInfo.PlayerInfo = info;\n\t\t\t\tif (uncertainty \u003C 0.05f)\n\t\t\t\t{\n\t\t\t\t\tenemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition;\n\t\t\t\t\tenemyPlayerInfo.LastKnownLocalHeading = info.Player.GetLocalVelocity().normalized;\n\t\t\t\t\tenemyPlayerInfo.OurLastLocalPositionWhenLastSeen = npc.transform.localPosition;\n\t\t\t\t\tenemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;\n\t\t\t\t\tenemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVector2 vector = UnityEngine.Random.insideUnitCircle * uncertainty;\n\t\t\t\t\tenemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition \u002B new Vector3(vector.x, 0f, vector.y);\n\t\t\t\t\tenemyPlayerInfo.LastKnownLocalHeading = (enemyPlayerInfo.LastKnownPosition - NpcContext.BodyPosition).normalized;\n\t\t\t\t\tenemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;\n\t\t\t\t\tenemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;\n\t\t\t\t}\n\t\t\t\tenemyPlayerInfo.Time = time;\n\t\t\t\tKnownEnemyPlayers[i] = enemyPlayerInfo;\n\t\t\t\tif (PrimaryKnownEnemyPlayer.PlayerInfo.Player == info.Player)\n\t\t\t\t{\n\t\t\t\t\tPrimaryKnownEnemyPlayer = enemyPlayerInfo;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tKnownEnemyPlayers.Add(new EnemyPlayerInfo\n\t\t{\n\t\t\tPlayerInfo = info,\n\t\t\tLastKnownLocalPosition = info.Player.transform.localPosition,\n\t\t\tTime = time\n\t\t});\n\t}\n",
    "ClassName": "BaseNpcMemory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSupplyDropDropped(BaseEntity baseEntity, CargoPlane cargoPlane)",
    "MethodSignature": "Update()",
    "MethodSourseCode": "\n\tprivate void Update()\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsecondsTaken \u002B= Time.deltaTime;\n\t\tfloat num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\n\t\tif (!dropped \u0026\u0026 num \u003E= 0.5f)\n\t\t{\n\t\t\tdropped = true;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.globalBroadcast = true;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tInterface.CallHook(\u0022OnSupplyDropDropped\u0022, baseEntity, this);\n\t\t\t}\n\t\t}\n\t\tbase.transform.position = Vector3.Lerp(startPos, endPos, num);\n\t\tbase.transform.hasChanged = true;\n\t\tif (num \u003E= 1f)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnCrateHackEnd(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "HackProgress()",
    "MethodSourseCode": "\n\tpublic void HackProgress()\n\t{\n\t\thackSeconds \u002B= 1f;\n\t\tif (hackSeconds \u003E requiredHackSeconds)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateHackEnd\u0022, this);\n\t\t\tRefreshDecay();\n\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\tisLootable = true;\n\t\t\tCancelInvoke(HackProgress);\n\t\t}\n\t\tClientRPC(null, \u0022UpdateHackProgress\u0022, (int)hackSeconds, (int)requiredHackSeconds);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer player, BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "CanPickup(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPickup(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (pickup.enabled)\n\t\t{\n\t\t\tif (!pickup.requireBuildingPrivilege || player.CanBuild())\n\t\t\t{\n\t\t\t\tif (pickup.requireHammer)\n\t\t\t\t{\n\t\t\t\t\treturn player.IsHoldingEntity\u003CHammer\u003E();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAcceptItem(ItemContainer itemContainer, Item item, int targetPos)",
    "MethodSignature": "CanAcceptItem(Item item, int targetPos)",
    "MethodSourseCode": "\n\tpublic CanAcceptResult CanAcceptItem(Item item, int targetPos)\n\t{\n\t\tif (canAcceptItem != null \u0026\u0026 !canAcceptItem(item, targetPos))\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif ((allowedContents \u0026 item.info.itemType) != item.info.itemType)\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (onlyAllowedItem != null \u0026\u0026 onlyAllowedItem != item.info)\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (availableSlots != null \u0026\u0026 availableSlots.Count \u003E 0)\n\t\t{\n\t\t\tif (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t\tint[] array = new int[32];\n\t\t\tforeach (ItemSlot availableSlot in availableSlots)\n\t\t\t{\n\t\t\t\tarray[(int)Mathf.Log((float)availableSlot, 2f)]\u002B\u002B;\n\t\t\t}\n\t\t\tforeach (Item item2 in itemList)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C 32; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (((uint)item2.info.occupySlots \u0026 (uint)(1 \u003C\u003C i)) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tarray[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j \u003C 32; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (((uint)item.info.occupySlots \u0026 (uint)(1 \u003C\u003C j)) != 0 \u0026\u0026 array[j] \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\treturn CanAcceptResult.CannotAcceptRightNow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAcceptItem\u0022, this, item, targetPos);\n\t\tif (obj is CanAcceptResult)\n\t\t{\n\t\t\treturn (CanAcceptResult)obj;\n\t\t}\n\t\treturn CanAcceptResult.CanAccept;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "CanPickupLock(BasePlayer rpcPlayer, BaseLock baseLock)",
    "MethodSignature": "RPC_TakeLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tpublic void RPC_TakeLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanPickupLock\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "BaseLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerAssist(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Assist(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void RPC_Assist(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerAssist\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tStopWounded(msg.player);\n\t\t\tmsg.player.stats.Add(\u0022wounded_assisted\u0022, 1, (Stats)5);\n\t\t\tstats.Add(\u0022wounded_healed\u0022, 1);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnCupboardClearList(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void ClearList(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcConversationResponded(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode != null \u0026\u0026 Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) == null)\n\t\t{\n\t\t\tif (responseNode.conditions.Length != 0)\n\t\t\t{\n\t\t\t\tUpdateFlags();\n\t\t\t}\n\t\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\t\tif (flag \u0026\u0026 !string.IsNullOrEmpty(responseNode.actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, responseNode.actionString);\n\t\t\t}\n\t\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\t\tif (speechNodeIndex == -1)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tForceSpeechNode(player, speechNodeIndex);\n\t\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "CanMoveItem(Item item, PlayerInventory playerInventory, uint num2, int num3, int num4)",
    "MethodSignature": "MoveItem(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server]\n\t[BaseEntity.RPC_Server.FromOwner]\n\tprivate void MoveItem(BaseEntity.RPCMessage msg)\n\t{\n\t\tuint num = msg.read.UInt32();\n\t\tuint num2 = msg.read.UInt32();\n\t\tint num3 = msg.read.Int8();\n\t\tint num4 = (int)msg.read.UInt32();\n\t\tItem item = FindItemUID(num);\n\t\tif (item == null)\n\t\t{\n\t\t\tmsg.player.ChatMessage(\u0022Invalid item (\u0022 \u002B num \u002B \u0022)\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022CanMoveItem\u0022, item, this, num2, num3, num4) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!CanMoveItemsFrom(item.parent.entityOwner, item))\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Cannot move item!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (num4 \u003C= 0)\n\t\t\t{\n\t\t\t\tnum4 = item.amount;\n\t\t\t}\n\t\t\tnum4 = Mathf.Clamp(num4, 1, item.MaxStackable());\n\t\t\tif (msg.player.GetActiveItem() == item)\n\t\t\t{\n\t\t\t\tmsg.player.UpdateActiveItem(0u);\n\t\t\t}\n\t\t\tif (num2 == 0)\n\t\t\t{\n\t\t\t\tif (!GiveItem(item))\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022GiveItem failed!\u0022);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemContainer itemContainer = FindContainer(num2);\n\t\t\tif (itemContainer == null)\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Invalid container (\u0022 \u002B num2 \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemContainer parent = item.parent;\n\t\t\tif ((parent != null \u0026\u0026 parent.IsLocked()) || itemContainer.IsLocked())\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Container is locked!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.PlayerItemInputBlocked())\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Container does not accept player items!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022Split\u0022))\n\t\t\t{\n\t\t\t\tif (item.amount \u003E num4)\n\t\t\t\t{\n\t\t\t\t\tint split_Amount = num4;\n\t\t\t\t\tif (itemContainer.maxStackSize \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsplit_Amount = Mathf.Min(num4, itemContainer.maxStackSize);\n\t\t\t\t\t}\n\t\t\t\t\tItem item2 = item.SplitItem(split_Amount);\n\t\t\t\t\tif (!item2.MoveToContainer(itemContainer, num3))\n\t\t\t\t\t{\n\t\t\t\t\t\titem.amount \u002B= item2.amount;\n\t\t\t\t\t\titem2.Remove();\n\t\t\t\t\t}\n\t\t\t\t\tItemManager.DoRemoves();\n\t\t\t\t\tServerUpdate(0f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.MoveToContainer(itemContainer, num3))\n\t\t\t{\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, BaseEntity baseEntity, BaseEntity baseEntity2)",
    "MethodSignature": "DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at player position!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;\n\t\tif (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ownerPlayer.Distance(baseEntity) \u003E 3f)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Too far away!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at placement position!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);\n\t\tif (baseEntity2 != null)\n\t\t{\n\t\t\tbaseEntity2.skinID = ownerItem.skin;\n\t\t\tbaseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));\n\t\t\tbaseEntity2.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity2.OnDeployed(baseEntity, ownerPlayer);\n\t\t\tbaseEntity2.Spawn();\n\t\t\tbaseEntity.SetSlot(deployable.slot, baseEntity2);\n\t\t\tif (deployable.placeEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\n\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, baseEntity, baseEntity2);\n\t\tUseItemAmount(1);\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 49
  },
  {
    "HookSignature": "OnCrateDropped(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "SetWasDropped()",
    "MethodSourseCode": "\n\tpublic void SetWasDropped()\n\t{\n\t\twasDropped = true;\n\t\tInterface.CallHook(\u0022OnCrateDropped\u0022, this);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "IOnServerUsersSet(ulong uid, ServerUsers.UserGroup group, string username, string notes, long expiry)",
    "MethodSignature": "Set(ulong uid, UserGroup group, string username, string notes, long expiry)",
    "MethodSourseCode": "\n\tpublic static void Set(ulong uid, UserGroup group, string username, string notes, long expiry = -1L)\n\t{\n\t\tRemove(uid);\n\t\tUser value = new User\n\t\t{\n\t\t\tsteamid = uid,\n\t\t\tgroup = group,\n\t\t\tusername = username,\n\t\t\tnotes = notes,\n\t\t\texpiry = expiry\n\t\t};\n\t\tInterface.CallHook(\u0022IOnServerUsersSet\u0022, uid, group, username, notes, expiry);\n\t\tusers.Add(uid, value);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnClientAuth(Network.Connection packetConnection)",
    "MethodSignature": "OnGiveUserInformation(Message packet)",
    "MethodSourseCode": "\n\tprivate void OnGiveUserInformation(Message packet)\n\t{\n\t\tif (packet.connection.state != 0)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.state = Network.Connection.State.Connecting;\n\t\tif (packet.read.UInt8() != 228)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Connection Protocol\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.userid = packet.read.UInt64();\n\t\tpacket.connection.protocol = packet.read.UInt32();\n\t\tpacket.connection.os = packet.read.String(128);\n\t\tpacket.connection.username = packet.read.String();\n\t\tif (string.IsNullOrEmpty(packet.connection.os))\n\t\t{\n\t\t\tthrow new Exception(\u0022Invalid OS\u0022);\n\t\t}\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.username = packet.connection.username.Replace(\u0027\\n\u0027, \u0027 \u0027).Replace(\u0027\\r\u0027, \u0027 \u0027).Replace(\u0027\\t\u0027, \u0027 \u0027)\n\t\t\t.Trim();\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring text = string.Empty;\n\t\tstring branch = ConVar.Server.branch;\n\t\tif (packet.read.Unread \u003E= 4)\n\t\t{\n\t\t\ttext = packet.read.String(128);\n\t\t}\n\t\tInterface.CallHook(\u0022OnClientAuth\u0022, packet.connection);\n\t\tif (branch != string.Empty \u0026\u0026 branch != text)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their branch is \u0027\u0022, text, \u0022\u0027 not \u0027\u0022, branch, \u0022\u0027\u0022));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Steam Beta: Requires \u0027\u0022 \u002B branch \u002B \u0022\u0027 branch!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003E 2283)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2283));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Server update required!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003C 2283)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2283));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Client update required!\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpacket.connection.token = packet.read.BytesWithSize(512u);\n\t\t\tif (packet.connection.token == null || packet.connection.token.Length \u003C 1)\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Token\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauth.OnNewConnection(packet.connection);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "IOnNpcTarget(Rust.Ai.HTN.IHTNAgent npc, BasePlayer player2Player, int k)",
    "MethodSignature": "Tick(IHTNAgent npc, float deltaTime, float time)",
    "MethodSourseCode": "\n\tpublic void Tick(IHTNAgent npc, float deltaTime, float time)\n\t{\n\t\tif (ConVar.AI.ignoreplayers || npc == null || npc.transform == null || npc.IsDestroyed || npc.AiDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerQueryResultCount = BaseEntity.Query.Server.GetPlayersInSphere(npc.transform.position, npc.AiDefinition.Sensory.VisionRange, PlayerQueryResults, delegate(BasePlayer player)\n\t\t{\n\t\t\tif (player == null || !player.isServer || player.IsDestroyed || player.transform == null || player.IsDead() || player.IsWounded())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (!player.IsSleeping() || !(player.secondsSleeping \u003C NPCAutoTurret.sleeperhostiledelay)) ? true : false;\n\t\t});\n\t\tList\u003CNpcPlayerInfo\u003E playersInRange = npc.AiDomain.NpcContext.PlayersInRange;\n\t\tif (PlayerQueryResultCount \u003E 0)\n\t\t{\n\t\t\tfor (int i = 0; i \u003C PlayerQueryResultCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer = PlayerQueryResults[i];\n\t\t\t\tHTNPlayer hTNPlayer = npc as HTNPlayer;\n\t\t\t\tif ((hTNPlayer != null \u0026\u0026 basePlayer == hTNPlayer) || (basePlayer.transform.position - npc.transform.position).sqrMagnitude \u003E npc.AiDefinition.Sensory.SqrVisionRange)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 0; j \u003C playersInRange.Count; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tNpcPlayerInfo value = playersInRange[j];\n\t\t\t\t\tif (value.Player == basePlayer)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.Time = time;\n\t\t\t\t\t\tplayersInRange[j] = value;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag)\n\t\t\t\t{\n\t\t\t\t\tplayersInRange.Add(new NpcPlayerInfo\n\t\t\t\t\t{\n\t\t\t\t\t\tPlayer = basePlayer,\n\t\t\t\t\t\tTime = time\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k \u003C playersInRange.Count; k\u002B\u002B)\n\t\t{\n\t\t\tNpcPlayerInfo player2 = playersInRange[k];\n\t\t\tif (Interface.CallHook(\u0022IOnNpcTarget\u0022, npc, player2.Player, k) != null)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (time - player2.Time \u003E npc.AiDefinition.Memory.ForgetInRangeTime \u0026\u0026 npc.AiDomain.NpcContext.BaseMemory.ShouldRemoveOnPlayerForgetTimeout(time, player2))\n\t\t\t{\n\t\t\t\tplayersInRange.RemoveAt(k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayersInRangeSensor",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnOutputUpdate(IOEntity iOEntity)",
    "MethodSignature": "UpdateOutputs()",
    "MethodSourseCode": "\n\tpublic virtual void UpdateOutputs()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOutputUpdate\u0022, this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tensureOutputsUpdated = false;\n\t\tusing (TimeWarning.New(\u0022ProcessIOOutputs\u0022))\n\t\t{\n\t\t\tfor (int i = 0; i \u003C outputs.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tIOSlot iOSlot = outputs[i];\n\t\t\t\tbool flag = true;\n\t\t\t\tIOEntity iOEntity = iOSlot.connectedTo.Get();\n\t\t\t\tif (!(iOEntity != null))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ioType == IOType.Fluidic \u0026\u0026 !DisregardGravityRestrictionsOnLiquid \u0026\u0026 !iOEntity.DisregardGravityRestrictionsOnLiquid)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022FluidOutputProcessing\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint passthroughAmount = GetPassthroughAmount(i);\n\t\t\t\tiOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBonusItemDropped(Item item, BasePlayer basePlayer)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer) == null)\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity());\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnItemAction(Item item, string text, BasePlayer msgPlayer)",
    "MethodSignature": "ItemCmd(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server.FromOwner]\n\t[BaseEntity.RPC_Server]\n\tprivate void ItemCmd(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (msg.player != null \u0026\u0026 msg.player.IsWounded())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint id = msg.read.UInt32();\n\t\tstring text = msg.read.String();\n\t\tItem item = FindItemUID(id);\n\t\tif (item == null || Interface.CallHook(\u0022OnItemAction\u0022, item, text, msg.player) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (text == \u0022drop\u0022)\n\t\t{\n\t\t\tint num = item.amount;\n\t\t\tif (msg.read.Unread \u003E= 4)\n\t\t\t{\n\t\t\t\tnum = msg.read.Int32();\n\t\t\t}\n\t\t\tbase.baseEntity.stats.Add(\u0022item_drop\u0022, 1, (Stats)5);\n\t\t\tif (num \u003C item.amount)\n\t\t\t{\n\t\t\t\titem.SplitItem(num)?.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t}\n\t\t\tbase.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, \u0022drop_item\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.ServerCommand(text, base.baseEntity);\n\t\t\tItemManager.DoRemoves();\n\t\t\tServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnOvenToggle(BaseOven baseOven, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnOvenToggle\u0022, this, msg.player) == null \u0026\u0026 flag != IsOn() \u0026\u0026 (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tStartCooking();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStopCooking();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\tbuyer.GiveItem(soldItem, GiveItemReason.PickedUp);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerReported(BasePlayer basePlayer, string text5, string text4, string text, string text2, string text3)",
    "MethodSignature": "OnPlayerReported(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void OnPlayerReported(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tstring text2 = msg.read.StringMultiLine();\n\t\tstring text3 = msg.read.String();\n\t\tstring text4 = msg.read.String();\n\t\tstring text5 = msg.read.String();\n\t\tDebugEx.Log($\u0022[PlayerReport] {this} reported {text5}[{text4}] - \\\u0022{text}\\\u0022\u0022);\n\t\tRCon.Broadcast(RCon.LogType.Report, new\n\t\t{\n\t\t\tPlayerId = UserIDString,\n\t\t\tPlayerName = displayName,\n\t\t\tTargetId = text4,\n\t\t\tTargetName = text5,\n\t\t\tSubject = text,\n\t\t\tMessage = text2,\n\t\t\tType = text3\n\t\t});\n\t\tInterface.CallHook(\u0022OnPlayerReported\u0022, this, text5, text4, text, text2, text3);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnVehicleModuleMove(BaseVehicleModule moduleForItem, BaseModularVehicle baseModularVehicle, BasePlayer player)",
    "MethodSignature": "CanMoveFrom(BasePlayer player, Item item)",
    "MethodSourseCode": "\n\tpublic bool CanMoveFrom(BasePlayer player, Item item)\n\t{\n\t\tBaseVehicleModule moduleForItem = GetModuleForItem(item);\n\t\tif (moduleForItem != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnVehicleModuleMove\u0022, moduleForItem, this, player);\n\t\t\tif (obj != null)\n\t\t\t{\n\t\t\t\tif (!(obj is bool))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\treturn moduleForItem.CanBeMovedNow();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseModularVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFindSpawnPoint(BasePlayer forPlayer)",
    "MethodSignature": "FindSpawnPoint(BasePlayer forPlayer)",
    "MethodSourseCode": "\n\tpublic static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindSpawnPoint\u0022, forPlayer);\n\t\tif (obj is BasePlayer.SpawnPoint)\n\t\t{\n\t\t\treturn (BasePlayer.SpawnPoint)obj;\n\t\t}\n\t\tbool flag = false;\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif ((bool)activeGameMode \u0026\u0026 activeGameMode.useCustomSpawns)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint playerSpawn = activeGameMode.GetPlayerSpawn(forPlayer);\n\t\t\tif (playerSpawn != null)\n\t\t\t{\n\t\t\t\treturn playerSpawn;\n\t\t\t}\n\t\t}\n\t\tif (SingletonComponent\u003CSpawnHandler\u003E.Instance != null \u0026\u0026 !flag)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint spawnPoint = SpawnHandler.GetSpawnPoint();\n\t\t\tif (spawnPoint != null)\n\t\t\t{\n\t\t\t\treturn spawnPoint;\n\t\t\t}\n\t\t}\n\t\tBasePlayer.SpawnPoint spawnPoint2 = new BasePlayer.SpawnPoint();\n\t\tGameObject[] array = GameObject.FindGameObjectsWithTag(\u0022spawnpoint\u0022);\n\t\tif (array.Length != 0)\n\t\t{\n\t\t\tGameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];\n\t\t\tspawnPoint2.pos = gameObject.transform.position;\n\t\t\tspawnPoint2.rot = gameObject.transform.rotation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUnityEngine.Debug.Log(\u0022Couldn\u0027t find an appropriate spawnpoint for the player - so spawning at camera\u0022);\n\t\t\tif (MainCamera.mainCamera != null)\n\t\t\t{\n\t\t\t\tspawnPoint2.pos = MainCamera.position;\n\t\t\t\tspawnPoint2.rot = MainCamera.rotation;\n\t\t\t}\n\t\t}\n\t\tif (UnityEngine.Physics.Raycast(new Ray(spawnPoint2.pos, Vector3.down), out var hitInfo, 32f, 1537286401))\n\t\t{\n\t\t\tspawnPoint2.pos = hitInfo.point;\n\t\t}\n\t\treturn spawnPoint2;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemUnlock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnButtonPress(PressButton pressButton, BasePlayer msgPlayer)",
    "MethodSignature": "Press(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void Press(RPCMessage msg)\n\t{\n\t\tif (!IsOn() \u0026\u0026 Interface.CallHook(\u0022OnButtonPress\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInvoke(UnpowerTime, pressPowerTime);\n\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tMarkDirty();\n\t\t\tInvoke(Unpress, pressDuration);\n\t\t}\n\t}\n",
    "ClassName": "PressButton",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnHelicopterAttacked(CH47HelicopterAIController cH47HelicopterAIController, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterAttacked\u0022, this, info) == null)\n\t\t{\n\t\t\tbase.OnAttacked(info);\n\t\t\tInitiateAnger();\n\t\t\tSetFlag(Flags.Reserved7, base.healthFraction \u003C= 0.8f);\n\t\t\tSetFlag(Flags.OnFire, base.healthFraction \u003C= 0.33f);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanReceiveCall(PhoneController phoneController)",
    "MethodSignature": "CanReceiveCall()",
    "MethodSourseCode": "\n\tprivate bool CanReceiveCall()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanReceiveCall\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (RequirePower \u0026\u0026 !IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (RequireParent \u0026\u0026 !base.baseEntity.HasParent())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnServerShutdown()",
    "MethodSignature": "Shutdown()",
    "MethodSourseCode": "\n\tinternal void Shutdown()\n\t{\n\t\tInterface.CallHook(\u0022IOnServerShutdown\u0022);\n\t\tBasePlayer[] array = BasePlayer.activePlayerList.ToArray();\n\t\tfor (int i = 0; i \u003C array.Length; i\u002B\u002B)\n\t\t{\n\t\t\tarray[i].Kick(\u0022Server Shutting Down\u0022);\n\t\t}\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.save\u0022);\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.writecfg\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnPlayerBanned(Network.Connection connection, AuthResponse Status)",
    "MethodSignature": "OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)",
    "MethodSourseCode": "\n\tinternal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)\n\t{\n\t\tif (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) =\u003E x.userid == SteamId);\n\t\tif (connection == null)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022Steam gave us a {Status} ticket response for unconnected id {SteamId}\u0022);\n\t\t\treturn;\n\t\t}\n\t\tswitch (Status)\n\t\t{\n\t\tcase AuthResponse.OK:\n\t\t\tUnityEngine.Debug.LogWarning($\u0022Steam gave us a \u0027ok\u0027 ticket response for already connected id {SteamId}\u0022);\n\t\t\treturn;\n\t\tcase AuthResponse.TimedOut:\n\t\t\treturn;\n\t\tcase AuthResponse.VACBanned:\n\t\tcase AuthResponse.PublisherBanned:\n\t\t\tif (!bannedPlayerNotices.Contains(SteamId))\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022IOnPlayerBanned\u0022, connection, Status);\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username.EscapeRichText() \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\tbannedPlayerNotices.Add(SteamId);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tUnityEngine.Debug.Log($\u0022Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \\\u0022{Status.ToString()}\\\u0022)\u0022);\n\t\tconnection.authStatus = Status.ToString();\n\t\tNetwork.Net.sv.Kick(connection, \u0022Steam: \u0022 \u002B Status);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer, bool true)",
    "MethodSignature": "DoImmediateDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server]\n\tprivate void DoImmediateDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 msg.player.IsAdmin \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, true) == null)\n\t\t{\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUseMailbox(BasePlayer player, Mailbox mailbox)",
    "MethodSignature": "PlayerIsOwner(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerIsOwner(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseMailbox\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn player.CanBuild();\n\t}\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHotAirBalloonToggled(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade)",
    "MethodSignature": "CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanChangeGrade\u0022, player, this, iGrade);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (HasUpgradePrivilege(iGrade, player))\n\t\t{\n\t\t\treturn !IsUpgradeBlocked();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCorpsePopulate(NPCMurderer nPCMurderer, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(\u0022assets/prefabs/npc/murderer/murderer_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tfor (int i = 0; i \u003C inventory.containerWear.itemList.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = inventory.containerWear.itemList[i];\n\t\t\t\t\tif (item != null \u0026\u0026 item.info.shortname == \u0022gloweyes\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tinventory.containerWear.Remove(item);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = base.displayName;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int j = 0; j \u003C containers.Length; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[j].Clear();\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlots.Length; j\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[j];\n\t\t\t\t\t\tfor (int k = 0; k \u003C lootSpawnSlot.numberToSpawn; k\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "NPCMurderer",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "CanCombineDroppedItem(DroppedItem droppedItem, DroppedItem di)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\n\tpublic void OnDroppedOn(DroppedItem di)\n\t{\n\t\tif (item == null || di.item == null || Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) != null || item.info.stackable \u003C= 1 || di.item.info != item.info || (di.item.IsBlueprint() \u0026\u0026 di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition \u0026\u0026 di.item.condition != di.item.maxCondition) || (item.hasCondition \u0026\u0026 item.condition != item.maxCondition))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (di.item.info != null \u0026\u0026 di.item.info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t{\n\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\n\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\tif (num != num2)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint num3 = di.item.amount \u002B item.amount;\n\t\tif (num3 \u003C= item.info.stackable \u0026\u0026 num3 != 0)\n\t\t{\n\t\t\tdi.DestroyItem();\n\t\t\tdi.Kill();\n\t\t\titem.amount = num3;\n\t\t\titem.MarkDirty();\n\t\t\tif (GetDespawnDuration() \u003C float.PositiveInfinity)\n\t\t\t{\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\n\t\t\t}\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "OnApplicationQuit()",
    "MethodSourseCode": "\n\tprivate void OnApplicationQuit()\n\t{\n\t\tif (!oxideMod.IsShuttingDown)\n\t\t{\n\t\t\tInterface.Call(\u0022OnServerShutdown\u0022);\n\t\t\tInterface.Oxide.OnShutdown();\n\t\t}\n\t}\n",
    "ClassName": "UnityScript",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnServerInitialized(bool false)",
    "MethodSignature": "OnPluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPluginLoaded\u0022)]\n\tprivate void OnPluginLoaded(Plugin plugin)\n\t{\n\t\tif (serverInitialized)\n\t\t{\n\t\t\tplugin.CallHook(\u0022OnServerInitialized\u0022, false);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserApprove(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBaseCombatEntityHurt\u0022)]\n\tprivate object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)\n\t{\n\t\tif (!(entity is BasePlayer))\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnEntityTakeDamage\u0022, entity, hitInfo);\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawn(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawn\u0022)]\n\tprivate object OnPlayerRespawn(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn Interface.CallHook(\u0022OnUserRespawn\u0022, iPlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string status)",
    "MethodSignature": "IOnPlayerBanned(Connection connection, AuthResponse status)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerBanned\u0022)]\n\tprivate void IOnPlayerBanned(Connection connection, AuthResponse status)\n\t{\n\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, connection, status.ToString());\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer basePlayer, DoorCloser entity)",
    "MethodSignature": "ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022ICanPickupEntity\u0022)]\n\tprivate object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, basePlayer, entity);\n\t\tif (!(obj is bool) || (bool)obj)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string message)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnNpcTarget(BaseEntity npcBody, BasePlayer target)",
    "MethodSignature": "IOnNpcTarget(IHTNAgent npc, BasePlayer target, int index)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(IHTNAgent npc, BasePlayer target, int index)\n\t{\n\t\tif (npc != null \u0026\u0026 Interface.CallHook(\u0022OnNpcTarget\u0022, npc.Body, target) != null)\n\t\t{\n\t\t\tnpc.AiDomain.NpcContext.PlayersInRange.RemoveAt(index);\n\t\t\tnpc.AiDomain.NpcContext.BaseMemory.Forget(0f);\n\t\t\tnpc.AiDomain.NpcContext.BaseMemory.PrimaryKnownEnemyPlayer.PlayerInfo.Player = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\tif (((obj == null) ? obj2 : obj) == null \u0026\u0026 !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanUserLogin(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(BasePlayer basePlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnLoseCondition(object[] array)",
    "MethodSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnLoseCondition\u0022)]\n\tprivate object IOnLoseCondition(Item item, float amount)\n\t{\n\t\tobject[] array = new object[2] { item, amount };\n\t\tInterface.CallHook(\u0022OnLoseCondition\u0022, array);\n\t\tamount = (float)array[1];\n\t\tfloat condition = item.condition;\n\t\titem.condition -= amount;\n\t\tif (item.condition \u003C= 0f \u0026\u0026 item.condition \u003C condition)\n\t\t{\n\t\t\titem.OnBroken();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnServerInitialized(bool serverInitialized)",
    "MethodSignature": "IOnServerInitialized()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerInitialized\u0022)]\n\tprivate void IOnServerInitialized()\n\t{\n\t\tif (!serverInitialized)\n\t\t{\n\t\t\tAnalytics.Collect();\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tInterface.Oxide.LogWarning(\u0022The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section\u0022);\n\t\t\t}\n\t\t\tserverInitialized = true;\n\t\t\tInterface.CallHook(\u0022OnServerInitialized\u0022, serverInitialized);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPAddress ipAddress, string obj, string[] obj2)",
    "MethodSignature": "IOnRconCommand(IPAddress ipAddress, string command)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnRconCommand\u0022)]\n\tprivate object IOnRconCommand(IPAddress ipAddress, string command)\n\t{\n\t\tif (ipAddress != null \u0026\u0026 !string.IsNullOrEmpty(command))\n\t\t{\n\t\t\tRemoteMessage message = RemoteMessage.GetMessage(command);\n\t\t\tif (string.IsNullOrEmpty(message?.Message))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tstring[] array = Oxide.Core.CommandLine.Split(message.Message);\n\t\t\tif (array.Length \u003E= 1)\n\t\t\t{\n\t\t\t\tstring obj = array[0].ToLower();\n\t\t\t\tstring[] obj2 = array.Skip(1).ToArray();\n\t\t\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, ipAddress, obj, obj2) != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnEntitySaved\u0022)]\n\tprivate void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)\n\t{\n\t\tif (serverInitialized \u0026\u0026 saveInfo.forConnection != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnEntitySaved\u0022, baseNetworkable, saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPlayerCommand(BasePlayer basePlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\tif (((obj == null) ? obj2 : obj) == null \u0026\u0026 !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnUserUnbanned(string player?Name ?? \u0022Unnamed\u0022, string text, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "IOnServerUsersRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerUsersRemove\u0022)]\n\tprivate void IOnServerUsersRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string reason)",
    "MethodSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerDisconnected\u0022)]\n\tprivate void OnPlayerDisconnected(BasePlayer basePlayer, string reason)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserDisconnected\u0022, iPlayer, reason);\n\t\t}\n\t\tCovalence.PlayerManager.PlayerDisconnected(basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserBanned(string playerName, string text, string player?Address ?? \u00220\u0022, string reason, ulong expiry)",
    "MethodSignature": "IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, ulong expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerUsersSet\u0022)]\n\tprivate void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, ulong expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerUnbanned(string player?Name ?? \u0022Unnamed\u0022, ulong steamId, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "IOnServerUsersRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerUsersRemove\u0022)]\n\tprivate void IOnServerUsersRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawned\u0022)]\n\tprivate void OnPlayerRespawned(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserRespawned\u0022, iPlayer);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnNpcTarget(NPCPlayerApex npc, BaseEntity target)",
    "MethodSignature": "IOnNpcTarget(NPCPlayerApex npc, BaseEntity target)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(NPCPlayerApex npc, BaseEntity target)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, npc, target) != null)\n\t\t{\n\t\t\treturn 0f;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnServerCommand(string argCmdFullName, string[] RustCommandSystemExtractArgs)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "IOnServerShutdown()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerShutdown\u0022)]\n\tprivate void IOnServerShutdown()\n\t{\n\t\tInterface.Oxide.CallHook(\u0022OnServerShutdown\u0022);\n\t\tInterface.Oxide.OnShutdown();\n\t\tCovalence.PlayerManager.SavePlayerData();\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanUseUI(BasePlayer player, string json)",
    "MethodSignature": "AddUi(BasePlayer player, string json)",
    "MethodSourseCode": "\n\tpublic static bool AddUi(BasePlayer player, string json)\n\t{\n\t\tif (player?.net != null \u0026\u0026 Interface.CallHook(\u0022CanUseUI\u0022, player, json) == null)\n\t\t{\n\t\t\tCommunityEntity.ServerInstance.ClientRPCEx(new SendInfo\n\t\t\t{\n\t\t\t\tconnection = player.net.connection\n\t\t\t}, null, \u0022AddUI\u0022, json);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDestroyUI(BasePlayer player, string elem)",
    "MethodSignature": "DestroyUi(BasePlayer player, string elem)",
    "MethodSourseCode": "\n\tpublic static bool DestroyUi(BasePlayer player, string elem)\n\t{\n\t\tif (player?.net != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnDestroyUI\u0022, player, elem);\n\t\t\tCommunityEntity.ServerInstance.ClientRPCEx(new SendInfo\n\t\t\t{\n\t\t\t\tconnection = player.net.connection\n\t\t\t}, null, \u0022DestroyUI\u0022, elem);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSignature": "IOnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(BaseNpc npc, BaseEntity target)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, npc, target) != null)\n\t\t{\n\t\t\tnpc.SetFact(BaseNpc.Facts.HasEnemy, 0);\n\t\t\tnpc.SetFact(BaseNpc.Facts.EnemyRange, 3);\n\t\t\tnpc.SetFact(BaseNpc.Facts.AfraidRange, 1);\n\t\t\tnpc.AiContext.EnemyPlayer = null;\n\t\t\tnpc.AiContext.LastEnemyPlayerScore = 0f;\n\t\t\tnpc.playerTargetDecisionStartTime = 0f;\n\t\t\treturn 0f;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnEntityTakeDamage(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBasePlayerAttacked\u0022)]\n\tprivate object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)\n\t{\n\t\tif (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnEntityTakeDamage\u0022, basePlayer, hitInfo) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tisPlayerTakingDamage = true;\n\t\ttry\n\t\t{\n\t\t\tbasePlayer.OnAttacked(hitInfo);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tisPlayerTakingDamage = false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerBanned(string playerName, ulong steamId, string player?Address ?? \u00220\u0022, string reason, ulong expiry)",
    "MethodSignature": "IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, ulong expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerUsersSet\u0022)]\n\tprivate void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, ulong expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnUserApproved(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string reason)",
    "MethodSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerKicked\u0022)]\n\tprivate void OnPlayerKicked(BasePlayer basePlayer, string reason)\n\t{\n\t\tif (basePlayer.IPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserKicked\u0022, basePlayer.IPlayer, reason);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanClientLogin(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 22
  }
]